# Data Structures and Algorithm Analysis in C

## 2017 年 8 月 6 日

### 2.3 要分析的问题 后面的内容

+ 最大的子序列和问题:

  + 给定整数 $A_1, A_2, \ldots, A_N$ (可能有负数), 求 $\sum_{k = i}^{j}A_k$ 的最大值(为方便起见, 如果所有整数均为负数, 则最大子序列和为 0). 
  + 例如: 输入 -2, 11, -4, 13, -5, -2 时, 答案是我20 (从 $A_2$ 到 $A_4$)
  + 解法见下面

+ 运行时间计算: 使用大 $O$ 结果, 有以下法则

  + 法则一: (FOR 循环)

    + 一次 for 循环的运行时间至多是该 for 循环内语句 (包括测试) 的运行时间乘以迭代次数.

  + 法则二: 嵌套 for 循环

    + 从里向外分析这些循环. 在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的 for 循环的大小的乘积.

  + 法则三: 顺序语句

    + 将各个语句的运行时间求和即可

  + 法则四: IF/ELSE 语句

    + 对于程序片段

      ```cpp
      if (Condition)
        S1
      else
        S2
      ```

      一个 if/else 语句的运行时间从不超过 Condition 再加上 S1 和 S2 中运行时间长者的总的运行时间.

+ 对于递归过程, 比如

  ```cpp
  long int
  Factorial(int N) {
    if (N <= 1)
      return 1;
    else
      return N * Factorial(N - 1);
  }
  ```

  + 上面这个例子实际上就是一个简单的 for 循环, 从而运行时间为 $O(N)$
  + **这个例子中对递归的使用实际上并不好. 当递归被正常使用时, 将其转换为一个简单的循环结构是相当困难的.**

  而下面这个斐波拉切的例子, 实际上对递归的使用的效率低得令人诧异:

  ```cpp
  long int
  Fib(int N) {
    if (N <= 1) /*1*/
      return 1;   /*2*/
    else
      return Fib(N - 1) + Fib(N - 2);/*3*/
  }
  ```

  + 对其进行运行时间的分析, 令 $T(N)$ 为函数 $F(N)$ 的运行时间, 那么当 $N = 0$ 或 $N = 1$ 时, 运行时间是某个常数, 我们设 $T(0) = T(1) = 1$. 如果 $N > 2$, 则 $T(N) = T(N - 1) + T(N - 2) + 2$, 其中 "2" 值得是第一行上的工作加上第三行上的加法. 可以证明 $T(N)\geq Fib(N)$, 以及 $Fib(N)\geq(\frac{3}{2})^N$ (N > 4). 这个程序的运行时间是以指数增长的.
  + 这个程序之所以慢, 是因为存在大量多余的工作要做. 违反了前面说过的递归的第四条主要的法则(**合成效益法则**). 注意到调用 `Fib(N - 1)` 时实际上计算了 `Fib(N - 2)`. 最后 `Fib(N - 2)` 被计算了两次.

+ 下面介绍最大子序列和问题的解

+ 分治(divide-and-conque)策略: 其想法是把问题分成两个大致相等的子问题, 然后递归地对它们求解, 这是 "分" 的部分. "治" 的阶段将两个子问题的解合并到一起并可能再做些少量的附加工作, 最后得到整个问题的解.



## 2017 年 8 月 3 日

先对带噪图像缩放, (缩放倍数待定,) 然后使用训练好的去噪网络进行去噪, 之后使用超分辨率网络进行放大...

### 前言

+ 作者说道: 我相信对递归做到泰然处之的唯一方法就是反复不断地看一些好的用法.


+ 选择问题: 设有一组 N 个数而要确定其中第 k 个最大者.
+ 递归: 当一个函数用它自己来定义时就称为递归. 递归的法则
  + 基准情形: 不要递归就能求解
  + 不断推进: 对于那些需要递归求解的情形, 递归调用必须总能够朝着产生基准情形的方向推进.
  + 设计法则: 假设所有的递归调用都能运行. 这很重要, 因为它意味着在设计递归程序时一般没有必要知道内存管理的细节, 不必试图追踪大量递归调用.追踪实际的递归调用序列常常是非常困难的.
  + 合成效益法则: 在求解一个问题的同一实例时, 切勿在不同的递归调用中做重复性的工作.
+ 算法: 算法是为求解一个问题需要遵循的, 被清楚指定的简单指令的集合.
  + 对于一个问题, 一旦给定某种算法并且以某种方式确定其是正确的, 那么重要的一步就是确定该算法将需要多少时间或空间等资源量的问题.
+ 数学基础
  + 定义1: 如果存在正常数 $c$ 和 $n_0$ 使得当 $N\geq n_0$ 时 $T(N)\leq cf(N)$, 则记为 $T(N) = O(f(N))$.
  + 定义2: 如果存在正常数 $c$ 和 $n_0$ 使得当 $N\geq n_0$ 时 $T(N)\geq cg(N)$, 则记为 $T(N) = \Omega(g(N))$.
  + 定义3: $T(N) = \Theta(h(N))$ 当且仅当 $T(N) = O(h(N))$ 且 $T(N) = \Omega(h(N))$.
  + 定义4: 如果 $T(N) = O(p(N))$ 且 $T(N)\neq \Theta(p(N))$, 则 $T(N) = o(p(N))$.
  + 这些定义的目的是要在函数之间建立一种相对的级别. 单纯地使用 $f(N) < g(N)$ 是没有什么意义的, 于是, 我们比较它们的相对增长率.
  + 比如, 虽然 $N$ 较小时, $1000N$ 要比 $N^2$ 大, 但 $N^2$ 以更快的速度增长, 因此 $N^2$ 最终将更大. 在这种情况下, $N = 1000$ 是转折点. 第一个定义是说, 最后总会存在某个点 $n_0$, 从它以后 $c\cdot f(N)$ 总是至少与 $T(N)$ 一样大, 从而若忽略常数因子, 则 $f(N)$ 至少与 $T(N)$ 一样大. 在该例中, $T(N)=1000N, f(N)=N^2, n_0 = 1000, c = 1$,因此我们可以说 $1000N=O(N^2)$, 这种记法称为大 $O$　记法．
  + 第一个定义是说 $T(N)$ 的增长率小于等于 $f(N)$ 的增长率. 第二个定义是说 $T(N)$ 的增长率大于等于 $g(N)$ 的增长率. 第三个定义是说 $T(N)$ 的增长率等于 $h(N)$ 的增长率. 最后一个定义是说 $T(N)$ 的增长率小于 $g(N)$ 的增长率. 它不同于大 $O$, 因为大 $O$ 包含增长率相同这种可能．
  + 当我们说 $T(N)=O(f(N))$ 时，我们是在保证函数 $T(N)$ 是在以不快于 $f(N)$ 的速度增长, 因此 $f(N)$ 是 $T(N)$ 的一个上界.
+ 我们需要掌握的重要结论是:
  + 法则一: 如果 $T_1(N) = O(f(N))$ 且 $T_2(N) = O(g(N))$, 那么
    + $T_1(N) + T_2(N) = \max(O(f(N)), O(g(N)))$,
    + $T_1(N) + T_2(N) = O(f(N) * g(N))$
  + 法则二: 如果 $T(N)$ 是一个 k 次多项式, 则 $T(N) = \Theta(N^k)$
  + 法则三: 对任意常数 k, $\log^k N = O(N)$. 它告诉我们对数增长得非常缓慢.

### 习题

+ 习题 1.8: $2^{100}(mod 5)$ 是多少? 
  + 答案是 1. 虽然有简{洁的解法, 比如有人直接想到 $2^4=16\equiv 1(mod 5)$, 然后直接使用 $(2^4)^{25}\equiv 1^{25}(mod 5)$, 就可以得到答案是 1.
  + 但是这里也考虑下我等凡人的思路, 我这样考虑, $5 = 1 + 2^2$, 而 $2^{100} - 1 = 1 + 2^1 + 2^2 + 2^3 + \ldots + 2^{99}$, 又因为 $(1 + 2^2) + (2^1 + 2^3)$ 刚好能整除 5, 那么最后 $2^{33}(1 + 2^1 + 2^2 + 2^3)$ 也能整除 5, 因此, $2^{100} - 1$ 能整除 5, 所以 $2^{100}(mod 5)$ 的结果为 1.