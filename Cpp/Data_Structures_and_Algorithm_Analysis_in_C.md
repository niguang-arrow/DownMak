# Data Structures and Algorithm Analysis in C

## 2017 年 8 月 3 日

先对带噪图像缩放, (缩放倍数待定,) 然后使用训练好的去噪网络进行去噪, 之后使用超分辨率网络进行放大...

### 前言

+ 作者说道: 我相信对递归做到泰然处之的唯一方法就是反复不断地看一些好的用法.


+ 选择问题: 设有一组 N 个数而要确定其中第 k 个最大者.
+ 递归: 当一个函数用它自己来定义时就称为递归. 递归的法则
  + 基准情形: 不要递归就能求解
  + 不断推进: 对于那些需要递归求解的情形, 递归调用必须总能够朝着产生基准情形的方向推进.
  + 设计法则: 假设所有的递归调用都能运行. 这很重要, 因为它意味着在设计递归程序时一般没有必要知道内存管理的细节, 不必试图追踪大量递归调用.追踪实际的递归调用序列常常是非常困难的.
  + 合成效益法则: 在求解一个问题的同一实例时, 切勿在不同的递归调用中做重复性的工作.
+ 算法: 算法是为求解一个问题需要遵循的, 被清楚指定的简单指令的集合.
  + 对于一个问题, 一旦给定某种算法并且以某种方式确定其是正确的, 那么重要的一步就是确定该算法将需要多少时间或空间等资源量的问题.
+ 数学基础
  + 定义1: 如果存在正常数 $c$ 和 $n_0$ 使得当 $N\geq n_0$ 时 $T(N)\leq cf(N)$, 则记为 $T(N) = O(f(N))$.
  + 定义2: 如果存在正常数 $c$ 和 $n_0$ 使得当 $N\geq n_0$ 时 $T(N)\geq cg(N)$, 则记为 $T(N) = \Omega(g(N))$.
  + 定义3: $T(N) = \Theta(h(N))$ 当且仅当 $T(N) = O(h(N))$ 且 $T(N) = \Omega(h(N))$.
  + 定义4: 如果 $T(N) = O(p(N))$ 且 $T(N)\neq \Theta(p(N))$, 则 $T(N) = o(p(N))$.
  + 这些定义的目的是要在函数之间建立一种相对的级别. 单纯地使用 $f(N) < g(N)$ 是没有什么意义的, 于是, 我们比较它们的相对增长率.
  + 比如, 虽然 $N$ 较小时, $1000N$ 要比 $N^2$ 大, 但 $N^2$ 以更快的速度增长, 因此 $N^2$ 最终将更大. 在这种情况下, $N = 1000$ 是转折点. 第一个定义是说, 最后总会存在某个点 $n_0$, 从它以后 $c\cdot f(N)$ 总是至少与 $T(N)$ 一样大, 从而若忽略常数因子, 则 $f(N)$ 至少与 $T(N)$ 一样大. 在该例中, $T(N)=1000N, f(N)=N^2, n_0 = 1000, c = 1$,因此我们可以说 $1000N=O(N^2)$, 这种记法称为大 $O$　记法．
  + 第一个定义是说 $T(N)$ 的增长率小于等于 $f(N)$ 的增长率. 第二个定义是说 $T(N)$ 的增长率大于等于 $g(N)$ 的增长率. 第三个定义是说 $T(N)$ 的增长率等于 $h(N)$ 的增长率. 最后一个定义是说 $T(N)$ 的增长率小于 $g(N)$ 的增长率. 它不同于大 $O$, 因为大 $O$ 包含增长率相同这种可能．
  + 当我们说 $T(N)=O(f(N))$ 时，我们是在保证函数 $T(N)$ 是在以不快于 $f(N)$ 的速度增长, 因此 $f(N)$ 是 $T(N)$ 的一个上界.
+ 我们需要掌握的重要结论是:
  + 法则一: 如果 $T_1(N) = O(f(N))$ 且 $T_2(N) = O(g(N))$, 那么
    + $T_1(N) + T_2(N) = \max(O(f(N)), O(g(N)))$,
    + $T_1(N) + T_2(N) = O(f(N) * g(N))$
  + 法则二: 如果 $T(N)$ 是一个 k 次多项式, 则 $T(N) = \Theta(N^k)$
  + 法则三: 对任意常数 k, $\log^k N = O(N)$. 它告诉我们对数增长得非常缓慢.

### 习题

+ 习题 1.8: $2^{100}(mod 5)$ 是多少? 
  + 答案是 1. 虽然有简{洁的解法, 比如有人直接想到 $2^4=16\equiv 1(mod 5)$, 然后直接使用 $(2^4)^{25}\equiv 1^{25}(mod 5)$, 就可以得到答案是 1.
  + 但是这里也考虑下我等凡人的思路, 我这样考虑, $5 = 1 + 2^2$, 而 $2^{100} - 1 = 1 + 2^1 + 2^2 + 2^3 + \ldots + 2^{99}$, 又因为 $(1 + 2^2) + (2^1 + 2^3)$ 刚好能整除 5, 那么最后 $2^{33}(1 + 2^1 + 2^2 + 2^3)$ 也能整除 5, 因此, $2^{100} - 1$ 能整除 5, 所以 $2^{100}(mod 5)$ 的结果为 1.