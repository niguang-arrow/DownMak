# Unix 实践

## 2017 年 11 月 6 日

+   只有内核才能直接管理设备(比如键盘,磁盘, 屏幕以及打印机等), 因此, 如果程序要从键盘得到数据, 需要向内核发出请求. 程序中所有对设备的操作都是通过内核进行的.
+   编写普通程序时可以认为, 程序是直接连接到键盘, 显示器等设备的, 但是进行系统编程时, 必须对系统的结构和工作方式有更深的了解, 要知道内核提供了哪些服务(系统调用), 如何使用它们, 系统有哪些资源和设备, 不同的资源和设备该如何操作.

### 系统资源

+   处理器
+   输入输出
+   进程管理
+   内存
+   设备
+   计时器
+   进程间通信
+   网络

### 登录

+   在登录过程中, 当用户名和密码通过验证后, 系统会启动一个叫 shell 的进程, 然后把用户交给这个进程, 由这个进程处理用户请求. 每个用户都有属于自己的 shell 进程.
+   用户操作的终端有很多参数, 可以调整参数使得用户输入的字符被立即送到程序, 而不是等待回车, 还可以使输入的字符不回显.



### 编写 who 命令

+   打开文件是内核提供的服务, 如果在打开过程中内核检测到任何错误, 这个系统调用就会返回 -1.
+   打开文件会建立进程和文件之间的连接, 文件描述法就是用来唯一标识这个连接的, 如果将一个文件打开多次, 对应的文件描述符也不相同.
+   close 这个系统调用会关闭进程和文件 fd 之间的连接.



### 内核缓冲技术

+   应用缓冲技术对提高系统的效率是很明显的, 它的主要思想是一次读入大量的数据放入缓冲区, 需要的时候从缓冲区取得数据.
+   用户进程位于用户空间, 内核位于系统空间, 磁盘只能被内核直接访问. 当使用系统调用时, 执行权会从用户代码转移到内核代码, 执行内核代码是需要时间的. 系统调用的开销大不仅仅是因为要传输数据, 当运行内核代码时, CPU 工作在管理员模式下, 这对应于一些特殊的堆栈和内存环境, 必须在系统调用发生时建立好. 系统调用结束后, CPU 要切换到用户模式, 必须把堆栈和内存环境恢复成用户程序运行时的状态, 这种运行环境的切换要消耗很多时间.
+   当工作在管理员模式下, 程序可以直接访问磁盘, 终端, 打印机等设备, 还可以访问全部的内存空间, 而在用户模式下, 程序不能直接访问设备, 也只能访问特定部分的内存空间. 在运行时刻, 系统会根据需要不断地在两种模式间切换.
+   管理员模式和用户模式之间的切换需要消耗时间, 相比之下, 磁盘的 I/O 操作消耗的时间更多, 为了提高效率, 内核也使用缓冲技术来提高对磁盘的访问速度.
+   内核将磁盘上的数据块复制到内核缓冲区中, 当一个用户空间中的进程要从磁盘上读数据时, 内核一般不直接读磁盘,  而是将内核缓冲区中的数据复制到进程的缓冲区中. 
+   **更为详细的介绍看 74 页(书 54 页)**.
+   当系统调用出错时会把全局变量 errno 的值设为相应的错误代码, 然后返回 -1, 程序可以通过检查 errno 来确定错误的类型, 并采取相关的措施.

























