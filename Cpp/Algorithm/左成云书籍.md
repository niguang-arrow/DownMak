# 程序员代码面试指南

2018 年 3 月 9 日

[TOC]

## 栈和队列

### 设计一个有 getMin 功能的栈

思路是使用两个栈, stackData 用于数据的保存, 而 stackMin 的栈顶始终保存 stackData 中的最小值. stackMin 和 stackData 中的数据始终是一样的. 一开始将 d1 push 进 stackData 时, 由于 stackMin 中也没有数据, 那么两个栈都直接 push d1. 然后 push d2, stackData 可以直接 push, 但是此时要判断 d2 和 stackMin 栈顶元素的大小, 如果 d2 <= d1, 那么将 d2 也 push 进 stackMin; 否则即 d2 > d1, 此时 stackMin 要将栈顶元素 d1 复制一份再 push 进 stackMin.

```cpp
// 左成云: 1. 设计一个有 getMin 功能的栈
#include <iostream>
#include <stack>
#include <initializer_list>

using namespace std;

// 定义一个可以返回最小值的栈 getMin
// 思路是使用两个栈, stackData 用于数据的保存, 而 stackMin
// 用于保存数据中的最小值
template <typename T>
class Stack {
private:
    stack<T> stackData;
    stack<T> stackMin;

public:
    Stack() {}
    Stack(initializer_list<T> ls) {
        for (const auto &d : ls)
            push(d);
    }
    ~Stack() {}
    void push(const T &data) {
        stackData.push(data);
        if (stackMin.empty())
            stackMin.push(data);
        else if (data <= stackMin.top())
            stackMin.push(data);
        else
            stackMin.push(stackMin.top());
    }

    void pop() {
        stackData.pop();
        stackMin.pop();
    }

    T top() const {
        return stackData.top();
    }

    T getMin() const {
        return stackMin.top();
    }

    bool empty() const {
        return stackData.empty();
    }
};


int main() {
    Stack<int> stk = {3, 4, 5, 1, 2, 1};
    while (!stk.empty()) {
        cout << "pop data: " << stk.top() << endl;
        cout << "min : " << stk.getMin() << endl;
        stk.pop();
    }

    return 0;
}
```



### 由两个栈组成的队列

栈是先进后出, 队列是先进先出, 当向 stack1 中 push 元素时, 不需要额外的操作; 主要是当队列中取出元素的时候, 需要用到 stack2. 首先要判断 stack2 是否为空, 如果为空, 那么就要将 stack1 中的数据依次 push 到 stack2 中, 这个时候, stack2 栈顶的元素就是一开始在 stack1 的栈底的元素, 那么此时, 在 stack2 中的元素, 从栈顶到栈底, 元素的顺序和一开始 push 到 stack1 中是相反的, 只要将 stack2 中栈顶元素给 pop 出来, 就能实现先进先出.

```cpp
// 左成云: 2. 由两个栈组成的队列
#include <iostream>
#include <stack>
#include <initializer_list>

using namespace std;

template <typename T>
class Queue {
private:
    stack<T> stack1;
    stack<T> stack2;
public:
    Queue() {}
    ~Queue() {}
    Queue(initializer_list<T> ls) {
        for (const auto &d : ls)
            push(d);
    }

    void push(T data) {
        stack1.push(data);
    }

    void pop() {
        // 这里先判断 stack2 是否为空, 如果为空, 那么只需要将 stack1 中的
        // 元素入栈 stack2. 但也有可以 stack1 也是为空的, 此时直接执行
        // stack2.pop(), 异常检测由标准库去做.
        if (stack2.empty()) {
            while (!stack1.empty()) {
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        stack2.pop();
    }

    // 这里 top 不要实现为 const 的, 要修改 stack1 和 stack2
    T top() {
        if (stack2.empty()) {
            while (!stack1.empty()) {
                stack2.push(stack1.top());
                stack1.pop();
            }
        }

        return stack2.top();
    }

    bool empty() const {
        return (stack1.empty() && stack2.empty());
    }

    int size() const {
        return (stack1.size() + stack2.size());
    }
};


int main() {
    Queue<int> myque = {1, 2, 3, 4, 5};

    while (!myque.empty()) { 
        cout << myque.top() << " ";
        myque.pop();
    }
    cout << endl;
}
```



### 如何仅用递归函数和栈操作逆序一个栈

要实现两个递归函数, 其中 `getLastElement` 每次返回栈顶的元素, reverse 函数中用到 `getLastElement` 函数实现对栈的翻转. 代码具体的含义不好描述, 如果画出递归的调用图会非常好理解, 所以应该多看书上第 9 页的图 1-4 和 1-5.

```cpp
// 左成云: 3. 如何仅用递归函数和栈操作逆序一个栈
#include <iostream>
#include <stack>

using namespace std;

int getLastElement(stack<int> &stk) {
    int result = stk.top();
    stk.pop();

    if (stk.empty())
        return result;
    else {
        int last = getLastElement(stk);
        stk.push(result);
        return last;
    }
}

void reverse(stack<int> &stk) {
    if (stk.empty())
        return;

    int i = getLastElement(stk);
    reverse(stk);
    stk.push(i);
}

int main() {

    stack<int> sta({1, 3, 4, 5});
    reverse(sta);
    while (!sta.empty()) {
        cout << sta.top() << " ";
        sta.pop();
    }
    cout << endl;
    return 0;
}
```

 

### 用一个栈实现另一个栈的排序

目标是将该栈中的元素从顶到底按从大到小的顺序排序. 但是只允许使用一个栈, 而不能使用其他的数据结构, 当然还可以申请其他的变量.

思路是, 比如要排序 stack1 中的元素, 那么使用名为 help 的辅助栈, 用 cur 表示当前 stack1 中弹出的栈顶的元素.

如果 cur 小于或等于 help 中栈顶的元素, 那么就将 cur 直接 push 到 help 的栈顶.

如果 cur 大于 help 中栈顶的元素, 那么以此将 help 中的元素弹出至 stack1 中, 直到 cur 小于或等于 help 栈顶的元素, 此时再将 cur push 到 help 中. 重复以上操作, 可以保证 help 中的元素从栈顶到栈底依次是从小到大排列的. 最后将 help 中的数据依次 push 入 stack1 中, 已达到目的.

```cpp
// 左成云: 5. 用一个栈实现另一个栈的排序
#include <iostream>
#include <stack>
using namespace std;

void makeStackSort(stack<int> &sta) {
    stack<int> help;

    while (!sta.empty()) {
        int cur = sta.top();
        sta.pop();

        while (!help.empty() && help.top() < cur) {
            sta.push(help.top());
            help.pop();
        }
        help.push(cur);
    }

    while (!help.empty()) {
        sta.push(help.top());
        help.pop();
    }
}


int main() {
    stack<int> sta({3, 1, 6, 4});
    makeStackSort(sta);
    while (!sta.empty()) {
        cout << sta.top() << " ";
        sta.pop();
    }
    cout << endl;
}
```



























