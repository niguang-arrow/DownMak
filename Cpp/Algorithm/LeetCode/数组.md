# Array

[TOC]

## 数组

### 287. **Find the Duplicate Number

https://leetcode.com/problems/find-the-duplicate-number/description/

表面上这道题标定的是 medium, 实际上要想出来太难... 

先给出关于这道题比较清晰的参考:

[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/solution/) leetcode 的官方解答

[leetcode笔记：Find the Duplicate Number](https://blog.csdn.net/liyuefeilong/article/details/50719741)

[Find the Duplicate Number 找到重复数字](https://segmentfault.com/a/1190000003817671)

[Find the Duplicate Number](http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/) 牛人博客, LeetCode 有六百多题的解答.

题目的大意是，给定一个包含`n + 1`个整数的数组，其中每一个整数的大小均在`[1, n]`之间，证明其中至少有一个重复元素存在。同时假设数组中只有一个数字出现重复，找出这个重复的数字。

注意事项：

- 不可以修改数组（假设数组是只读的）
- 只能使用常数空间
- 运行时间复杂度应该小于`O(n^2)`
- 数组中只存在一个重复数，但是该数可能重复多次



思路: 首先, 使用鸽笼(抽屉)原理可以证明, 这 n + 1 个数字中必然有重复数字. 可以将 n + 1 个位置想象成 n + 1 双袜子, 1 ~ n 这 n 个数相当于抽屉, 要让 n + 1 双袜子放到 n 个抽屉中, 必然有一个抽屉要放置两双袜子, 翻译过来就是数组中至少有两个位置要取相同的数.

```bash
解决本题需要的主要技巧就是要注意到：由于数组的n + 1个元素范围从1到n，我们可以将数组考虑成一个从集合{1, 2, ..., n}到其本身(即集合本身)的函数f。这个函数的定义为f(i) = A[i]。基于这个设定，重复元素对应于一对下标 i != j 满足 f(i) = f(j)。我们的任务就变成了寻找一对(i, j)。一旦我们找到这个值对，只需通过f(i) = A[i] 即可获得重复元素。这变成了计算机科学界一个广为人知的“环检测”问题。

由于数组元素范围1到n，不存在值为 0 的元素, 因此环的形状必然是 P 型的:
                x_0 -> x_1 -> ... x_k -> x_{k+1} ... -> x_{k+j}
                                    ^                       |
                                    |                       |
                                    +-----------------------+
由Robert Floyd提出的一个著名算法，给定一个ρ型序列，在线性时间，只使用常数空间寻找环的起点。这个算法经常被称为“龟兔”算法.                                    
```

当我看完 [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/) 的解法后(这道检测链表中环的问题的解答可以参考 Gitbooks : [Linked List Cycle](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/)), 再来解决这道题就轻松很多.

为了用检测链表环的思路来解决这道题, 我们可以发现, 比如对于序列 `{3, 1, 2, 3, 4}`, 可以得到如下链表:

```bash
0  ->  3  -> 
	   |___|	   
```

也就是说, 存在 `(i, j)` 为 `(0, 3)`, 使得 `f[0] == f[3] == 3`. 所以环是索引 3, 而值是 `f[3] = 3`. (举出这个例子是想说明, 当存在环时, 后面的 2, 4 之类的值也许不会访问到).

那检测链表中的环, 思路是设置快慢指针 (fast 与 slow), fast 每次移动两步, 而 slow 每次移动一步, 当 fast 和 slow 重合时(除了起始的时候), 说明链表中存在环, 而要找到环的位置, 详情见:

Gitbooks : [Linked List Cycle](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/) 摘录下来:

譬如下面这个，环的起点就是n2。

```bash
        n6-----------n5
        |            |
  n1--- n2---n3--- n4|
```

我们仍然可以使用两个指针fast和slow，fast走两步，slow走一步，判断是否有环，当有环重合之后，譬如上面在n5重合了，那么如何得到n2呢？

首先我们知道，fast每次比slow多走一步，所以重合的时候，fast移动的距离是slot的两倍，我们假设n1到n2距离为a，n2到n5距离为b，n5到n2距离为c，fast走动距离为`a + b + c + b`，而slow为`a + b`，有方程`a + b + c + b = 2 x (a + b)`，可以知道`a = c`，所以我们只需要在重合之后，一个指针从n1，而另一个指针从n5，都每次走一步，那么就可以在n2重合了。

综上, 代码为: 注意初始的情况

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
      	// 初始的时候, slow 和 fast 都应该是 nums[0] 的, 但由于这里使用的是 
      	// while 循环而不是 do...while, 所以 slow 和 fast 写成了下面的形式,
      	// do...while 的写法参见 leetcode 的官方解答.
      	// 下面先将 fast 移动两格, 而 slow 只移动一格
        int slow = nums[nums[0]], fast = nums[nums[nums[0]]];
        while (fast != slow) {
            fast = nums[nums[fast]];
            slow = nums[slow];
        }
		
      	// 当 fast 和 slow 相遇后, 要开始查找环的入口. 参见上面思路中 n1, n2, 的
      	// 图示, 这里将 fast 指向 n1, 而 slow 目前指向的是 n5, 然后每次让它们移动
      	// 一格, 最终相遇在 n2.
        fast = nums[0];
        while (fast != slow) {
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
};
```



### 142. **Linked List Cycle II

https://leetcode.com/problems/linked-list-cycle-ii/description/

在链表中找环并返回环的节点. 这道题是链表的题, 但由于和上一道 287 Find the Duplicate Number 联系紧密, 所以放在这里.

解析的话就看  [Linked List Cycle](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/) 写得很精彩易懂. (另外看完 287 后, 其实我们知道, 使用龟兔算法来解决此类问题, 要注意这个环是 P 型的)

+ 双指针方法

```bash
链表问题中的一个重要的方法叫双指针法。定义两个指针，一个叫慢指针，另一个叫快指针。通常慢指针每次向前移动一个节点，而快指针每次向前移动若干个节点。这个方法通常用于寻找链表中特定的位置。比如找到链表的中点，可以让快指针每次移动两个节点。这样当快指针到达链表末尾时，慢指针刚好在链表中间的位置。
```

假设环的起点就是n2。

```bash
        n6-----------n5
        |            |
  n1--- n2---n3--- n4|
```

我们仍然可以使用两个指针fast和slow，fast走两步，slow走一步，判断是否有环，当有环重合之后，譬如上面在n5重合了，那么如何得到n2呢？

首先我们知道，fast每次比slow多走一步，所以重合的时候，fast移动的距离是slot的两倍，我们假设n1到n2距离为a，n2到n5距离为b，n5到n2距离为c，fast走动距离为`a + b + c + b`，而slow为`a + b`，有方程`a + b + c + b = 2 x (a + b)`，可以知道`a = c`，所以我们只需要在重合之后，一个指针从n1，而另一个指针从n5，都每次走一步，那么就可以在n2重合了。

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head || !head->next)
            return nullptr;

        ListNode *fast = head;
        ListNode *slow = head;

        // 首先判断是否存在环
        while (fast->next && fast->next->next) {
            fast = fast->next->next;
            slow = slow->next;
            // 如果存在环, 那么开始找环
            if (fast == slow) {
                fast = head;
                while (fast != slow) {
                    fast = fast->next;
                    slow = slow->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
};
```



### 448. *Find All Numbers Disappeared in an Array

https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/

感觉这道题像智力题. 这是一道很好的题目; 非常巧妙.

Given an array of integers where 1 ≤ a[i] ≤ *n* (*n* = size of array), some elements appear twice and others appear once.

Find all the elements of [1, *n*] inclusive that do not appear in this array.

Could you do it without extra space and in O(*n*) runtime? You may assume the returned list does not count as extra space.

**Example:**

```bash
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
```



思路: **看到类似这种数组中的元素的值限定在 1 ~ N 之间的, 可能就可以考虑使用将元素值作为索引的方法...** 由于每个元素值的大小都是 `1 <= a[i] <= N`, 那么访问 `a[a[i] - 1]` 是没有问题的. 考虑上面这个数组:

```bash
# 假设数组的索引从 1 开始
index : 1   2   3   4   5   6   7   8
value : 4   3   2   7   8   2   3   1
```

现在从索引 1 开始, 如果依次将 `a[abs(a[i])]` 的值改为负数, 但如果 `a[abs(a[i])]` 已经是负数了, 那么就不用修改了.

```bash
# 假设数组的索引从 1 开始
index :  1    2    3     4   5   6     7    8
value : -4   -3   -2    -7   8   2    -3   -1
```

可以看到只有 `{5, 6}` 处的元素依然是正数, 那么消失的数字就是 `{5, 6}`. 由于下面的代码中索引从 0 开始, 所以最后要加 1.

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for (auto &d : nums)
            if (nums[abs(d) - 1] > 0)
                nums[abs(d) - 1] = -nums[abs(d) - 1];
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i)
            if (nums[i] > 0)
                res.push_back(i + 1);
        return res;
    }
};
```



leetcode 上的解答:

[Java accepted simple solution](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution)

The basic idea is that we iterate through the input array and mark elements as negative using `nums[nums[i] -1] = -nums[nums[i]-1]`. In this way all the numbers that we have seen will be marked as negative. In the second iteration, if a value is not marked as negative, it implies we have never seen that index before, so just add it to the return list.

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> ret = new ArrayList<Integer>();
        
        for(int i = 0; i < nums.length; i++) {
            int val = Math.abs(nums[i]) - 1;
            if(nums[val] > 0) {
                nums[val] = -nums[val];
            }
        }
        
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] > 0) {
                ret.add(i+1);
            }
        }
        return ret;
    }
```

最为关键的是下面的解释:

大致意思可以理解为, 对于 nums 中的每个元素, 将 nums[i] - 1 对应的那个元素设置为负值, 表示那个元素已经被访问过, 之后判断 nums 中哪些值为正的, 如果为正, 说明对应的索引 i + 1 不存在在 nums 中.

https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution/97460

A more detailed explanation for those who might still be confused:

This solution is using the relation between array index ([0, n-1]) and the given value range [1,n].

Each time when a new value X is read, it changes the corresponding Xth number (value at index X-1) into negative, indicating value X is read for the first time.
For example. using the given test case [4,3,2,7,8,2,3,1], when it comes to i = 2 in the first loop, this solution marks the 2nd number (index = 1), indicating we’ve found number 2 for the first time.

When we encounter a redundant number Y, because we’ve marked the Yth position (index Y -1) when we saw Y for the first time, the if clause won’t let us flip it again. This leaves the already marked Yth number (number at index Y-1) negative.
For example, in the given test case, when i = 5, val = |2| - 1 = 1, nums[1] = -3 < 0. No flip operation is needed because we’ve found value 2 before.

Looping through the 1st loop takes O(n) time, flipping signs won’t take extra space.

The second loop checks the signs of the values at indices. If the sign at index P is negative, it means value P + 1 is in the array. e.g. nums[0] = -4, so value 0+1 = 1 is in the array. If the value at index Q is positive, then value Q + 1 is not in the array. e.g. nums[4] = 8 > 0, value 4 + 1 = 5, we add 5 into the ret list.



### 442. **Find All Duplicates in an Array

https://leetcode.com/problems/find-all-duplicates-in-an-array/description/

找出数组中所有的重复数字. 这道题可以认为承接上题 448. Find All Numbers Disappeared in an Array.

Given an array of integers, 1 ≤ a[i] ≤ *n* (*n* = size of array), some elements appear **twice** and others appear **once**.

Find all the elements that appear **twice** in this array.

Could you do it without extra space and in O(*n*) runtime?

**Example:**

```bash
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
```



思路: 参考 448. Find All Numbers Disappeared in an Array 这道题的笔记, 注意到数组中的元素的范围在 1 ~ N, 所以, 可以考虑使用将 `nums[nums[i] - 1]` 的值设置为负数的做法. 

考虑上面这个数组:

```bash
# 假设数组的索引从 1 开始
index : 1   2   3   4   5   6   7   8
value : 4   3   2   7   8   2   3   1
```

现在从索引 1 开始, 如果依次将 `a[abs(a[i])]` 的值改为负数, 但如果 `a[abs(a[i])]` 已经是负数了, 那么就不用修改了. 当 index = 6 时, 问题就出现了, 下图用 `|6|` 标注出来了.

```bash
# 假设数组的索引从 1 开始
index :  1    2    3     4   5  |6|     7    8
value :  4   -3   -2    -7   8   2     -3   -1
```

因为此时 `nums[nums[6]]` 即 `nums[2]` 已经是负数了, 另外可以观察到如果 index 进行到 7 的时候, `nums[nums[7]]` 即 `nums[3]` 的值也是负数, 而 2, 3 就是我们要找的重复数字, 我们便意识到, 如果当 `nums[abs(nums[i])]` 已经是负数了, 我们就需要把 `abs(nums[i])` 给记录下来, 因为它就是重复数字.

```cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[abs(nums[i]) - 1] > 0) 
                // 不要使用乘法, 直接写成负数的形式提高性能.
                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1];
            else
                res.push_back(abs(nums[i]));
        }
        return res;
    }
};
```



### 645. *Set Mismatch

https://leetcode.com/problems/set-mismatch/description/

The set `S` originally contains numbers from 1 to `n`. But unfortunately, due to the data error, one of the numbers in the set got duplicated to **another** number in the set, which results in repetition of one number and loss of another number.

Given an array `nums` representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.

**Example 1:**

```bash
Input: nums = [1,2,2,4]
Output: [2,3]
```

**Note:**

1. The given array size will in the range [2, 10000].
2. The given array's numbers won't have any order.

思路: 可以使用 442. Find All Duplicates in an Array 中的解法, 将 `nums[abs(nums[i]) - 1]` 中的元素设置为负数, 如果这个值本身就是负数, 那么说明 `abs(nums[i])` 就是重复元素. 而要求缺失的元素, 可以使用求和的方式. 

另外注意代码中判断 res 是否为空, 如果测试用例是 `[1, 2]`, 那么就没有重复值, 结果应该返回空.

```cpp
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int n = nums.size();
        int a = std::accumulate(nums.begin(), nums.end(), 0);
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[abs(nums[i]) - 1] > 0)
                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1];
            else {
                res = {abs(nums[i])};
                break;
            }
        }
        if (res.empty()) // 说明没有找到重复元素.
            return res;
        int num = (n + 1) * n / 2 - (a - res.back());
        res.push_back(num);
        return res;
    }
};
```

leetcode 的讨论区还有一种思路: (原因没有想明白... 应该要举例子然后找规律...)

[Java O(n) Time O(1) Space](https://leetcode.com/problems/set-mismatch/discuss/105507/Java-O(n)-Time-O(1)-Space)

```java
public static int[] findErrorNums(int[] nums) {
    int[] res = new int[2];
    for (int i : nums) {
        if (nums[Math.abs(i) - 1] < 0) res[0] = Math.abs(i);
	else nums[Math.abs(i) - 1] *= -1;
    }
    for (int i=0;i<nums.length;i++) {
        if (nums[i] > 0) res[1] = i+1;
    }
    return res;
}
```





### 283. *Move Zeros

https://leetcode.com/problems/move-zeroes/

(刚刚发现 283, 27, 26, 80 这四题其实是同一类型的题, 都是将元素从数组中删除)

将数组中的 0 都挪到数组的尾部, 并且保持原来非零元素在数组中的顺序.

思路是: 要引入一个索引 k 来使得 `nums[0....k]` 范围内的元素原数组中大于零的值, `nums[k+1...n-1]` 范围内的值等于零. 对于当前访问的元素 `nums[i]` 来说, 如果它等于零, 我们只要访问下一个元素即可. 而当 `nums[i]` 不等于 0 时, 只要和 `nums[k + 1]` 交换即可.(我明白了, 到这里可以得到这样的结论, 比如我明确了 `nums[0...k]` 的意义, 那么后面的操作就是很正常了)

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if (nums.empty())
            return;

        // arr[0...k] 保存所有非零元素
      	// 初始为 -1 说明 arr[0, k] 中无元素. 如果初始化为 0, 
      	// 那么下面使用 nums[k++]
        int k = -1; 
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != 0) {
                if (i != (k + 1))
                    swap(nums[i], nums[++k]);
                else
                    ++k;
            }
        }
    }
};
```



### 27. *Remove Element

https://leetcode.com/problems/remove-element/description/

将数组中等于 val 的所有元素给删除(移到数组末尾), 并返回其他非 val 元素的长度.

思路: 其实这道题就是 283. move zeros 的变形, 只不过前面是将 0 移到末尾, 这里是将 val 移到末尾.

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if (nums.empty())
            return nums.size();

        // arr[0...k] 保存不等于 val 的元素
        int k = -1;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != val) {
                if (i != (k + 1))
                    swap(nums[i], nums[++k]);
                else
                    ++k;
            }
        }
        return k + 1;
    }
};
```



### 26. *Remove Duplicates from Sorted Array

https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/

将排序数组中的重复数字给去除, 并返回新数组的长度. 注意只能原地修改数组, 使用 O(1) 的额外空间.

思路: 其实和 283. Move Zeros 的思路一致, 要使用两个下标, 一个下标 i 用于遍历数组, 另一个下标 k 用于记录不重复数组的范围, 比如下面的代码中, 我令 `arr[0....k]` 范围内的元素是不重复的. 这样的话, 访问到当前元素 `arr[i]` 时, 就得和 `arr[k]` 进行比较, 如果等于 `arr[k]` 的话, 说明是重复的, 因此只需遍历下一个元素; 而如果当前元素与 `arr[k]` 不相等, 那么就使 `arr[k+1] = arr[i]`, 并且 k 要移动到下一位.

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
            if (nums.empty())
                return 0;

            int k = 0;
            // nums[0, k] 范围内的数应是没有重复的
            for (int i = 1; i < nums.size(); ++i) {
                if (nums[i] != nums[k]) {
                  	// 有的答案没有下面这个 if else 条件判断, 直接使用
                  	// nums[++k] = nums[i]; 我是说, 如果当前访问的元素
                  	// 就是 arr[k] 的下一位, 并且和 arr[k] 不相等, 那么
                  	// 直接将 k 移向下一位即可.
                    if (i != (k + 1))
                        nums[++k] = nums[i];
                    else
                        ++k;
                }
            }
      		// nums.resize(k + 1) 实际上不需要
            nums.resize(k + 1);
            return k + 1;
    }
};
```

### 80. **Remove Duplicates from Sorted Array II

https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/

承接上面的 26 题, 但是这次允许数组中重复数字最多出现两次. 比如 `nums = {1, 1, 1, 2, 2, 3}` 时, 结果为 5, `{1, 1, 2, 2, 3}`. 首

首先思路是, 当访问 `nums[i]` 时, 它要和 `nums[k - 1]` 进行比较, 其中 `nums[0....k]` 保存着满足条件的元素. 这样的话, 代码能允许重复数字最多出现两次.

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
            if (nums.size() <= 2)
                return nums.size();

            int k = 1;
            for (int i = 2; i < nums.size(); ++i) {
                if (nums[i] != nums[k - 1]) {
                    nums[++k] = nums[i];
                }
            }
            return k + 1;

    }
};
```

### 33. Search in Rotated Sorted Array

https://leetcode.com/problems/search-in-rotated-sorted-array/description/

将一个排序数组进行旋转, 然后在其中搜索某个数. 比如 `[0, 1, 2, 3, 4, 5]` 旋转后为 `[3, 4, 5, 0, 1, 2]`, 然后在旋转后的数组中搜索.

思路: 使用二分查找, 关键在于边界的确定. (参考了 leetcode-cpp.pdf 上 2.1.3 的解答)

要分情况讨论, 当访问 nums[mid] 时, 考虑两种情况, nums[mid] 是大于或等于 nums[left] 呢, 还是小于 nums[left]. 在这两种情况下, 又要考虑 target 和 nums[mid] 以及 nums[left] 的关系.

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if (nums.empty())
            return -1;

        int l = 0, r = nums.size() - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] >= nums[l]) { // 说明 nums[l...mid] 是排序好的
                if (target >= nums[l] && target < nums[mid])
                    r = mid - 1;
                else
                    l = mid + 1;
            }
            else {// 说明 nums[mid...r] 是排序好的
                if (target < nums[l] && target > nums[mid])
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return -1;
    }
};
```



### 81. Search in Rotated Sorted Array II

https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/

在上一题的基础上, 如果排序数组中有重复元素会怎样? 比如数组 `{1, 2, 2, 2, 2, 3, 4}` 旋转之后成了

`{2, 2, 3, 4, 1, 2, 2}`. 

思路: 出现重复元素的话, 那么在 33. Search in Rotated Sorted Array 中使用的 `nums[mid] >= nums[l]` 就不能判定 `nums[l....mid]` 为递增序列了. 这个时候可以将其拆分为两个条件:

- 如果 nums[mid] > nums[l], 那么 nums[l....mid] 一定是递增的;
- 如果 nums[mid] == nums[l], 无法确认状况, 那么就令 `l++`, 往下看一步即可.

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        if (nums.empty())
            return false;

        int l = 0, r = nums.size() - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target)
                return true;
            if (nums[mid] > nums[l]) {
                if (target >= nums[l] && target < nums[mid])
                    r = mid - 1;
                else
                    l = mid + 1;
            }
            else if (nums[mid] == nums[l]) {
                l ++;
            }
            else {
                if (target < nums[l] && target > nums[mid])
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return false;
    }
};
```

可是我没想到下面的解法还更快... 来自 leetcode

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] == target) return true;
        }
        return false;
    }
};
```





### 75. **Sort Colors

https://leetcode.com/problems/sort-colors/description/

将只 0, 1, 2 三个元素的长度为 n 的数组排序.

思路: 一方面可以使用计数排序, 使用一个大小为 3 的数组来统计每个元素的个数; 另一方面使用三路快排的思路.

首先, 使用计数排序:

```cpp
class Solution {
public:
    // 使用计数排序
    void sortColors(vector<int>& nums) {
        if (nums.empty())
            return;

        int count[3] = {0};
        for (const auto &d : nums)
            count[d]++;

        int index = 0;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < count[i]; j++) {
                nums[index++] = i;
            }
        }
    }
};
```

下面是使用三路快排的思路:

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        if (nums.empty())
            return;
        
        // nums[0... lt] 保存 0
        // nums[lt+1....i] 保存 1
        // nums[gt....n-1] 保存 2
        int lt = -1, gt = nums.size();
        int i = 0;
        while (i < gt) {
            if (nums[i] == 1)
                ++i;
            else if (nums[i] == 0)
                swap(nums[i++], nums[++lt]);
            else
                swap(nums[i], nums[--gt]);
        }
    }
};
```



### 1. *Two Sum

https://leetcode.com/problems/two-sum/description/

给定一个整数序列, 要求返回两个索引, 它们对应的两个值的和等于 target. (此题的测试可以假设肯定是有一个解的, 另外, 不能将同一个值使用两次, 比如数组中有一个数字 4, target 为 8, 不能说 4 + 4 = 8). 比如 `[2, 7, 11, 15]`, target 为 9, 那么返回 `[0, 1]`.

思路: 等下会做另一道类似的题, 但是是在有序数组中查找两个数, 使得它们的和与 target 相等. 但这道题的不同之处在于, 它的数组是无序的, 而排序太浪费时间, 如果要在遍历过程中实现目的, 那么需要快速查找的方法, 这个时候只好考虑使用空间来换取时间, 因此引入哈希表来对元素进行查找, 时间复杂度为 O(1), 空间复杂度为 O(n), 保存元素本身以及它对应的索引. 当访问元素 `nums[i]` 时, 在哈希表中查找 `nums[target - nums[i]]` 是否存在, 如果存在, 那么就保存索引; 否则将 `nums[i]` 以及索引 i 加入到哈希表中.(代码中的 `swap(i, j)` 是为了是返回结果中的索引的顺序是从小到大的.)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        if (nums.size() < 2)
            throw invalid_argument("nums' size invalid");

        unordered_map<int, int> hash_map;
        for (int i = 0; i < nums.size(); ++i) {
            auto iter = hash_map.find(target - nums[i]);
            if (iter != hash_map.end()) {
                int j = iter->second;
                if (i > j)
                    std::swap(i, j);
                int res[2] = {i, j};
                return vector<int>(res, res+2);
            }
            else
                hash_map.insert(std::make_pair(nums[i], i));
        }
    }
};
```



### 167. *Two Sum II - Input array is sorted

https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/

与上一题不同的地方是, 数组是排序的, 因此可以使用对撞指针. 要找到两个数等于 target, 由于数组是排序的, 那么这两个数必然是一左一右, 那么可以使用两个指针, 从数组的起始和尾部开始搜索, 如果 `nums[i] + nums[j]` 刚好等于 target, 那么, 直接返回. 如果和的结果小于 target, 那么说明 `nums[i]` 小了, 要增大, 应该 `++i`; 如果结果大于 target, 说明 `nums[j]` 大了, 应该 `--j`.

另外, 注意一点: **题目中要求是返回的索引从 1 开始, 因此, i 和 j 要加 1.**

由于代码 while 外面没有 return, 编译器会给出警告, 可以使用 `return {}` 解决.

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        if (numbers.size() < 2)
            throw invalid_argument("numbers' size invalid");

        int i = 0, j = numbers.size() - 1;
        // 由于结果返回两个, 所以i和j肯定不相等
        while (i < j) {
            if (numbers[i] + numbers[j] == target) {
                int res[2] = {i+1, j+1};
                return vector<int>(res, res + 2);
            }
            else if (numbers[i] + numbers[j] < target)
                ++i;
            else
                --j;
        }
    }
};
```



### 15. 3Sum

https://leetcode.com/problems/3sum/description/

给定含 n 个整数的数组 S, 找出是否存在 3 个整数使得 a + b + c = 0. 把所有不重复的三元组给找出来. 比如:

```bash
For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```



思路: 首先给数组排序, 然后遍历整个数组(直到 `nums.size() - 2` 的位置), 每一次访问的 `nums[i]` 可以作为三元组的首位元素, 这样可以保证所有的三元组不重复(当然其实还有另外的约束, 下面谈到), 然后针对 `nums[i + 1, .... n - 1]` 范围内的元素, 进行 2sum 操作, 即使用对撞指针. 但还需要考虑的两点是, `nums[i+1, .... n-1]` 中可能有多个 pair 满足 2sum, 另外也会有大量的重复元素, 因此在进行 2sum 的时候, 要使用 while 循环将这些相同的元素给略过. 

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.size() < 3)
            return {};

        vector<vector<int>> res;
        std::sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; ++i) {
          	// 当 i == 0 时, 进行判断; 当 i > 0 时, 需要判断 nums[i]
          	// 是否和前一个元素相等, 如果相等, 就不需要考虑了.
            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {
                int lo = i + 1, hi = nums.size() - 1, target = 0 - nums[i];
                while (lo < hi) {
                    vector<int> path;
                  	// 注意, 当在 nums[i+1, .... n-1] 范围内找到了 target, 在考虑
                  	// 下一个 pair 之前, 还要使用两个 while 循环判断 nums[lo] 和 
                  	// nums[lo+1] 是否相等.
                    if (nums[lo] + nums[hi] == target) {
                        path.insert(path.end(), {nums[i], nums[lo], nums[hi]});
                        res.push_back(path);

                        while (lo < hi && nums[lo] == nums[lo + 1]) lo ++;
                        while (lo < hi && nums[hi] == nums[hi - 1]) hi --;
                        lo ++;
                        hi --;
                    }
                    else if (nums[lo] + nums[hi] < target)
                        lo ++;
                    else
                        hi --;
                }
            }
        }
        return res;
    }
};
```

针对 3元组的首个元素可能会重复的问题, 还有另外的写法:

[Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments](https://leetcode.com/problems/3sum/discuss/7402/Share-my-AC-C++-solution-around-50ms-O(N*N)-with-explanation-and-comments)

```cpp
vector<vector<int> > threeSum(vector<int> &num) {
    
    vector<vector<int> > res;

    std::sort(num.begin(), num.end());

    for (int i = 0; i < num.size(); i++) {
        
        int target = -num[i];
        int front = i + 1;
        int back = num.size() - 1;

        while (front < back) {

            int sum = num[front] + num[back];
            
            // Finding answer which start from number num[i]
            if (sum < target)
                front++;

            else if (sum > target)
                back--;

            else {
                vector<int> triplet(3, 0);
                triplet[0] = num[i];
                triplet[1] = num[front];
                triplet[2] = num[back];
                res.push_back(triplet);
                
                // Processing duplicates of Number 2
                // Rolling the front pointer to the next different number forwards
                while (front < back && num[front] == triplet[1]) front++;

                // Processing duplicates of Number 3
                // Rolling the back pointer to the next different number backwards
                while (front < back && num[back] == triplet[2]) rear--;
            }
            
        }
		// 在这里考虑三元组的首元素可能重复的问题.
        // Processing duplicates of Number 1
        while (i + 1 < num.size() && num[i + 1] == num[i]) 
            i++;

    }
    
    return res;
    
}
```



### 16. 3Sum Closet

https://leetcode.com/problems/3sum-closest/description/

给定一个整数数组 S, 在其中找到 3 个整数使得它们的和接近一个给定的 target. 返回这 3 个数的和. (可以假设所有的测试用例中只有一个解) 比如:

```bash
For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```



思路: 类似于 15. 3Sum. 为了得到最接近 target 的值, 要计算使 `std::abs(target - sum)` 最小的那个 sum. 为了得到这些 sum, 和 3Sum 一样, 首先对数组进行排序, 然后固定 nums[i], 再对后面的内容进行 2Sum.

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        if (nums.size() < 3)
            return accumulate(nums.begin(), nums.end(), 0);

        int res = nums[0] + nums[1] + nums[nums.size() - 1];
        std::sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; ++i) {
            int lo = i + 1, hi = nums.size() - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi] + nums[i];
                if (sum == target)
                    return sum;
                if (sum > target)
                    hi --;
                else {
                    lo ++;
                }
                if (std::abs(target - sum) < std::abs(target - res))
                    res = sum;
            }
        }
        return res;
    }
};
```

再看一个 leetcode 上解释非常详细的:

[A n^2 Solution, Can we do better ?](https://leetcode.com/problems/3sum-closest/discuss/7873/A-n2-Solution-Can-we-do-better)

```cpp
int threeSumClosest(vector<int> &num, int target) {        
    vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.
    int n = 0;
    int ans = 0;
    int sum;
    
    sort(v.begin(), v.end());
    
    // If less then 3 elements then return their sum
    while (v.size() <= 3) {
        return accumulate(v.begin(), v.end(), 0);
    }
    
    n = v.size();
    
    /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]
     *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. 
     * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that 
     * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.
     * if the sum of the triplet is greater then the target it implies
     * we need to reduce our sum, so we do K = K - 1, that is we reduce
     * our sum by taking a smaller number.
     * Simillarly if sum of the triplet is less then the target then we
     * increase out sum by taking a larger number, i.e. J = J + 1.
     */
    ans = v[0] + v[1] + v[2];
    for (int i = 0; i < n-2; i++) {
        int j = i + 1;
        int k = n - 1;
        while (j < k) {
            sum = v[i] + v[j] + v[k];
            if (abs(target - ans) > abs(target - sum)) {
                ans = sum;
                if (ans == target) return ans;
            }
            (sum > target) ? k-- : j++;
        }
    }
    return ans;
}
```



### 18. 4Sum

https://leetcode.com/problems/4sum/description/

给定一个整数数组和给定的 target, 是否存在 a, b, c, d 4个整数使得它们的和满足 a+b+c+d = target? 返回所有不重复的 (a, b, c, d) 四元组.

```bash
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```



思路: 首先固定 a, 然后再使用 3Sum 的方法求解.

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        if (nums.size() < 4)
            return {};

        std::sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> path;
        for (int i = 0; i < nums.size() - 3; ++i) {
          for (int j = i + 1; j < nums.size() - 2; ++j) {
            int lo = j + 1, hi = nums.size() - 1;
            while (lo < hi) {
              int sum = nums[i] + nums[j] + nums[lo] + nums[hi];
              if (sum == target) {
                path = {nums[i], nums[j], nums[lo], nums[hi]};
                res.push_back(path);
                while (lo < hi && nums[lo] == nums[lo + 1]) lo ++;
                while (lo < hi && nums[hi] == nums[hi - 1]) hi --;
                lo ++;
                hi --;
              }
              else if (sum < target)
                lo ++;
              else
                hi --;
            }
            while (j + 1 < nums.size() - 2 && nums[j + 1] == nums[j]) ++j;
          }
          while (i + 1 < nums.size() - 3 && nums[i + 1] == nums[i]) ++i;
        }
        return res;
    }
};
```

不知道为什么, 下面 leetcode 上的解答和我的逻辑类似, 但是运算速度比我的快:

[4Sum C++ solution with explanation and comparison with 3Sum problem. Easy to understand.](https://leetcode.com/problems/4sum/discuss/8714/4Sum-C++-solution-with-explanation-and-comparison-with-3Sum-problem.-Easy-to-understand.)

```cpp
class Solution {
public:
    vector<vector<int> > fourSum(vector<int> &num, int target) {
    
        vector<vector<int> > res;
    
        if (num.empty())
            return res;
    
        std::sort(num.begin(),num.end());
    
        for (int i = 0; i < num.size(); i++) {
        
            int target_3 = target - num[i];
        
            for (int j = i + 1; j < num.size(); j++) {
            
                int target_2 = target_3 - num[j];
            
                int front = j + 1;
                int back = num.size() - 1;
            
                while(front < back) {
                
                    int two_sum = num[front] + num[back];
                
                    if (two_sum < target_2) front++;
                
                    else if (two_sum > target_2) back--;
                
                    else {
                    
                        vector<int> quadruplet(4, 0);
                        quadruplet[0] = num[i];
                        quadruplet[1] = num[j];
                        quadruplet[2] = num[front];
                        quadruplet[3] = num[back];
                        res.push_back(quadruplet);
                    
                        // Processing the duplicates of number 3
                        while (front < back && num[front] == quadruplet[2]) ++front;
                    
                        // Processing the duplicates of number 4
                        while (front < back && num[back] == quadruplet[3]) --back;
                
                    }
                }
                
                // Processing the duplicates of number 2
                while(j + 1 < num.size() && num[j + 1] == num[j]) ++j;
            }
        
            // Processing the duplicates of number 1
            while (i + 1 < num.size() && num[i + 1] == num[i]) ++i;
        
        }
    
        return res;
    
    }
};
```

这道题在 leetcode-cpp.pdf 上还有两种使用 hash 表进行求解的方法, 展示如下, 但都不是很快.

这是使用 `unordered_map` 的:

```cpp
// LeetCode, 4Sum
// 用一个 hashmap 先缓存两个数的和
// 时间复杂度，平均 O(n^2)，最坏 O(n^4)，空间复杂度 O(n^2)
class Solution {
public:
   vector<vector<int> > fourSum(vector<int> &num, int target) {
       vector<vector<int>> result;
       if (num.size() < 4) return result;
       sort(num.begin(), num.end());
       unordered_map<int, vector<pair<int, int> > > cache;
       for (size_t a = 0; a < num.size(); ++a) {
           for (size_t b = a + 1; b < num.size(); ++b) {
               cache[num[a] + num[b]].push_back(pair<int, int>(a, b));
           }
       }
       for (int c = 0; c < num.size(); ++c) {
           for (size_t d = c + 1; d < num.size(); ++d) {
               const int key = target - num[c] - num[d];
               if (cache.find(key) == cache.end()) continue;
               const auto& vec = cache[key];
               for (size_t k = 0; k < vec.size(); ++k) {
                   if (c <= vec[k].second)
                       continue; // 有重叠
                   result.push_back( { num[vec[k].first],
                           num[vec[k].second], num[c], num[d] });
               }
           }
       }
       sort(result.begin(), result.end());
       result.erase(unique(result.begin(), result.end()), result.end());
       return result;
   }
};
```

下面是使用 multimap 的:

```cpp
// LeetCode, 4Sum
// 用一个 hashmap 先缓存两个数的和
// 时间复杂度 O(n^2)，空间复杂度 O(n^2)
// @author 龚陆安 (http://weibo.com/luangong)
class Solution {
public:
   vector<vector<int>> fourSum(vector<int>& num, int target) {
       vector<vector<int>> result;
       if (num.size() < 4) return result;
       sort(num.begin(), num.end());
       unordered_multimap<int, pair<int, int>> cache;
       for (int i = 0; i + 1 < num.size(); ++i)
           for (int j = i + 1; j < num.size(); ++j)
               cache.insert(make_pair(num[i] + num[j], make_pair(i, j)));
       for (auto i = cache.begin(); i != cache.end(); ++i) {
           int x = target - i->first;
           auto range = cache.equal_range(x);
           for (auto j = range.first; j != range.second; ++j) {
               auto a = i->second.first;
               auto b = i->second.second;
               auto c = j->second.first;
               auto d = j->second.second;
               if (a != c && a != d && b != c && b != d) {
                   vector<int> vec = { num[a], num[b], num[c], num[d] };
                   sort(vec.begin(), vec.end());
                   result.push_back(vec);
               }
           }
       }
       sort(result.begin(), result.end());
       result.erase(unique(result.begin(), result.end()), result.end());
       return result;
   }
};
```





### 454. 4Sum II

https://leetcode.com/problems/4sum-ii/description/

给定 4 个整型数组, 计算有多少个 `(i, j, k, l)` 四元组使得 `A[i] + B[j] + C[k] + D[l]` 的结果为 0.

(为了让问题简单一些, 假设所有的数组中元素数量为 0 <= N <= 500, 并且和的结果不超过 `2^31 - 1`), 比如:

```bash
Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```



思路: 使用一个查找表, 记录 `A[i] + B[j]` 的和, 然后分析 C 和 D 中元素的和, 判断查找表中是否存在 `0 - C[k] - D[l]`.

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        // 使用 record 记录 A[i] + B[j] 的和有多少个
        unordered_map<int, int> record;
        for (int i = 0; i < A.size(); ++i)
            for (int j = 0; j < B.size(); ++j)
                record[A[i] + B[j]] ++;

        int res = 0;
        for (int i = 0; i < C.size(); ++i) {
            for (int j = 0; j < D.size(); ++j) {
                auto iter = record.find(0 - C[i] - D[j]);
                if (iter != record.end())
                    res += iter->second;
            }
        }
        return res;
    }
};
```





### 653. *Two Sum IV - Input is a BST

https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/

依然是 two sum, 但是在一棵二叉搜索树上查找, 返回 True 或 False. 比如

```bash
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
```



思路: 这道题只要借助一个数组就特别简单. 先对 BST 进行中序遍历, 那么元素在数组中就从小到大排列了, 这个时候只需要对这个数组使用题 1 中 Two Sum 的双指针方法即可.

```cpp
class Solution {
    void inorder(TreeNode* node,vector<int> &nums) {
        if (!node) return;
        inorder(node->left,nums);
        nums.push_back(node->val);
        inorder(node->right,nums);
    }
public:
    bool findTarget(TreeNode* root, int k) {
        vector<int> res;
        inorder(root,res);
        int i=0,j=res.size()-1;
        while(i<j){
            int sum = res[i]+res[j];
            if(sum==k) return true;
            else if(sum >k){
                j--;
            }
            else i++;
        }
        return false;
    }
};
```

如果使用 `unordered_set` 的话, 要注意一个陷阱, 即 `k - val != val`:

```cpp
class Solution {
private:
    void dfs(TreeNode *root, unordered_set<int> &record) {
        if (!root)
            return;

        record.insert(root->val);
        dfs(root->left, record);
        dfs(root->right, record);
    }
public:
    bool findTarget(TreeNode* root, int k) {
        unordered_set<int> record;
        dfs(root, record);

        for (auto &val : record)
            if (record.count(k - val) && (k - val) != val)
                return true;
        return false;
    }
};
```





### 88. *Merge Sorted Array

https://leetcode.com/problems/merge-sorted-array/description/

给定两个有序数组 num1 和 num2, 将两个数组中的元素有序的合并到 num1 中. 注意 nums1 的大小可以认为比 `m + n` 要大.

思路: 就是归并排序的思路, 但是要注意, 由于并没有额外的申请新的空间, 而是将数组保存到 nums1 上, 因此在 nums1 中需要从后向前开始排序, 并且还要将 nums1 中元素中与 nums2 的元素中选出最大的开始比较. 另外还需要注意 m 和 n 不能同时为 0, 但可以有一个为 0.

```cpp
class Solution {
public:
    // 注意题目已经假设 nums1 的大小至少和 m + n 一样大
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
      	// 这里在两者都小于 1 的情况下才返回, leetcode 有一个测试用例就是 m = 0,
      	// n = 1 这样也是可以的.
        if (m < 1 && n < 1)
            return;
		// 在 nums1 的末尾开始, 实现两个数组的归并.
        int k = m + n - 1;
        int i = m - 1, j = n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] < nums2[j])
                nums1[k--] = nums2[j--];
            else
                nums1[k--] = nums1[i--];
        }

        while (i >= 0)
            nums1[k--] = nums1[i--];
        while (j >= 0)
            nums1[k--] = nums2[j--];
    }
};
```



### 215. Kth Largest Element in an Array

https://leetcode.com/problems/kth-largest-element-in-an-array/description/

在一个未排序的数组中找到第 k 个最大的元素. 这个 k 指的是排好序后的第 k 个最大元素. 比如:

Given `[3,2,1,5,6,4]` and k = 2, return 5. (可以假设 `1 <= k <= arr.size()`)

思路: 目前的思路是使用快排的思路, 利用 partition 找到第 (k - 1) 个元素(将元素从大到小排序). 另外的思路可以使用一个优先队列, 返回第 k - 1 个元素.

```cpp
class Solution {
private:
  	// 使用两路快排的思路, 注意在 while 循环中, 我使用 >= v 的
  	// 元素放在前头, 使得左边的元素大于 v, 右边的元素小于 v
    int partition(vector<int> &nums, int l, int r) {
        if (l > r)
            return -1;

        int v = nums[l];
        // 注意 arr[l.... i) >= v, arr(j.... r] <= v
        // 以及i 和 j 的初始化, 要使得这两个集合都是空集.
        int i = l + 1, j = r;
        while (true) {
            while (i <= r && nums[i] >= v) i++;
            while (j >= l+1 && nums[j] <= v) j--;
            if (i > j)
                break;
            std::swap(nums[i++], nums[j--]);
        }
        std::swap(nums[l], nums[j]);
        return j;
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        if (nums.empty())
            return -1;
		
      	//while 中使用 index + 1 是因为数组从 0 开始计数, 而
      	// k 从 1 开始计数.
        int index = partition(nums, 0, nums.size() - 1);
        while ((index + 1) != k) {
            if ((index + 1) < k)
                index = partition(nums, index + 1, nums.size() - 1);
            else
                index = partition(nums, 0, index - 1);
        }
        return nums[index];
    }
};
```

下面是使用优先队列的代码:

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq(nums.begin(), nums.end());
        for(int i = 0; i < k-1; i++){
            pq.pop();
        }
        return pq.top();
    }
};
```



### 11. **Container With Most Water

https://leetcode.com/problems/container-with-most-water/description/

使容器盛上最多的水. 给定 n 个非负的整数 $a_1, a_2, ..., a_n$, 每一个表示位于 $(i, a_i)$ 处的点. 以 $(i, 0)$ 和 $(i, a_i)$ 为端点可以作 n 条垂直的直线. 其中, 每两条直线和 x 轴可以组成一个容器, 现在要找到两条直线, 它们和 x 轴形成的容器容量最大.

思路: 这个问题我第一次提交写错了, 给出我在给出的数组为 `height = {2,3,10,5,7,8,9}` 时报错, 正确的结果是 36, 可以看出是当 `i = 2, j = 6, height[i] = 10, height[j] = 9` 时得到最大值. 这道题应该采用双指针对撞的技术来减少考虑的情况. 但问题的关键是以什么标准来让两个指针进行移动. 通过仔细观察 height 可以发现, 当 `i = 0, j = n - 1` 时, 假设最大值 `res` 就是当前的容量, 那么之后 i he j 要怎样移动呢? 注意到 2 要比 9 小, 移动是必然要做的, 不管是 i 向右移动, 还是 j 向左移动, x 轴的大小总是要减小 1 的, 但是由于 2 比 9 小, 那么应该将 i 向右移动, 因为下一个 `height[i + 1]` 可能会使得容量最大, 因为如果 `height[i + 1]` 足够高, 而 9 也是一个比较大的值, 那么就有可能获得更大的容量. 

通过以上的分析, 就知道了 i 和 j 的移动规律, 也就是如果 `height[i] < height[j]`, 那么就将 i 向右移动, 反之, 则将 j 向左移动.

```cpp
class Solution {
private:
  	// 用于计算面积
    int Area(int i, int j, int ai, int aj) {
        return (j - i) * min(ai, aj);
    }
public:
    int maxArea(vector<int>& height) {
        if (height.empty())
            return 0;
		// res 保存最大值
        int i = 0, j = height.size() - 1;
        int res = Area(i, j, height[i], height[j]);
      	// 关于循环结束的条件, 是 i 和 j 至少有一个距离
      	// 在 if 后面的语句中, 即使 ++i == j, 也没有关系
      	// 这个时候的 Area 就是 0, 依然能得到正确的最大容量.
        while (i < j) {
            if (height[i] < height[j]) {
                ++i;
                res = max(res, Area(i, j, height[i], height[j]));
            }
            else {
                --j;
                res = max(res, Area(i, j, height[i], height[j]));
            }
        }
        return res;
    }
};
```



### 387. First Unique Character in a String

https://leetcode.com/problems/first-unique-character-in-a-string/description/

给定一个字符串, 查找第一个在字符串中没有重复的字符, 并返回它的索引; 如果不存在就返回 -1. 比如:

**Examples:**

```bash
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
```

**Note:** You may assume the string contain only lowercase letters.



思路: 由于可以认为字符串中只含有小写字母, 那么可以使用大小为 `vector<int>(26, 0)` 的数组保存字符的索引(如果不是小写字母, 那么就使用 `vector<int>(256, 0)`). 为什么保存索引能成功呢? 因为索引都是正数, 如果遇到重复的字符, 我就把索引设置为负数, 那么之后只要遍历一遍数组, 专门处理值大于 0 的值, 就可以找到最小的索引. 这里需要注意的是索引 0, 如果数组初始化为 -1, 可以避免这个尴尬. 当然也可以初始化为 0.

```cpp
// 这是我第二次提交的代码
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty())
            return -1;

        vector<int> records(26, 0);

        for (int i = 0; i < s.size(); ++i) {
            int index = s[i] - 'a';
            if (records[index] == 0)
                records[index] = i + 1; // 保存索引+1, 以免和 0 误会
            else if (records[index] > 0)
                records[index] = -1; // 如果有重复, 就设置为 -1.
        }
        int first = INT32_MAX;
        for (const auto &index : records) {
            if (index > 0)
                first = min(first, index);
        }

        if (first == INT32_MAX)
            return -1;
        return first - 1; // 最后要减 1
    }
};


// 下面是我第一次提交的代码, 比上面竟然还快...
// 但我觉得有个地方有问题, 注释中给出
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty())
            return -1;

        vector<int> records(26, -1);

        for (int i = 0; i < s.size(); ++i) {
            int index = s[i] - 'a';
            if (records[index] == -1)
                records[index] = i; // 保存索引
            else if (records[index] >= 0)
              	// 这里不断的减小可能会出问题, 如果 s.size() 太大的话.
                records[index] -= s.size();
        }
        int first = INT32_MAX;
        for (const auto &index : records) {
            if (index >= 0)
                first = min(first, index);
        }

        if (first == INT32_MAX)
            return -1;
        return first;
    }
};

// 看 leetcode 上有更简洁的做法
// 只要查找第一个出现次数为 1 的元素的索引即可.
class Solution {
public:
    int firstUniqChar(string s) {
        int ascii[256] = {0};
        
        for (char c : s) ascii[c - '0']++;
        for (int i = 0; i < s.size(); i++) {
            if (ascii[s[i] - '0'] == 1) return i;
        }
        
        return -1;
    }
};
```



### 561. *Array Partition I

https://leetcode.com/problems/array-partition-i/description/

给定 2n 个整数, 现在要将它们分成 n 个数对 (a1, b1), (a2, b2), ..., (an, bn), 使得 min(ai, bi) 的和 (`i = 1 ... n`) 尽可能大. 比如:

**Example 1:**

```bash
Input: [1,4,3,2]

Output: 4
Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
```

**Note:**

1. **n** is a positive integer, which is in the range of [1, 10000].
2. All the integers in the array will be in the range of [-10000, 10000].

思路: 这道题的关键是要观察到这样一个现象: 较大的数要聚在一起, 那么 min(ai, bi) 才会比较大. 比如上面的例子中, 如果 4 和 1 组成数对, 那么 min(1, 4) 就是 1, 相比 min(3, 4) 就小了. 因此, 思路就是将这个数组排序, 然后将 `0 ~ 2n - 1` 索引中偶数位置的元素相加即可.

```cpp
class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        if (nums.empty() || nums.size() % 2 == 1)
            throw invalid_argument("nums' size must be even");

        std::sort(nums.begin(), nums.end());
        int sum = 0;
        for (int i = 0; i < nums.size(); i += 2)
            sum += nums[i];
        return sum;
    }
};
```

leetcode 上有对这一思路的证明: [Java Solution, Sorting. And rough proof of algorithm.](https://leetcode.com/problems/array-partition-i/discuss/102170/Java-Solution-Sorting.-And-rough-proof-of-algorithm.)



### 566. *Reshape the Matrix

https://leetcode.com/problems/reshape-the-matrix/description/

类似于 matlab 中的 reshape 函数, 将一个矩阵给 reshape. 如果无法 reshape, 就返回原矩阵. 两个矩阵以行来遍历的话相同.



思路: 对于元素个数为 `rows * cols` 的矩阵, 在 `[0 ~ rows * cols - 1]` 范围内的元素 k, 对应于矩阵中的位置为 `(k/cols, k%cols)`, 知道这一点后, 解法很简单. 另外, 发现使用两个循环还更快.

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        int rows = nums.size(), cols = nums[0].size();
        if ((rows * cols) != (r * c) || r <= 0 || c <= 0)
            return nums;

        vector<vector<int>> res(r, vector<int>(c));
        for (int k = 0; k < rows * cols; ++k) {
            res[k/c][k%c] = nums[k/cols][k%cols];
        }
        return res;
    }
};
```

下面是使用两个循环的:

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        int row = nums.size();
        int column = nums[0].size();
        if(row * column != r * c) return nums;
        
        vector<vector<int>> ans(r, vector<int>(c));
        
        for(int i = 0; i < r; i++)
            for(int j = 0; j < c; j++)
                ans[i][j] = nums[(i * c + j) / column][(i * c + j) % column];
        return ans;
    }
};
```



### 724. *Find Pivot Index

https://leetcode.com/problems/find-pivot-index/description/

给定一个整型数组, 返回这个数组的 pivot 索引 i, 使得它左边的所有数 nums[0,...., i - 1] 与右边所有数 nums[i + 1,..., n - 1] 的和相等. 如果没有这样的索引, 返回 -1. 比如:

**Example 1:**

```bash
Input: 
nums = [1, 7, 3, 6, 5, 6]
Output: 3
Explanation: 
The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.
Also, 3 is the first index where this occurs.
```

**Example 2:**

```bash
Input: 
nums = [1, 2, 3]
Output: -1
Explanation: 
There is no index that satisfies the conditions in the problem statement.
```

**Note:**

The length of `nums` will be in the range `[0, 10000]`.

Each element `nums[i]` will be an integer in the range `[-1000, 1000]`.

思路: 好吧, 这道题我做错了多遍...这里直接给出 leetcode 的解答. 首先求出整个数组的和 sum, 然后依次遍历每一个索引 i, 判断左边的和 leftsum 是否等于 `sum - nums[i] - leftsum` (即右边的和, 注意不包括 nums[i]), 如果不相等, 那么 leftsum += nums[i].

https://leetcode.com/problems/find-pivot-index/solution/

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = 0, leftsum = 0;
        for (auto &d : nums) sum += d;

        for (int i = 0; i < nums.size(); ++i) {
            if (leftsum == sum - nums[i] - leftsum)
                return i;
            else
                leftsum += nums[i];
        }
        return -1;
    }
};
```





### 118. *Pascal's Triangle

https://leetcode.com/problems/pascals-triangle/description/

杨辉三角形.

Given *numRows*, generate the first *numRows* of Pascal's triangle.

For example, given *numRows* = 5,
Return

```bash
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

思路: 仔细观察, 末尾的 1 就是上一行的最后一位加上 0, 所以要判断是否为最后一位.

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        if (numRows <= 0)
            return vector<vector<int>>{};

        vector<int> prev{1};
        vector<vector<int>> res{prev};

        for (int i = 1; i < numRows; ++i) {
            vector<int> path(i + 1, 0);
            path[0] = 1;
            for (int j = 0; j < prev.size(); ++j) {
                if (j + 1 == prev.size())
                    path[j + 1] = prev[j] + 0;
                else
                    path[j + 1] = prev[j] + prev[j + 1];
            }
            res.push_back(path);
            prev = path;
        }
        return res;
    }
};
```

经下面 119. Pascal's Triangle II 这道题的启发, 我们可以从后向前计算, 代码看起来会更简洁:

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        if (numRows <= 0)
            return vector<vector<int>>{};

        vector<int> prev{1};
        vector<vector<int>> res{prev};

        for (int i = 1; i < numRows; ++i) {
            vector<int> path(i + 1, 0);
            path[0] = 1;
            path[i] = 1;
            for (int j = i - 1; j > 0; --j)
                path[j] = prev[j] + prev[j - 1];
            res.push_back(path);
            prev = path;
        }

        return res;
    }
};
```



### 119. *Pascal's Triangle II

https://leetcode.com/problems/pascals-triangle-ii/description/

```bash
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

给定index k, 返回杨辉三角形中的第 k 行. 比如给定 k = 3, 返回 `[1, 3, 3, 1]`.



思路: 这道题如果从前往后计算就特别麻烦, 我等下会给出这个思路的方法. 在 leetcode 上看到如下的解法, 从后向前计算, 非常简洁:

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> result(rowIndex+1, 0);
        result[0] = 1;
        for(int i = 1; i <= rowIndex; i++) {
            for(int j = i; j >= 1; j--) {
                result[j] = result[j] + result[j-1];
            }
        }
        return result;
    }
};
```

下面是我的解法: 不过多解释, 调试了半天...

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        if (rowIndex < 0)
            return vector<int>{};

        vector<int> res(rowIndex + 1, 0);
        res[0] = 1;

        int prev = res[0], now = 0;;
        for (int i = 1; i <= rowIndex; ++i) {
            for (int j = 1; j < i + 1; ++j) {
                now = res[j];
                res[j] += prev;
                prev = now;
            }
            prev = res[0];
        }
        res.erase(res.begin() + rowIndex + 1, res.end());
        return res;
    }
};
```



### 485. *Max Consecutive Ones

https://leetcode.com/problems/max-consecutive-ones/description/

给定一个只包含 0-1 的数组, 找出 1 的连续个数最多是多少?

```bash
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
```

**Note:**

- The input array will only contain `0` and `1`.
- The length of input array is a positive integer and will not exceed 10,000



思路: 解法一: 使用 [i, j] 来标识只包含 1 的连续子数组的范围. 如果当前访问的元素(其中 `j + 1` 表示当前访问的元素)是 1, 那么 `j++`, 否则, `i = ++j + 1`;

```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int i = 0, j = -1;
        int res = 0;
        while (i < nums.size()) {
            if (nums[j + 1] == 1)
                j ++;
            else {
                res = max(res, j - i + 1);
                i = ++j + 1;
            }
        }
        return res;
    }
};
```

如果只用一个索引来遍历数组, 而不是像上面使用两个索引(i 和 j)来标识范围, 那么可以看看下面的解法:

[Java 4 lines concise solution with explanation](https://leetcode.com/problems/max-consecutive-ones/discuss/96693/Java-4-lines-concise-solution-with-explanation/101261)

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0;
        int sum = 0;
        for(int i = 0 ; i< nums.length; i ++){
            sum += nums[i];
            if(nums[i] == 0)    // reset sum to zero when encounters zeros
                sum = 0;
            else                // keep update max
                max = Math.max(max, sum);
        }
        return max;
    }
}
```



### 169. *Majority Element

https://leetcode.com/problems/majority-element/description/

给定一个长度为 n 的数组, 找出出现次数超过 `⌊ n/2 ⌋` 的元素(它被称为 majority element).

You may assume that the array is non-empty and the majority element always exist in the array.

思路: 这道题复杂在若用 O(n) 的方法解决. 最直观的思路是, 我可以排序, 然后找中间的元素:

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        std::sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```

[6 Suggested Solutions in C++ with Explanations](https://leetcode.com/problems/majority-element/discuss/51612/6-Suggested-Solutions-in-C++-with-Explanations) 给出了 6 种方法:

1. 使用 Hash 表统计元素个数, 下面的写法可以借鉴, 很简洁:

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           unordered_map<int, int> counts; 
           int n = nums.size();
           for (int i = 0; i < n; i++)
             	// 一方面将元素加入到表中, 同时将比较完成.
               if (++counts[nums[i]] > n / 2) 
                   return nums[i];
       }
   };
   ```

2. 对数组进行排序, 取中间的那个数. 代码上面有.

3. 从数组中随机选取某个数, 然后判断它是不是 Majority element, 多次重复这个过程. 链接中说速度很快.

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           int n = nums.size();
           srand(unsigned(time(NULL)));
           while (true) {
               int idx = rand() % n;
               int candidate = nums[idx];
               int counts = 0; 
               for (int i = 0; i < n; i++)
                   if (nums[i] == candidate)
                       counts++; 
               if (counts > n / 2) return candidate;
           }
       }
   };
   ```

4. **Divide and Conquer** 分治法. 每次将数组分成两个部分, 类似于归并排序, 即进行 divide, 然后判断 left 和 right 中哪个值的数量最多. 注意边界条件是, 当 divide 后只有一个元素时, majority element 就是该元素本身.

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           return majority(nums, 0, nums.size() - 1);
       }
   private:
       int majority(vector<int>& nums, int left, int right) {
           if (left == right) return nums[left];
           int mid = left + ((right - left) >> 1);
           int lm = majority(nums, left, mid);
           int rm = majority(nums, mid + 1, right);
           if (lm == rm) return lm;
           return count(nums.begin() + left, nums.begin() + right + 1, lm) > count(nums.begin() + left, nums.begin() + right + 1, rm) ? lm : rm;
       }
   }; 
   ```

5. **Moore Voting Algorithm** 

   这个方法太牛啦! 使用 O(n) 以及 O(1) 的时间以及空间复杂度.

   A brilliant and easy-to-implement algorithm! It also runs very fast, about 20ms.

   使用 counts 用于记录票数, 使用 major 用于记录出现可能是 majority element 的元素. 当 counts 为 0 的时候, 设置当前访问的 `nums[i]` 为 major, 之后访问新的元素时, 如果新元素与 major 相等, 那么就 counts 加 1; 否则将 counts 减 1. 从程序中可以看出, 对于 2n + 1 个元素, 如果 majority element 的个数是 n + 1, 那么最后 counts 的值就是 1. 有点像使用 `nums[i....n - 1]` 这些元素来对 major 进行投票, 值相等才增加票数, 值不等那么就消减票数.rug

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           int major, counts = 0, n = nums.size();
           for (int i = 0; i < n; i++) {
               if (!counts) {
                   major = nums[i];
                   counts = 1;
               }
               else counts += (nums[i] == major) ? 1 : -1;
           }
           return major;
       }
   };
   ```

6. **Bit Manipulation** (没看懂)

   Another nice idea! The key lies in how to count the number of `1`'s on a specific bit. Specifically, you need a `mask` with a `1` on the `i`-the bit and `0` otherwise to get the `i`-th bit of each element in `nums`. The code is as follows.

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           int major = 0, n = nums.size();
           for (int i = 0, mask = 1; i < 32; i++, mask <<= 1) {
               int bitCounts = 0;
               for (int j = 0; j < n; j++) {
                   if (nums[j] & mask) bitCounts++;
                   if (bitCounts > n / 2) {
                       major |= mask;
                       break;
                   }
               }
           } 
           return major;
       } 
   };
   ```



### 611. **Valid Triangle Number

https://leetcode.com/problems/valid-triangle-number/description/

给定一个由非负整数组成的数组, 要求出所有能组成三角形的三元组的个数. 比如:

```bash
Input: [2,2,3,4]
Output: 3
Explanation:
Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
```



思路: 这道题的话, 先对数组进行从小到大排序的话, 思考会轻松一些. 这样的话, 就要找到 `i < j < k`, 使得 `nums[i] + nums[j] > nums[k]`. 当 i 和 j 确定之后, 对于 k 的话, 从 `(i + 2)` 这个索引开始搜索, 一直找到第一个不满足上面不等式条件的 k 值. 然后再考虑下一个 j. 说不清楚了, 直接看代码. 注意下面代码中很重要的一点, `k = i + 2` 放在 `for(int i = 0;...)` 的下面而不是放在 `for(int j = 0;...)` 的下面, 这是一步非常非常重要的优化. 当然 `k = i + 2` 可以放在  `for(int j = 0;...)`  的下面, 但是这样会极其耗时, 方法退化到 `O(n^3)`. 按照如下代码所写, 那么当 `++j` 后, 对于当前的 k 值, `nums[i+2,....k-1]` 仍然是满足 `nums[i] + nums[j] > nums[k]` 的, 不需要重复判断 `nums[i+2,...k-1]` 这些值是否仍按照这个 > 条件.

```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        if (nums.size() < 3)
            return 0;

        int count = 0;
        std::sort(nums.begin(), nums.end());
      	// 三元组 (i, j, k), 那么 i 最多到 nums.size() - 2
      	// k 的初始值为 i + 2. k 最多移动到 nusm.size() - 1;
      	// 当确定 j 之后, 使用 while 循环知道第一个不满足 > 条件的 k,
      	// 那么满足条件的三角形就是 k - j - 1.
      	// 注意 k = i + 2 放置的位置, 当 j 发生变化时, nums[i+2,...,k-1]
      	// 肯定满足 nums[i] + nums[j] > nums[k] 的, 所以不需要重复累加.
        for (int i = 0; i < nums.size() - 2; ++i) {
            int k = i + 2;
            for (int j = i + 1; j < nums.size() - 1 && nums[i] != 0; ++j) {
                while (k < nums.size() && nums[i] + nums[j] > nums[k])
                    k ++;
                count += k - j - 1;
            }
        }
        return count;
    }
};
```

leetcode 有官方解答, 非常清晰:

https://leetcode.com/problems/valid-triangle-number/solution/

在 leetcode 提交之后还看到一个新奇的解法, 如下:

排序之后, 从后向前考虑. 简洁精彩啊.

```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        sort(nums.begin(),nums.end());
        int count = 0;
        int n = nums.size();
        for(int k = n-1; k >= 0; k--){
            int i = 0;
            int j = k-1;
            while(i < j){
                if(nums[i] + nums[j] > nums[k]) {
                    count += j-i;
                    j--;
                }
                else i++;                    
            }
        }
        return count;
    }
};
```



### 56. **Merge Intervals

https://leetcode.com/problems/merge-intervals/description/

给定一些区间, 将有重合部分的区间合并. 比如:

Given a collection of intervals, merge all overlapping intervals.

For example,
Given `[1,3],[2,6],[8,10],[15,18]`,
return `[1,6],[8,10],[15,18]`.



思路: 我这里使用优先队列来解决. 按 Interval 的 `end` 值的大小, 将区间加入到最大堆中. 这样每次弹出的区间总是坐标轴上最右边的, 如果当前弹出来的区间 `small` 与已经弹出来的区间 `large` 比较, 如果它们有重合(这个时候很好比较了, 只要看 small 的 start 与 large 的 start 即可), 那么合并, 否则, 将 large 存入 res 中, 然后将 small 设置为 large, 用于下一次比较.

```cpp
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
private:
    struct Comp {
        bool operator()(const Interval &lhs, const Interval &rhs) {
            return lhs.end < rhs.end;
        }
    };
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        if (intervals.empty())
            return {};
        priority_queue<Interval, vector<Interval>, Comp> Queue(intervals.begin(), intervals.end());
        vector<Interval> res;
        Interval large = Queue.top();
        Queue.pop();
        while (!Queue.empty()) {
            Interval small = Queue.top();
            Queue.pop();
            if (small.end >= large.start)
                large.start = small.start < large.start ? small.start : large.start;
            else {
                res.push_back(large);
                large = small;
            }
        }
        res.push_back(large);
        return res;
    }
};
```



### 692. **Top K Frequent Words

https://leetcode.com/problems/top-k-frequent-words/description/

给定一个由字符串组成的列表, 返回 k 个出现频率最高的元素. 返回的结果中, 要按照字符串的出现频率从大到小排序, 如果两个字符串有相同的频率, 那么就按照字典序排列. 比如:

**Example 1:**

```bash
Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
Output: ["i", "love"]
Explanation: "i" and "love" are the two most frequent words.
    Note that "i" comes before "love" due to a lower alphabetical order.
```

**Example 2:**

```bash
Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
Output: ["the", "is", "sunny", "day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.
```

**Note:**

1. You may assume *k* is always valid, 1 ≤ *k* ≤ number of unique elements.
2. Input words contain only lowercase letters.

思路: 使用哈希表以及优先队列来解决. 但是优先队列要自定义比较运算.

注意 Comp 中的 `operator()` 必须是 public 的, 这也是为什么 Comp 用 struct 定义而不是 class.

```cpp
class Solution {
private:
    struct Comp {

        bool operator()(const pair<int, string> &p1, const pair<int, string> &p2) {
            if (p1.first < p2.first || (p1.first == p2.first && p2 < p1))
                return true;
            return false;
        }
    };
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> freq;
        for (auto &s : words)
            freq[s] ++;
        priority_queue<pair<int, string>, vector<pair<int, string>>, Comp> Queue;
        for (auto &iter : freq)
            Queue.push(make_pair(iter.second, iter.first));

        vector<string> res;
        while (k --) {
            auto ele = Queue.top();
            Queue.pop();
            res.push_back(ele.second);
        }
        return res;
    }
};
```

下面是使用 lambda 的, 来自:

[O(nlog(k)) Priority Queue C++ code](https://leetcode.com/problems/top-k-frequent-words/discuss/108366/O(nlog(k))-Priority-Queue-C++-code)

```cpp
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> freq;
        for(auto w : words){
            freq[w]++;
        }
        
        auto comp = [&](const pair<string,int>& a, const pair<string,int>& b) {
            return a.second > b.second || (a.second == b.second && a.first < b.first);
        };
        typedef priority_queue< pair<string,int>, vector<pair<string,int>>, decltype(comp) > my_priority_queue_t;
        my_priority_queue_t  pq(comp);
        
        for(auto w : freq ){
            pq.emplace(w.first, w.second);
            if(pq.size()>k) pq.pop();
        }
        
        vector<string> output;
        while(!pq.empty()){
            output.insert(output.begin(), pq.top().first);
            pq.pop();
        }
        return output;
    }
};
```



### 373. **Find K Pairs with Smallest Sums

https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/

给定两个数组 nums1 与 nums2, 它们都是按升序排列, 以及一个整数 k, 定义一个 pair 为 (u, v) 表示 u 从 nums1 中取出, 而 v 为 nums2 中的数. 现在要找到 k 个 pairs (u1, v1),...(uk, vk), 使它们的和最小. 比如:

**Example 1:**

```bash
Given nums1 = [1,7,11], nums2 = [2,4,6],  k = 3

Return: [1,2],[1,4],[1,6]

The first 3 pairs are returned from the sequence:
[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

**Example 2:**

```bash
Given nums1 = [1,1,2], nums2 = [1,2,3],  k = 2

Return: [1,1],[1,1]

The first 2 pairs are returned from the sequence:
[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

**Example 3:**

```bash
Given nums1 = [1,2], nums2 = [3],  k = 3 

Return: [1,3],[2,3]

All possible pairs are returned from the sequence:
[1,3],[2,3]
```

从上面的例子中可以看出, 如果 k 的值大于了 `nums1.size() * nums2.size()`, 那么返回所有的结果.



思路: 这道题最直观的思路是使用一个最大堆, 保存 `pair<int, pair<int, int>>`, 第一个值表示 sum, `u + v`, 第二个值表示 `(nums[i], nums[j])`. 首先在堆中放入 k 个值, 对于新来的值, 如果它比堆中的最大元素还小, 就插入到堆中.

```cpp
class Solution {
public:
    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {

        priority_queue<pair<int, pair<int, int>>> Queue;
        int count = 0; // count 来记录当前堆中是否插入了 k 个元素.
        for (int i = 0; i < nums1.size(); ++i) {
            for (int j = 0; j < nums2.size(); ++j) {
                if (count < k) {
                    Queue.push(make_pair(nums1[i]+nums2[j], make_pair(nums1[i], nums2[j])));
                    count ++;
                }
                else { // 如果新来的元素小于堆的 top, 那么插入新元素, 弹出旧元素.
                    auto ele = Queue.top();
                    if (ele.first > (nums1[i] + nums2[j])) {
                        Queue.pop();
                        Queue.push(make_pair(nums1[i]+nums2[j], make_pair(nums1[i], nums2[j])));
                    }
                }
            }
        }
        vector<pair<int, int>> res;
        while (!Queue.empty()) {
            auto ele = Queue.top();
            Queue.pop();
            res.push_back(ele.second);
        }
        return res;
    }
};

```



### 747. *Largest Number At Least Twice of Others

https://leetcode.com/problems/largest-number-at-least-twice-of-others/description/

给定的数组 nums 中总存在唯一的最大的数 A, 现需判断 A 是否是数组中其他所有元素的 2 倍. 如果是, 那么返回 A 的索引, 否则返回 -1. 比如:

**Example 1:**

```bash
Input: nums = [3, 6, 1, 0]
Output: 1
Explanation: 6 is the largest integer, and for every other number in the array x,
6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.
```

**Example 2:**

```bash
Input: nums = [1, 2, 3, 4]
Output: -1
Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.
```

**Note:**

1. `nums` will have a length in the range `[1, 50]`.
2. Every `nums[i]` will be an integer in the range `[0, 99]`.



思路: 一开始想复杂了, 后来发现只要找到这个数组中最大的两个数 `first`(第一大的数)以及 `second`(第二大的数), 然后判断 `first` 是否是 `second` 的两倍即可.

```cpp
class Solution {
public:
    int dominantIndex(vector<int>& nums) {
      	// 如果数组中只有一个数, 那么返回 true
        int imax = nums[0];
        int isec = INT32_MIN;
        int index = 0;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > imax) {
                isec = imax;
                imax = nums[i];
                index = i;
            }
            else if (nums[i] > isec) {
                isec = nums[i];
            }
        }
        return imax >= 2 * isec ? index : -1;
    }
};
```

leetcode 官方给出的解答如下:

https://leetcode.com/articles/largest-number-at-least-twice-of-others/

思路是: 扫描两遍, 第一遍求出最大值对应的索引 maxIndex, 第二遍判断对于 `i != maxIndex` 的 nums[i], 是否都满足 `nums[i] * 2 <= nums[maxIndex]`.

```java
class Solution {
    public int dominantIndex(int[] nums) {
        int maxIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] > nums[maxIndex])
                maxIndex = i;
        }
        for (int i = 0; i < nums.length; ++i) {
            if (maxIndex != i && nums[maxIndex] < 2 * nums[i])
                return -1;
        }
        return maxIndex;
    }
}
```



### 643. *Maximum Average Subarray I

https://leetcode.com/problems/maximum-average-subarray-i/description/

给定长度为 n 的整数数组, 找到其中含有 k 个元素的连续子数组, 使得该子数组的平均值最大. 比如:

**Example 1:**

```bash
Input: [1,12,-5,-6,50,3], k = 4
Output: 12.75
Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75
```

**Note:**

1. 1 <= `k` <= `n` <= 30,000.
2. Elements of the given array will be in the range [-10,000, 10,000].



思路: 这题比较简单, 每次移动长度为 k 的方框, 求方框元素的和, 当向右移动方框时, 将新元素加入方框, 并将方框中的第一个元素给去除, 更新连续子数组和的最大值.

```cpp
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int res = std::accumulate(nums.begin(), nums.begin() + k, 0);
        int imax = res;
        for (int i = k; i < nums.size(); ++i) {
            res += nums[i] - nums[i - k];
            imax = max(imax, res);
        }
        return imax / double(k);
    }
};
```



### 665. *Non-decreasing Array

https://leetcode.com/problems/non-decreasing-array/description/

给定一个长度为 n 的整数数组, 判断它是否能通过只修改最多一个元素使得整个数组是非递减的. 定义一个数组为非递减的: `array[i] >= array[i - 1]` 对合适的 i 总成立. 比如:

**Example 1:**

```bash
Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
```

**Example 2:**

```bash
Input: [4,2,1]
Output: False
Explanation: You can't get a non-decreasing array by modify at most one element.
```

**Note:** The `n` belongs to [1, 10,000].



思路 1:(会修改原数组) 这道题不容易啊... 想半天没有搞定, 最后看答案还要半天. 讨论中讲解最好的是:

[Clean Code - 6 liner Without Modifying Input](https://leetcode.com/problems/non-decreasing-array/discuss/106849/C++-Java-Clean-Code-6-liner-Without-Modifying-Input)

其中谈到了这样的策略: 要考虑 `a[i - 2], a[i - 1]` 以及 `a[i]` 三个值的相对大小; 当遇到 `a[i - 1]  > a[i]` 的时候, 需要考虑两种情况:

1. `a[i - 2]` 不存在或者 `a[i - 2] <= a[i]`, 那么这个时候只需要减小 a[i-1] 的值(比如说让 `a[i - 1] = a[i]`, 另一方面, 如果选择增大 a[i] 的值, 风险在于 a[i+1] 可能就不能满足 `a[i+1]>=a[i]` 了, 因此, 优先选择减小 a[i-1] 的值)就行;
2. `a[i - 2] > a[i]`, 这个时候, 就只能增大 `a[i]` 的值了.

不管哪种情况, 都需要使用 `modified` 来统计修改的次数, 如果修改的次数大于 1, 那么就返回 false; 否则返回 true.

```cpp
class Solution {
public:
    bool checkPossibility(vector<int>& a) {
        int modified = 0;
        for (int i = 1; i < a.size(); i++) {
            if (a[i] < a[i - 1]) {
                if (modified++ > 0) return false;
                if (i - 2 < 0 || a[i - 2] <= a[i]) a[i - 1] = a[i]; // lower a[i - 1]
                else a[i] = a[i - 1]; // rise a[i]
            }
        }
        return true;
    }
};
```

思路 2:(不修改原数组) 从思路一中可以看到, 策略是:

在 `a[i - 1] > a[i]` 的情况下:

1. `a[i - 2] <= a[i]`, lower a[i - 1];
2. `a[i - 2] > a[i]`, raise a[i];

为了不修改原数组, 需要使用变量 prev 来保存 a[i-1] 的值, 只有在 `a[i - 2] > a[i]` 的情况下, 才不需要修改 prev 的值(此时的策略是提升 a[i], 注意modified此时也增加了). 

```cpp
class Solution {
public:
    bool checkPossibility(vector<int>& a) {
        int modified = 0;
     	int prev = a[0];
        for (int i = 1; i < a.size(); i++) {
            if (a[i] < prev) {
                if (modified++ > 0) return false;
                if (i - 2 >= 0 && a[i - 2] > a[i]) continue;
            }
            prev = a[i];
        }
        return true;
    }
};
```





### 667. **Beautiful Arrangement II

https://leetcode.com/problems/beautiful-arrangement-ii/description/

Given two integers `n` and `k`, you need to construct a list which contains `n` different positive integers ranging from `1` to `n` and obeys the following requirement: 
Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly `k` distinct integers.

If there are multiple answers, print any of them.

**Example 1:**

```bash
Input: n = 3, k = 1
Output: [1, 2, 3]
Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.
```

**Example 2:**

```bash
Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.
```

**Note:**

1. The `n` and `k` are in the range 1 <= k < n <= 104.



思路: 这道题是直接看讨论的, 一开始没有做出来, 讲解非常细致的是:

[Clean Code 4-liner](https://leetcode.com/problems/beautiful-arrangement-ii/discuss/106948/C++-Java-Clean-Code-4-liner)

这道题关键在于要找到一种策略使得可以获得需要的 Beautiful Arrangement, 首先观察到, 比如 n = 9, 那么

```bash
1 2 3 4 5 6 7 8 9
```

满足 k = 1, 而当:

```bash
1 9 2 8 3 7 4 6 5
```

可以得到最大的 k = 8. 下面直接使用上面网站的答案: 要得到最大的 k, 可以从 k = 1 时产生的数组的头部和尾部交替取数, 比如:

```bash
# start from i = 1, j = n;
# i++, j--, i++, j--, i++, j--

i: 1   2   3   4   5
j:   9   8   7   6
out: 1  9  2  8  3  7  4  6  5  # 这一行是输出
dif:   8  7  6  5  4  3  2  1   # 这一行是差值
```

从上面可以看出, 初始化 `i = 1, j = n` 然后只要在 `i <= j` 的情况下, 按照

```bash
i++, j--, i++, j--, i++, .... 
# 每个 i++, j-- 都表示一个数, 当 n = 9 时, 
# 结果为: 1, 9, 2, 8, 3, ...
```

这样得到的结果中 `k` 刚好是 n - 1; 而为了得到其他任意的 k, 只需要将后面的 (i++, j--) 数对都改成 `i++`(这样的话, 所有的 diff 都是 1, 从而使得 k 减少), 比如说 n = 9, 而 k = 5, 那么只需要:

```bash
     i++ j-- i++ j--  i++ i++ i++ ...
out: 1   9   2   8    3   4   5   6   7
dif:   8   7   6   5    1   1   1   1 
```

但是还要考虑一种情况, 如果 k 为偶数, 比如 k = 4, 那么就应该让 `j--` 放在 `i++` 前面:

```bash
    j--  i++ j-- i++ i++ i++ i++ ...
out: 9   1   8   2   3    4   5  6  7
dif:   8   7   6   1   1    1   1  1
```

所以代码如下:

```cpp
class Solution {
public:
    vector<int> constructArray(int n, int k) {
        vector<int> res;

        for (int i = 1, j = n; i <= j;) {
          	// k 为奇数, i++ 放在前面, 
          	// k 为偶数, j-- 放在前面
            if (k > 1)
                res.push_back(k-- % 2 ? i++ : j--);
            else // 处理 k 为 1 的情况.
                res.push_back(i++);
        }
        return res;
    }
};
```



### 821. *Shortest Distance to a Character

https://leetcode.com/problems/shortest-distance-to-a-character/description/

给定一个字符串 S 和一个字符 C, 求 S 中每个字符距离最近的 C 的距离, 其中 S 中保证有字符 C.

Given a string `S` and a character `C`, return an array of integers representing the shortest distance from the character `C` in the string.

**Example 1:**

```bash
Input: S = "loveleetcode", C = 'e'
Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]
```

**Note:**

1. `S` string length is in `[1, 10000].`
2. `C` is a single character, and guaranteed to be in string `S`.
3. All letters in `S` and `C` are lowercase.



思路: 首先从左向右遍历 S, 求出每个字符和它左边第一个 C 的距离(下面代码中使用 prev 来记录每个字符左边第一个 C), 然后再从右向左遍历 S, 求出每个字符和它右边第一个 C 的距离(同样的, 使用 prev 来记录每个字符右边第一个 C); 这样的话, 只要对每一个字符求出两个距离的最小值, 就是最终的答案.

leetcode 官方给出了参考答案: https://leetcode.com/problems/shortest-distance-to-a-character/solution/

```cpp
class Solution {
public:
    vector<int> shortestToChar(string S, char C) {
        // 两次循环, 第一次从左到右计算每个元素与其左边的 C 的距离,
        // 第二次循环从右向左计算每个元素与其右边的 C 的距离, 两者取最短
      
      	// 初始 prev 取个较大的负值, 这样的话, 对于 S[0...k], 如果其中没有字符 C, 
      	// 那么它们距离左边的第一个 C 的距离就可以非常大, 而在下一个循环中, 可以保证它们
      	// 距离右边的的第一个 C 的距离要更小.
      	// 当 S[i] == C 时, 要更新 prev.
        vector<int> res(S.size());
        int prev = INT32_MIN / 2;
        for (int i = 0; i < S.size(); ++i) {
            if (S[i] == C) prev = i;
            res[i] = i - prev;
        }
		// 进行第二个循环, 
        // 此时 prev 保存着 S 中最右边的 C, 现在从右边开始, 计算每个元素
        // 与其右边的 C 的距离, 注意这里要使用 abs(), 索引之差可能为负值;
        for (int i = S.size() - 1; i >= 0; --i) {
            if (S[i] == C) prev = i;
            res[i] = min(res[i], abs(i - prev));
        }
        return res;

    }
};
```



### 414. *Third Maximum Number

https://leetcode.com/problems/third-maximum-number/description/

给定一个非空的整数数组, 返回第三个最大的整数. 如果其不存在, 那么返回数组中最大的整数. 比如:

**Example 1:**

```bash
Input: [3, 2, 1]
Output: 1

Explanation: The third maximum is 1.
```

**Example 2:**

```bash
Input: [1, 2]
Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
```

**Example 3:**

```bash
Input: [2, 2, 3, 1]
Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.
```



思路: 注意第三个例子, 如果存在相同的数, 不需要考虑. 所以第三个例子中, 第三个最大的数不是 2 而是 1. 可以设置 3 个遍历 first, second, third 来保存前 3 个最大的整数, 它们初始都设置为最小值. 另外注意的是, 下面代码中, 使用 long 来保存结果, 是因为, 比如这个例子:

```cpp
[1, 2, -2147483648]
```

结果应该返回 `-2147483648` 而不是 2; 但是如果使用 int 的话, 由于它们初始化都是 `INT32_MIN`, 就无法求出正确的结果.

```cpp
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        long first = INT64_MIN, second = INT64_MIN, third = INT64_MIN;
        for (auto &data : nums) {
            if (data > first) { // 求出最大值, 更新第二大以及第三大值
                third = second;
                second = first;
                first = data;
            }
            else if (data > second) { // 此时 data 保证 <= first
                if (data == first)
                    continue;
                third = second;
                second = data;
            }
            else if (data > third) { // 此时 data 保证 <= second
                if (data == second)
                    continue;
                third = data;
            }
        }
        return third == INT64_MIN ? (int)first : (int)third;
    }
};
```

如果要使用 `INT32_MIN`, leetcode 上面有一种解答:

```cpp
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        int max = INT_MIN;
        int max2 = INT_MIN;
        int max3 = INT_MIN;
        int flag = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == INT_MIN)
                flag = 1;
            if (max < nums[i]) {
                max3 = max2;
                max2 = max;
                max = nums[i];
            } else if (max2 < nums[i] && max > nums[i]) {
                max3 = max2;
                max2 = nums[i];
            } else if (max3 < nums[i] && max2 > nums[i])
                max3 = nums[i];
        }
        
        if (max3 != INT_MIN || (max3 != max2 && flag == 1))
            return max3;
        else
            return max;
    }
};
```

如果使用 java 的话, 写成如下方式解决:

[Java neat and easy understand solution, O(n) time, O(1) space](https://leetcode.com/problems/third-maximum-number/discuss/90202/Java-neat-and-easy-understand-solution-O(n)-time-O(1)-space)

```java
public int thirdMax(int[] nums) {
        Integer max1 = null;
        Integer max2 = null;
        Integer max3 = null;
        for (Integer n : nums) {
            if (n.equals(max1) || n.equals(max2) || n.equals(max3)) continue;
            if (max1 == null || n > max1) {
                max3 = max2;
                max2 = max1;
                max1 = n;
            } else if (max2 == null || n > max2) {
                max3 = max2;
                max2 = n;
            } else if (max3 == null || n > max3) {
                max3 = n;
            }
        }
        return max3 == null ? max1 : max3;
    }
```



### 506. *Relative Ranks

https://leetcode.com/problems/relative-ranks/description/

给定 n 个运动员的分数, 求出他们的相对排名, 然后将 top 3 设置为 "Gold Medal", "Silver Medal" 以及 "Bronze Medal", 不是 top3 的直接使用排名的字符串形式表示. 比如:

**Example 1:**

```bash
Input: [5, 4, 3, 2, 1]
Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". 
For the left two athletes, you just need to output their relative ranks according to their scores.
```

**Note:**

1. N is a positive integer and won't exceed 10,000.
2. All the scores of athletes are guaranteed to be unique.



思路: 没啥说的, 排序, 然后将前三设置为 medal, 注意排序的时候要保留每个运动员的索引. 下面的代码可以多体会. 使用 `vector<pair<int, int>>` 在保留分数的同时保留索引, 另一方面, 使用 `emplace_back` 构建对象. 排序时, 使用 `scores.rbegin()` 等反向迭代器, 使得分数排序可以从大到小(默认是从小到大, 比如使用 `nums.begin()` 的话)

```cpp
class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& nums) {
        // 保存每个运动员的分数和索引, emplace 使用构造函数构建对象
        // 而不是拷贝对象.
        vector<pair<int, int>> scores;
        vector<string> medals = {"Gold", "Silver", "Bronze"};
        for (int i = 0; i < nums.size(); ++i)
            scores.emplace_back(nums[i], i);
        // 默认从小到大排序, 现在从大到小排序
        std::sort(scores.rbegin(), scores.rend());
        vector<string> res(nums.size());
        for (int i = 0; i < scores.size(); ++i)
            res[scores[i].second] = i < 3 ? (medals[i] + " Medal") : to_string(i + 1);
        return res;
    }
};
```



### 204. *Count Primes

https://leetcode.com/problems/count-primes/description/

给定非负整数 n, 求出比 n 小的质数的个数.

注意: 也就是说, 如果给定的是 n = 2, 那么返回 0 而不是 1, 因为是小于 n 的质数的个数.

思路: 有 3 种思路. 前两种就不写代码了.

思路 1: 伪代码如下, 判断每个数是不是质数: `isPrime` 的时间复杂度为 O(n), 这会导致这道题的求解为 O(n^2).

```python
def isPrime(n):
    if n <= 2: return False
    for x in [2....n-1]:
        if n % x == 0: return False
    return True
```

思路 2: 注意到:

```bash
if n is not prime:

<=> n = a x b, a <= b
--> a <= sqrt(n)
## 因为如果 a > sqrt(n), 那么 axb > n
```

这样的话, 可以使用如下代码判断是否为质数: `isPrime` 的时间复杂度为 O(sqrt(n)), 整道题的时间复杂度为 O(n^{1.5}).

```python
def isPrime(n):
    if n <= 2: return False
    for x in [2....sqrt(n)]:
        if n % x == 0: return False
    return True
```

思路 3: [维基百科 - 埃拉托斯特尼筛法](https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95)

该算法可以得到所有小于或等于 n 的素数, 时间复杂度为 O(nlog(logn))

```cpp
Input: an integer n > 1
 
Let A be an array of Boolean values, indexed by integers 2 to n,
initially all set to true.
 
 for i = 2, 3, 4, ..., not exceeding √n:
  if A[i] is true:
    for j = i^2, i^2+i, i^2+2*i, i^2+3*i, ..., not exceeding n :
      A[j] := false
 
Output: all i such that A[i] is true.
```

C++ 实现如下:

```cpp
class Solution {
public:
    int countPrimes(int n) {
        if (n < 3) return 0;
        // count[i] 判断 i 是否为质数, 因为题中要求的是小于 n
        // 的所有质数的个数, 所以不包括 n
        vector<int> count(n, 1);
        count[0] = count[1] = 0; // 初始化
        // i 小于 sqrt(n) 即可, 只要考虑 sqrt(n) 范围内的质数即可.
        for (int i = 2; i < sqrt(n); ++i) {
            // 如果 i 不是质数, 那么继续考虑下一个质数.
            // 注意第二个循环中 j 的变化是从 i^2 开始, 然后
            // 每次加上 i.
            if (!count[i]) continue;
            for (int j = i * i; j < n; j += i)
                count[j] = 0;
        }
        return std::accumulate(count.begin(), count.end(), 0);
    }
};
```



### 830. *Positions of Large Groups

https://leetcode.com/problems/positions-of-large-groups/description/

In a string `S` of lowercase letters, these letters form consecutive groups of the same character.

For example, a string like `S = "abbxxxxzyy"` has the groups `"a"`, `"bb"`, `"xxxx"`, `"z"` and `"yy"`.

Call a group *large* if it has 3 or more characters.  We would like the starting and ending positions of every large group.

The final answer should be in lexicographic order.

 

**Example 1:**

```bash
Input: "abbxxxxzzy"
Output: [[3,6]]
Explanation: "xxxx" is the single large group with starting  3 and ending positions 6.
```

**Example 2:**

```bash
Input: "abc"
Output: []
Explanation: We have "a","b" and "c" but no large group.
```

**Example 3:**

```bash
Input: "abcdddeeeeaabbbcd"
Output: [[3,5],[6,9],[12,14]]
```

 

思路: 使用双指针, `S[i...j]` 为一个 Large Group 的条件是其中的元素都相等, 并且大小大于或等于 3.

```cpp
class Solution {
public:
    vector<vector<int>> largeGroupPositions(string S) {
        vector<vector<int>> res;
        int i = 0, j = 0;
        // S[i ... j] is a Group
        while (i < S.size()) {
            j = i;
            while (j < S.size() && S[i] == S[j])
                ++j;
          	// 因为当 S[i] != S[j] 时, ++j 已经被执行了, 所以最后
          	// 直接计算 j - i 的值.
            if (j - i >= 3) 
                res.push_back({i, j - 1});
            i = j;
        }
        return res;
    }
};
```



### 792. **Number of Matching Subsequences

https://leetcode.com/problems/number-of-matching-subsequences/description/

给定一个字符串 S 和一个字典, 判断字典中哪些 word 是 S 的子序列.

Given string `S` and a dictionary of words `words`, find the number of `words[i]` that is a subsequence of `S`.

```bash
Example :
Input: 
S = "abcde"
words = ["a", "bb", "acd", "ace"]
Output: 3
Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".
```

**Note:**

- All words in `words` and `S` will only consists of lowercase letters.
- The length of `S` will be in the range of `[1, 50000]`.
- The length of `words` will be in the range of `[1, 5000]`.
- The length of `words[i]` will be in the range of `[1, 50]`.

思路: 这道题给出了判断某个字符串 word 是否是另一个字符串 S 的子序列更快的方法. 原来我使用的是 O(n) 的方法, 使用 k 用于索引 word, 使用 i 索引 S, 每遍历 S 中的一个字符, 判断是否与 `word[k]` 相等, 最终只要 `k >= word.size()`, 那么 word 就是 S 中的子序列. 但是这道题需要更快的判断 word 是 S 的子序列. 

方法是: 使用 `vector<vector<int>> record` 用于记录 S 中每个字符的索引, 比如 `S = "abac"`, 那么 record 就是 `{{0, 2}, {1}, {3}}`, 分别表示 `record[S[i] - 'a']` 的索引. 之后对于 word 中的每个字符 `word[i]`, 要求它下一个字符 `word[i + 1]` 在 S 中的索引, 必须大于 word[i] 在 S 中的索引. 换句话说, 就是 word[i] 和 word[i + 1] 都要出现在 S 中, 并且 word[i + 1] 要出现在 word[i] 之后. 现在的问题是这句话换成代码如何实现? 下面的代码使用 `upper_bound` 实现了:

(代码刚看可能会有点懵逼, 但没关系, 慢慢理解)

重点看 isSubsequence 的实现. `x = -1` 是为了处理 word 中第一个字符的情况. 

`vector<int> indexes = record[c - 'a'];` 从 record 中取出字符 `word[i]` 在 S 中的所有索引, 对于 word 中的第一个字符, 如果 indexes 为空, 那么说明不存在该字符, 可以返回 false. 如果 indexes 不为空, 那么 indexes 中的任意一个值都要大于 x(初始为 -1), 这样就得到了第一个元素的索引, 之后要考虑 word 中下一个元素 `word[i + 1]`, 首先仍然是从 record 中找到相应的 indexes, 然后要判断这些 indexes 中有没有比 word[i] 所在的索引(`x = *it`) 还要大的, 如果存在, 继续考虑下一个 word[i + 2]... 如果不存在, 直接返回 false.

注意, 下面代码中, 为了方便解释, 我利用了注释的代码, 但是提交的时候, 不要使用注释的代码, 而必须写成未注释代码的样子, 否则时间会非常久.

```cpp
class Solution {
private:
    vector<vector<int>> record;
    bool isSubsequence(const string &word) {
        int x = -1;
        for (const auto &c : word) {
            //vector<int> indexes = record[c - 'a'];
            //auto it = upper_bound(indexes.begin(), indexes.end(), x);
            //if (it == indexes.end()) return false;
          	auto it = upper_bound(record[c - 'a'].begin(), 
                                  record[c - 'a'].end(), x);
            if (it == record[c - 'a'].end()) return false;
            x = *it;
        }
        return true;
    }
public:
    int numMatchingSubseq(string S, vector<string>& words) {
        int res = 0;
        record = vector<vector<int>>(26);
		// 这里的逻辑很简单, 主要看 isSubsequence 的实现.
        for (int i = 0; i < S.size(); ++i) record[S[i] - 'a'].push_back(i);
        for (auto &word : words) {
            if (isSubsequence(word))
                res += 1;
        }
        return res;
    }
};
```

此题参考: [C++ 12 Line Solution with Explanation](https://leetcode.com/problems/number-of-matching-subsequences/discuss/117575/C++-12-Line-Solution-with-Explanation)

```cpp
// General Idea:
    // - Brute force checking will time out, we need efficent way to look up words
    // - Create an vector that stores indices for each character a-z in S
    // - Then for each word, do a binary search for next index for current character in word 
    //   that is greater than the index we last found for the alst character
    // - If it doesn't exist, word doesn't exist, otherwise continue to search for word
    
	int numMatchingSubseq (string S, vector<string>& words) {
		vector<vector<int>> alpha (26);
		for (int i = 0; i < S.size (); ++i) alpha[S[i] - 'a'].push_back(i);
		int res = 0;
		for (const auto& word : words) {
			int x = -1;
			bool found = true;

			for (char c : word) {
				auto it = upper_bound(alpha[c - 'a'].begin (), 
                                      alpha[c - 'a'].end (), x);
				if (it == alpha[c - 'a'].end ()) found = false;
				else x = *it;
			}
			if (found) res++;
		}
		return res;
	}
```





## 栈

### 496. *Next Greater Element I

https://leetcode.com/problems/next-greater-element-i/description/

给定没有重复数字的序列 nums1 和 nums2, 其中 nums1 是 nums2 的子集, 也就是说 num1 中的元素都是 nums2 中的元素. 现在要在 num2 中查找 nums1 中每个元素的 next greater element.

The Next Greater Number of a number **x** in `nums1` is the first greater number to its right in `nums2`. If it does not exist, output -1 for this number.

num1 中 x 的 Next Greater Number 是 num2 中位于 x 右边的第一个大于 x 的元素.

**Example 1:**

```bash
Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.
```

**Example 2:**

```bash
Input: nums1 = [2,4], nums2 = [1,2,3,4].
Output: [3,-1]
Explanation:
    For number 2 in the first array, the next greater number for it in the second array is 3.
    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.
```

**Note:**

1. All elements in `nums1` and `nums2` are unique.
2. The length of both `nums1` and `nums2` would not exceed 1000.



思路: 这道题要维护一个单调栈. 思路参考: [Java 10 lines linear time complexity O(n) with explanation](https://leetcode.com/problems/next-greater-element-i/discuss/97595/Java-10-lines-linear-time-complexity-O(n)-with-explanation)

首先需要观察到如下结论:

假设我们已经有了一个单调递减的序列, 其最后面跟了一个更大的值, 比如: `[5, 4, 3, 2, 1, 6]`, 那么 6 就是序列中前面所有数的(5 ~ 1) 的 next greater number.

于是, 我们可以使用一个栈来维护一个 decreasing sub-sequence, 每当我们遇到一个元素 x 要比 `stack.top()` 还要大时, 那么就可以从栈中将所有比 x 小的元素给 pop 掉, 对于这些被 pop 掉的元素, 它们的 next greater Element 就是 x.

比如对于 [9, 8, 7, 3, 2, 1, 6], The stack will first contain `[9, 8, 7, 3, 2, 1]`,

and then we see `6` which is greater than `1` so we pop `1 2 3` whose next greater element should be `6`.

但是这道题还需要结合一个哈希表来记录对于 nums2 中每个元素对应的 next Greater Element 的索引是什么. 首先对于 nums2 中的元素, 将它们推入一个 decreasing stack, 然后用哈希表记录 next Greater Element 的索引. 之后对于 nums1 中的每个元素, 再通过哈希表查找 NGE.

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& findNums, vector<int>& nums) {
        vector<int> res(findNums.size(), -1);
        stack<int> s;
      	// nums[i] -> index of nums[nextGreaterElement] 
        unordered_map<int, int> record; 
      	// 首先遍历 num2, 求出每个元素的 NGE 的索引, 
      	// stack 中保存的是索引, 而哈希表中保存的是元素的值 -> NGE 的索引.
        for (int i = 0; i < nums.size(); ++i) {
            while (!s.empty() && nums[i] > nums[s.top()]) {
                record[nums[s.top()]] = i;
                s.pop();
            }
            s.push(i);
        }
      	// 针对 nums1 中的每个元素, 查找 NGE.
        for (int i = 0; i < findNums.size(); ++i)
            if (record.count(findNums[i]))
                res[i] = nums[record[findNums[i]]];

        return res;
    }
};
```



### 739. **Daily Temperatures

https://leetcode.com/problems/daily-temperatures/description/

Given a list of daily `temperatures`, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead.

For example, given the list `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`.

**Note:** The length of `temperatures` will be in the range `[1, 30000]`. Each temperature will be an integer in the range `[30, 100]`.



思路: 如果理解了上一题 496. Next Greater Element I, 就会发现, 其实这道题也是再求 NGE. 同样的, 需要使用一个单调栈, 从栈底到栈顶的元素是从大到小的, 比如 `[75, 71, 69]`, 那么当遇到 72 时, 将所有小于 72 的元素(71 和 69)弹出栈, 因为它们的 next Greater Element 都是 72.

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 维护一个单调栈, 使得栈里面的元素从栈底到栈顶
        // 是严格单调递减的
        vector<int> res(temperatures.size(), 0);
        stack<int> s;
        for (int i = 0; i < temperatures.size(); ++i) {
            while (!s.empty() && temperatures[i] > temperatures[s.top()]) {
                auto index = s.top();
                s.pop();
                res[index] = i - index;
            }
            s.push(i);
        }
        return res;
    }
};
```

leetcode 的官方解答为: https://leetcode.com/articles/daily-temperatures/

其中在 leetcode 的讨论中, [使用单调栈/哈希map](https://leetcode.com/problems/daily-temperatures/discuss/113898/map) 叙述得很清晰:

单调栈:

这个单调是对站内数据而言，也就是说，站内数据是有序的。递增或递减的。

假如有序列[75, 71, 69, 72, 76] ，栈s
`i = 0, s 75`
`i = 1`, 71比栈顶元素75小入栈 `s 75 71`
`i = 2`, 同理 `s 75 71 69`
`i = 3`, 72比栈顶元素大，此时不能入栈否则不能保证单调。
既然栈内是递减的，那么栈中比72小的数，从左至右其第一个比自身大的数就是72。将这两个找到目标数的元素pop出栈,并将72入栈。此时`s 75 72`。
i = 4, 76比栈顶元素大，同理72、75都找到了目标数76.







## 回溯法(Backtracking)

回溯, 沿着路径寻找答案, 一旦到底的话就回去继续去寻找
回溯法是暴力解法的一个主要实现手段. 一般来讲，会设置一个递归函数，函数的参数会携带一些当前的可能解的信息，根据这些参数得出可能解或者不可能而回溯。

[回溯算法（Backtracking）说明与实例](https://blog.csdn.net/leoleocs/article/details/47311283#t2) 这个博客关于回溯算法的介绍非常清晰.

### 78. **Subsets

https://leetcode.com/problems/subsets/description/

给定一个数组, 其中的元素都不相同, 返回这个数组所有的子集. 比如:

If **nums** = `[1,2,3]`, a solution is:

```bash
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```



思路: 给定一个长度为 n 的数组, 那么总共有 2 的 n 次方个子集. 如果使用 res 来保存这些子集的话, 

假设 A 表示 res 中的所有子集, 当访问元素 `nums[i]` 时, 将 `nums[i]` 加入到 A 的每个元素中, 就形成了新的子集 B, 然后更新 res 为 `A + B`. 即可.

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        vector<vector<int>> res;
        vector<int> cur;
        res.push_back(cur); // 初始时保存空子集
        while (i < n) {
          	// start 来遍历 res 中的每个子集.
          	// 下面注释看不懂那就不用管, 记录我曾写的一个 bug.
          	// 注意不要使用迭代器, 因为会在 res 中插入新的元素,
          	// 尾部迭代器 end 会失效. 所以这里使用索引 end.
            int start = 0;
            int end = res.size();
			// 依次访问 res 中的每个子集, 并将 nums[i] 加入到这些子集中
            while (start < end) { 
                cur = res[start];
                cur.push_back(nums[i]);
                ++start;
                res.push_back(cur);
            }
            ++i;
        }
        return res;
    }
};
```

leetcode 上给出了特别详细的讨论和总结:

[C++ Recursive/Iterative/Bit-Manipulation Solutions with Explanations](https://leetcode.com/problems/subsets/discuss/27278/C++-RecursiveIterativeBit-Manipulation-Solutions-with-Explanations)



### 17.  **Letter Combinations of a Phone Number

https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/

给定一个由数字组成的字符串, 返回这些数字所能表示的所有的字符组合. 这道题有个图, 即原来的诺基亚手机上每个数字下面对应多个字符, 把这些字符和数字对应起来就是: (其中 1 没有对应任何字符, 而 0 对应空格)

```c++
{'2', {"a", "b", "c"}},
{'3', {"d", "e", "f"}},
{'4', {"g", "h", "i"}},
{'5', {"j", "k", "l"}},
{'6', {"m", "n", "o"}},
{'7', {"p", "q", "r", "s"}},
{'8', {"t", "u", "v"}},
{'9', {"w", "x", "y", "z"}}
```

现在, 我给定数字组成的字符串 "23", 那么就能得到如下字符组合:

```bash
Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```



思路: 这是一个树型问题, 拿 "23" 来说, 2 对应的字符有 "a", "b", "c", 而 3 对应的字符有 "d", "e", "f". 组合在一起就有 9 种情况. 那么对于任意输入的数字串 digits, 思路一: 如果我能得到由 digits[1....n-1] 中的所有组合 A, 那么只要把 digits[0] 对应的每个字母, 加在 A 中的每个组合前即可. 下面两种解法的时间复杂度为 3^n = O(2^n)

解法一: 按照思路一的介绍, 可以理解为这是一棵向上生长的树, 直到生长到根(digit[0])为止.

```cpp
class Solution {
private:
    unordered_map<char, vector<string>> phone = {
        {'2', {"a", "b", "c"}},
        {'3', {"d", "e", "f"}},
        {'4', {"g", "h", "i"}},
        {'5', {"j", "k", "l"}},
        {'6', {"m", "n", "o"}},
        {'7', {"p", "q", "r", "s"}},
        {'8', {"t", "u", "v"}},
        {'9', {"w", "x", "y", "z"}}
    };
    vector<string> combinations(string &s, int i) {
      	// s 为空的时候, 返回的是空结果
        if (i >= s.size())
            return vector<string>{};
		// 这应该是真正的边界情况, 如果只剩最后一个数字了, 那么
      	// 返回去该数字对应的单个字符.
        if (i == s.size() - 1)
            return phone[s[i]];

        vector<string> res;
      	// combinations(s, i + 1) 求出了 digits[i+1, ...n-1] 的所有组合
      	// 只要将 digits[i] 对应的字符加在那些组合前面即可.
        for (auto &str : combinations(s, i + 1))
            for (auto &c : phone[s[i]])
                res.push_back(c + str);
        return res;
    }
public:
    vector<string> letterCombinations(string digits) {
        return combinations(digits, 0);
    }
};
```

思路二: 构建一棵向下生长的树, 即考虑完 digits[i] 后, 然后接着考虑 digits[i+1],... 持续这个过程一直到 digits[n - 1]. 这样的话, 就需要有个变量(引用), 来记录当考虑 digits[i+1] 时, 处理完 digits[i] 后得到的结果, 我在下面的代码设置为 cur.

```cpp
// 下面代码的写法有一点树往下生长的感觉
class Solution {
private:
    vector<string> res;
    unordered_map<char, vector<string>> phone = {
        {'2', {"a", "b", "c"}},
        {'3', {"d", "e", "f"}},
        {'4', {"g", "h", "i"}},
        {'5', {"j", "k", "l"}},
        {'6', {"m", "n", "o"}},
        {'7', {"p", "q", "r", "s"}},
        {'8', {"t", "u", "v"}},
        {'9', {"w", "x", "y", "z"}}
    };
    void combinations(string &s, int i, const string &cur) {
      	// 遍历到底的话, 就将结果加入到 res 中.
        if (i == s.size())
            res.push_back(cur);
        vector<string> letters = phone[s[i]];
        for (auto &c : letters)
          	// 注意这里产生右值, 所以 combitions 最后一个参数需要是 const 的
            combinations(s, i + 1, cur + c); 
    }
public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty())
            return {};
        res.clear(); // 初始化 res
        combinations(digits, 0, "");
        return res;
    }
};
```



### 39. **Combination Sum

https://leetcode.com/problems/combination-sum/description/

Given a **set** of candidate numbers (**C**) **(without duplicates)** and a target number (**T**), find all unique combinations in **C** where the candidate numbers sums to **T**.

The **same** repeated number may be chosen from **C** unlimited number of times.

**Note:**

- All numbers (including target) will be positive integers.
- The solution set must not contain duplicate combinations.

For example, given candidate set `[2, 3, 6, 7]` and target `7`, 
A solution set is: 

```bash
[
  [7],
  [2, 2, 3]
]
```

注意元素可以重复选取.



思路: 观察上面的例子可以看到, 由于元素可以重复选取, 可能会得到如下结果:

```bash
[2, 2, 3]
[2, 3, 2]
```

但是它们是重复的结果, 所以要舍去一个. 因此, 为了得到 unique 的结果, 最好将  candidate set 进行排序, 当选取了 3, 就不应该再选取 2 了. 也就是说, 每次选取 nums[i] 时, 之后递归只能选取 nums[i] 以及之后的数字, 而不能选取 nums[0, ... i-1] 那些数字, 否则可能发生重复.

我的回溯是假回溯. 要学真回溯应该去看看讨论组. 这里谈下我的思路. 对于 candidate set 中的每个元元素值 `nums[i]` (注意为了避免重复以及将 set 从小到大排序了), 判断它是否和 target 相等, 如果相等就可以加入到 res 中. 否则再判断 `f(target - nums[i])` 返回的满足 sum 等于 `target - nums[i]` 的序列是否为空, 如果不为空, 则将 `nums[i]` 分别加入到这些序列中即可.

```cpp
class Solution {
private:
  	// start 的使用非常关键, 因为它可以避免最后结果不唯一. 由于 candidates 先排好序了,
  	// 当当前 combinations 使用了 nums[start], 那之后递归调用 combinations 时只能使用
  	// nums[start....n-1] 中的值.
    vector<vector<int>> combinations(vector<int> &candidates, int target, int start) {
        vector<vector<int>> res;
        for (int i = start; i < candidates.size() && candidates[i] <= target; ++i) {
            if (candidates[i] == target)
                res.push_back({candidates[i]});
          	// 对于不等于 target 的 candidates[i], 判断 
          	// sum 为 target - candidates[i] 的序列有哪些.
            auto conditions = combinations(candidates, target - candidates[i], i);
            if (!conditions.empty()) {
                for (auto &condition : conditions) {
                    condition.push_back(candidates[i]);
                    res.push_back(condition);
                }
            }
        }
        return res;
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if (target <= 0)
            return {};
        std::sort(candidates.begin(), candidates.end());
        return combinations(candidates, target, 0);
    }
};
```

以下两个正宗一些的 Backtracking 可以学习:

[Accepted 16ms c++ solution use backtracking, easy understand.](https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.)

[Almost same solution for two problems Combination Sum and Combination Sum II , C++  Code with comments ,fast](https://leetcode.com/problems/combination-sum/discuss/16666/Almost-same-solution-for-two-problems-Combination-Sum-and-Combination-Sum-II-C++-Code-with-comments-fast)



### 40. **Combination Sum II

https://leetcode.com/problems/combination-sum-ii/description/

Given a collection of candidate numbers (**C**) and a target number (**T**), find all unique combinations in **C** where the candidate numbers sums to **T**.

Each number in **C** may only be used **once** in the combination.

**Note:**

- All numbers (including target) will be positive integers.
- The solution set must not contain duplicate combinations.

For example, given candidate set `[10, 1, 2, 7, 6, 1, 5]` and target `8`, 
A solution set is: 

```bash
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```



思路: 和第一题的区别是, candidate set 中存在重复元素, 但是每个元素只能用一次. 由于存在重复元素, 还是有必要先排序, 并引入 start(参见 39. Combination Sum). 之后的思路是一致的.

```cpp
class Solution {
private:
    vector<vector<int>> combinations(vector<int> &candidates, int target, int start) {
        vector<vector<int>> res;
        for (int i = start; i < candidates.size() && candidates[i] <= target; ++i) {
          	// 如果 candidates[i] 和 candidates[i - 1] 相等, 那么就没有必要再考虑了,
          	// 因为在访问 candidates[i - 1] 时, 已经把考虑 candidates[i] 时的所有情况
          	// 都包含了.
            if (i > start && candidates[i] == candidates[i - 1])
                continue;
            if (candidates[i] == target)
                res.push_back({candidates[i]});
          	// 注意 start 更新到 i+1, 因为 candidates 中的每个元素只能用一次.
          	// 当 candidates[i] 和 target 不相等时, 求出 sum 等于 
          	// target - candidates[i] 的子序列.
            auto conditions = combinations(candidates, target - candidates[i], i + 1);
            if (!conditions.empty()) {
                for (auto &condition : conditions) {
                    condition.push_back(candidates[i]);
                    res.push_back(condition);
                }
            }
        }
        return res;
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        if (target <= 0)
            return {};
        std::sort(candidates.begin(), candidates.end());
        return combinations(candidates, target, 0);
    }
};
```



### 216. **Combination Sum III

https://leetcode.com/problems/combination-sum-iii/description/

Find all possible combinations of **\*k*** numbers that add up to a number **\*n***, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

Example 1:

Input: k= 3, n = 7

Output:

```bash
[[1,2,4]]
```

Example 2:

Input: k= 3, n = 9

Output:

```bash
[[1,2,6], [1,3,5], [2,3,4]]
```

题意: 从 1 到 9 中选出 k 个数, 使它们的和等于 target n. 结果之间不重复.



思路: 这道题和 39. Combination Sum 的区别在于, 这里规定了必须是 k 个数, 由于候选数组已经确定了是 1 ~ 9 这 9 个数字, 所以不需要排序了. 当时为了防止结果之间有重复, 仍需要设置 start, 当访问到 start 时, 下次迭代只能访问 start 以及 start 之后的元素. 由于规定了必须是 k 个数组成的结果, 所以我在下面的代码中, 给 `combinations` 函数多设置了两个参数 level 以及 thisk, 分别表示当前递归调用 combinations 的次数, 以及 k 值是多少. 只有当 level 和 thisk 相等时, 说明递归调用的次数已经到了 k 次, 才可以将结果加入到 res 中.

```cpp
class Solution {
private:
    vector<vector<int>> combinations(int k, int n, int level, int thisk, int start) {
        vector<vector<int>> res;
        if (k <= 0 || n < 1)
            return res;
        for (int i = start; i < 10; ++i) {
          	// 只有当递归调用的 level 已经到了 thisk, 才可以将
          	// 结果加入到 res 中.
            if (i == n && level == thisk)
                res.push_back({i});
          	// 考虑 n - i 的返回结果, 如果 conditions 不为空的话,
          	// 说明存在使得 k - 1 个元素的和等于 n - i, 那么此时将 
          	// i 加入到 res 中即可.
            auto conditions = combinations(k - 1, n - i, level + 1, thisk, i + 1);
            if (!conditions.empty()) {
                for (auto &condition : conditions) {
                    if (condition.size() == k - 1) {
                        condition.push_back(i);
                        res.push_back(condition);
                    }
                }
            }
        }
        return res;

    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        return combinations(k, n, 1, k, 1);
    }
};
```















