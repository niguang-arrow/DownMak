# Array

## 数组

(刚刚发现 283, 27, 26, 80 这四题其实是同一类型的题, 都是将元素从数组中删除)

### 283. *Move Zeros

https://leetcode.com/problems/move-zeroes/

将数组中的 0 都挪到数组的尾部, 并且保持原来非零元素在数组中的顺序.

思路是: 要引入一个索引 k 来使得 `nums[0....k]` 范围内的元素原数组中大于零的值, `nums[k+1...n-1]` 范围内的值等于零. 对于当前访问的元素 `nums[i]` 来说, 如果它等于零, 我们只要访问下一个元素即可. 而当 `nums[i]` 不等于 0 时, 只要和 `nums[k + 1]` 交换即可.(我明白了, 到这里可以得到这样的结论, 比如我明确了 `nums[0...k]` 的意义, 那么后面的操作就是很正常了)

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if (nums.empty())
            return;

        // arr[0...k] 保存所有非零元素
      	// 初始为 -1 说明 arr[0, k] 中无元素. 如果初始化为 0, 
      	// 那么下面使用 nums[k++]
        int k = -1; 
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != 0) {
                if (i != (k + 1))
                    swap(nums[i], nums[++k]);
                else
                    ++k;
            }
        }
    }
};
```



### 27. *Remove Element

https://leetcode.com/problems/remove-element/description/

将数组中等于 val 的所有元素给删除(移到数组末尾), 并返回其他非 val 元素的长度.

思路: 其实这道题就是 283. move zeros 的变形, 只不过前面是将 0 移到末尾, 这里是将 val 移到末尾.

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if (nums.empty())
            return nums.size();

        // arr[0...k] 保存不等于 val 的元素
        int k = -1;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != val) {
                if (i != (k + 1))
                    swap(nums[i], nums[++k]);
                else
                    ++k;
            }
        }
        return k + 1;
    }
};
```



### 26. *Remove Duplicates from Sorted Array

https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/

将排序数组中的重复数字给去除, 并返回新数组的长度. 注意只能原地修改数组, 使用 O(1) 的额外空间.

思路: 其实和 283. Move Zeros 的思路一致, 要使用两个下标, 一个下标 i 用于遍历数组, 另一个下标 k 用于记录不重复数组的范围, 比如下面的代码中, 我令 `arr[0....k]` 范围内的元素是不重复的. 这样的话, 访问到当前元素 `arr[i]` 时, 就得和 `arr[k]` 进行比较, 如果等于 `arr[k]` 的话, 说明是重复的, 因此只需遍历下一个元素; 而如果当前元素与 `arr[k]` 不相等, 那么就使 `arr[k+1] = arr[i]`, 并且 k 要移动到下一位.

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
            if (nums.empty())
                return 0;

            int k = 0;
            // nums[0, k] 范围内的数应是没有重复的
            for (int i = 1; i < nums.size(); ++i) {
                if (nums[i] != nums[k]) {
                  	// 有的答案没有下面这个 if else 条件判断, 直接使用
                  	// nums[++k] = nums[i]; 我是说, 如果当前访问的元素
                  	// 就是 arr[k] 的下一位, 并且和 arr[k] 不相等, 那么
                  	// 直接将 k 移向下一位即可.
                    if (i != (k + 1))
                        nums[++k] = nums[i];
                    else
                        ++k;
                }
            }
      		// nums.resize(k + 1) 实际上不需要
            nums.resize(k + 1);
            return k + 1;
    }
};
```

### 80. **Remove Duplicates from Sorted Array II

https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/

承接上面的 26 题, 但是这次允许数组中重复数字最多出现两次. 比如 `nums = {1, 1, 1, 2, 2, 3}` 时, 结果为 5, `{1, 1, 2, 2, 3}`. 首

首先思路是, 当访问 `nums[i]` 时, 它要和 `nums[k - 1]` 进行比较, 其中 `nums[0....k]` 保存着满足条件的元素. 这样的话, 代码能允许重复数字最多出现两次.

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
            if (nums.size() <= 2)
                return nums.size();

            int k = 1;
            for (int i = 2; i < nums.size(); ++i) {
                if (nums[i] != nums[k - 1]) {
                    nums[++k] = nums[i];
                }
            }
            return k + 1;

    }
};
```

### 33. Search in Rotated Sorted Array

https://leetcode.com/problems/search-in-rotated-sorted-array/description/

将一个排序数组进行旋转, 然后在其中搜索某个数. 比如 `[0, 1, 2, 3, 4, 5]` 旋转后为 `[3, 4, 5, 0, 1, 2]`, 然后在旋转后的数组中搜索.

思路: 使用二分查找, 关键在于边界的确定. (参考了 leetcode-cpp.pdf 上 2.1.3 的解答)

要分情况讨论, 当访问 nums[mid] 时, 考虑两种情况, nums[mid] 是大于或等于 nums[left] 呢, 还是小于 nums[left]. 在这两种情况下, 又要考虑 target 和 nums[mid] 以及 nums[left] 的关系.

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if (nums.empty())
            return -1;

        int l = 0, r = nums.size() - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] >= nums[l]) { // 说明 nums[l...mid] 是排序好的
                if (target >= nums[l] && target < nums[mid])
                    r = mid - 1;
                else
                    l = mid + 1;
            }
            else {// 说明 nums[mid...r] 是排序好的
                if (target < nums[l] && target > nums[mid])
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return -1;
    }
};
```



### 81. Search in Rotated Sorted Array II

https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/

在上一题的基础上, 如果排序数组中有重复元素会怎样? 比如数组 `{1, 2, 2, 2, 2, 3, 4}` 旋转之后成了

`{2, 2, 3, 4, 1, 2, 2}`. 

思路: 出现重复元素的话, 那么在 33. Search in Rotated Sorted Array 中使用的 `nums[mid] >= nums[l]` 就不能判定 `nums[l....mid]` 为递增序列了. 这个时候可以将其拆分为两个条件:

- 如果 nums[mid] > nums[l], 那么 nums[l....mid] 一定是递增的;
- 如果 nums[mid] == nums[l], 无法确认状况, 那么就令 `l++`, 往下看一步即可.

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        if (nums.empty())
            return false;

        int l = 0, r = nums.size() - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target)
                return true;
            if (nums[mid] > nums[l]) {
                if (target >= nums[l] && target < nums[mid])
                    r = mid - 1;
                else
                    l = mid + 1;
            }
            else if (nums[mid] == nums[l]) {
                l ++;
            }
            else {
                if (target < nums[l] && target > nums[mid])
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return false;
    }
};
```

可是我没想到下面的解法还更快... 来自 leetcode

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] == target) return true;
        }
        return false;
    }
};
```





### 75. **Sort Colors

https://leetcode.com/problems/sort-colors/description/

将只 0, 1, 2 三个元素的长度为 n 的数组排序.

思路: 一方面可以使用计数排序, 使用一个大小为 3 的数组来统计每个元素的个数; 另一方面使用三路快排的思路.

首先, 使用计数排序:

```cpp
class Solution {
public:
    // 使用计数排序
    void sortColors(vector<int>& nums) {
        if (nums.empty())
            return;

        int count[3] = {0};
        for (const auto &d : nums)
            count[d]++;

        int index = 0;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < count[i]; j++) {
                nums[index++] = i;
            }
        }
    }
};
```

下面是使用三路快排的思路:

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        if (nums.empty())
            return;
        
        // nums[0... lt] 保存 0
        // nums[lt+1....i] 保存 1
        // nums[gt....n-1] 保存 2
        int lt = -1, gt = nums.size();
        int i = 0;
        while (i < gt) {
            if (nums[i] == 1)
                ++i;
            else if (nums[i] == 0)
                swap(nums[i++], nums[++lt]);
            else
                swap(nums[i], nums[--gt]);
        }
    }
};
```



### 1. Two Sum

https://leetcode.com/problems/two-sum/description/

给定一个整数序列, 要求返回两个索引, 它们对应的两个值的和等于 target. (此题的测试可以假设肯定是有一个解的, 另外, 不能将同一个值使用两次, 比如数组中有一个数字 4, target 为 8, 不能说 4 + 4 = 8). 比如 `[2, 7, 11, 15]`, target 为 9, 那么返回 `[0, 1]`.

思路: 等下会做另一道类似的题, 但是是在有序数组中查找两个数, 使得它们的和与 target 相等. 但这道题的不同之处在于, 它的数组是无序的, 而排序太浪费时间, 如果要在遍历过程中实现目的, 那么需要快速查找的方法, 这个时候只好考虑使用空间来换取时间, 因此引入哈希表来对元素进行查找, 时间复杂度为 O(1), 空间复杂度为 O(n), 保存元素本身以及它对应的索引. 当访问元素 `nums[i]` 时, 在哈希表中查找 `nums[target - nums[i]]` 是否存在, 如果存在, 那么就保存索引; 否则将 `nums[i]` 以及索引 i 加入到哈希表中.(代码中的 `swap(i, j)` 是为了是返回结果中的索引的顺序是从小到大的.)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        if (nums.size() < 2)
            throw invalid_argument("nums' size invalid");

        unordered_map<int, int> hash_map;
        for (int i = 0; i < nums.size(); ++i) {
            auto iter = hash_map.find(target - nums[i]);
            if (iter != hash_map.end()) {
                int j = iter->second;
                if (i > j)
                    std::swap(i, j);
                int res[2] = {i, j};
                return vector<int>(res, res+2);
            }
            else
                hash_map.insert(std::make_pair(nums[i], i));
        }
    }
};
```



### 167. *Two Sum II - Input array is sorted

https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/

与上一题不同的地方是, 数组是排序的, 因此可以使用对撞指针. 要找到两个数等于 target, 由于数组是排序的, 那么这两个数必然是一左一右, 那么可以使用两个指针, 从数组的起始和尾部开始搜索, 如果 `nums[i] + nums[j]` 刚好等于 target, 那么, 直接返回. 如果和的结果小于 target, 那么说明 `nums[i]` 小了, 要增大, 应该 `++i`; 如果结果大于 target, 说明 `nums[j]` 大了, 应该 `--j`.

另外, 注意一点: **题目中要求是返回的索引从 1 开始, 因此, i 和 j 要加 1.**

由于代码 while 外面没有 return, 编译器会给出警告, 可以使用 `return {}` 解决.

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        if (numbers.size() < 2)
            throw invalid_argument("numbers' size invalid");

        int i = 0, j = numbers.size() - 1;
        // 由于结果返回两个, 所以i和j肯定不相等
        while (i < j) {
            if (numbers[i] + numbers[j] == target) {
                int res[2] = {i+1, j+1};
                return vector<int>(res, res + 2);
            }
            else if (numbers[i] + numbers[j] < target)
                ++i;
            else
                --j;
        }
    }
};
```



### 15. 3Sum

https://leetcode.com/problems/3sum/description/

给定含 n 个整数的数组 S, 找出是否存在 3 个整数使得 a + b + c = 0. 把所有不重复的三元组给找出来. 比如:

```bash
For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```



思路: 首先给数组排序, 然后遍历整个数组(直到 `nums.size() - 2` 的位置), 每一次访问的 `nums[i]` 可以作为三元组的首位元素, 这样可以保证所有的三元组不重复(当然其实还有另外的约束, 下面谈到), 然后针对 `nums[i + 1, .... n - 1]` 范围内的元素, 进行 2sum 操作, 即使用对撞指针. 但还需要考虑的两点是, `nums[i+1, .... n-1]` 中可能有多个 pair 满足 2sum, 另外也会有大量的重复元素, 因此在进行 2sum 的时候, 要使用 while 循环将这些相同的元素给略过. 

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.size() < 3)
            return {};

        vector<vector<int>> res;
        std::sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; ++i) {
          	// 当 i == 0 时, 进行判断; 当 i > 0 时, 需要判断 nums[i]
          	// 是否和前一个元素相等, 如果相等, 就不需要考虑了.
            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {
                int lo = i + 1, hi = nums.size() - 1, target = 0 - nums[i];
                while (lo < hi) {
                    vector<int> path;
                  	// 注意, 当在 nums[i+1, .... n-1] 范围内找到了 target, 在考虑
                  	// 下一个 pair 之前, 还要使用两个 while 循环判断 nums[lo] 和 
                  	// nums[lo+1] 是否相等.
                    if (nums[lo] + nums[hi] == target) {
                        path.insert(path.end(), {nums[i], nums[lo], nums[hi]});
                        res.push_back(path);

                        while (lo < hi && nums[lo] == nums[lo + 1]) lo ++;
                        while (lo < hi && nums[hi] == nums[hi - 1]) hi --;
                        lo ++;
                        hi --;
                    }
                    else if (nums[lo] + nums[hi] < target)
                        lo ++;
                    else
                        hi --;
                }
            }
        }
        return res;
    }
};
```

针对 3元组的首个元素可能会重复的问题, 还有另外的写法:

[Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments](https://leetcode.com/problems/3sum/discuss/7402/Share-my-AC-C++-solution-around-50ms-O(N*N)-with-explanation-and-comments)

```cpp
vector<vector<int> > threeSum(vector<int> &num) {
    
    vector<vector<int> > res;

    std::sort(num.begin(), num.end());

    for (int i = 0; i < num.size(); i++) {
        
        int target = -num[i];
        int front = i + 1;
        int back = num.size() - 1;

        while (front < back) {

            int sum = num[front] + num[back];
            
            // Finding answer which start from number num[i]
            if (sum < target)
                front++;

            else if (sum > target)
                back--;

            else {
                vector<int> triplet(3, 0);
                triplet[0] = num[i];
                triplet[1] = num[front];
                triplet[2] = num[back];
                res.push_back(triplet);
                
                // Processing duplicates of Number 2
                // Rolling the front pointer to the next different number forwards
                while (front < back && num[front] == triplet[1]) front++;

                // Processing duplicates of Number 3
                // Rolling the back pointer to the next different number backwards
                while (front < back && num[back] == triplet[2]) rear--;
            }
            
        }
		// 在这里考虑三元组的首元素可能重复的问题.
        // Processing duplicates of Number 1
        while (i + 1 < num.size() && num[i + 1] == num[i]) 
            i++;

    }
    
    return res;
    
}
```



### 16. 3Sum Closet

https://leetcode.com/problems/3sum-closest/description/

给定一个整数数组 S, 在其中找到 3 个整数使得它们的和接近一个给定的 target. 返回这 3 个数的和. (可以假设所有的测试用例中只有一个解) 比如:

```bash
For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```



思路: 类似于 15. 3Sum. 为了得到最接近 target 的值, 要计算使 `std::abs(target - sum)` 最小的那个 sum. 为了得到这些 sum, 和 3Sum 一样, 首先对数组进行排序, 然后固定 nums[i], 再对后面的内容进行 2Sum.

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        if (nums.size() < 3)
            return accumulate(nums.begin(), nums.end(), 0);

        int res = nums[0] + nums[1] + nums[nums.size() - 1];
        std::sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; ++i) {
            int lo = i + 1, hi = nums.size() - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi] + nums[i];
                if (sum == target)
                    return sum;
                if (sum > target)
                    hi --;
                else {
                    lo ++;
                }
                if (std::abs(target - sum) < std::abs(target - res))
                    res = sum;
            }
        }
        return res;
    }
};
```

再看一个 leetcode 上解释非常详细的:

[A n^2 Solution, Can we do better ?](https://leetcode.com/problems/3sum-closest/discuss/7873/A-n2-Solution-Can-we-do-better)

```cpp
int threeSumClosest(vector<int> &num, int target) {        
    vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.
    int n = 0;
    int ans = 0;
    int sum;
    
    sort(v.begin(), v.end());
    
    // If less then 3 elements then return their sum
    while (v.size() <= 3) {
        return accumulate(v.begin(), v.end(), 0);
    }
    
    n = v.size();
    
    /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]
     *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. 
     * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that 
     * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.
     * if the sum of the triplet is greater then the target it implies
     * we need to reduce our sum, so we do K = K - 1, that is we reduce
     * our sum by taking a smaller number.
     * Simillarly if sum of the triplet is less then the target then we
     * increase out sum by taking a larger number, i.e. J = J + 1.
     */
    ans = v[0] + v[1] + v[2];
    for (int i = 0; i < n-2; i++) {
        int j = i + 1;
        int k = n - 1;
        while (j < k) {
            sum = v[i] + v[j] + v[k];
            if (abs(target - ans) > abs(target - sum)) {
                ans = sum;
                if (ans == target) return ans;
            }
            (sum > target) ? k-- : j++;
        }
    }
    return ans;
}
```



### 18. 4Sum

https://leetcode.com/problems/4sum/description/

给定一个整数数组和给定的 target, 是否存在 a, b, c, d 4个整数使得它们的和满足 a+b+c+d = target? 返回所有不重复的 (a, b, c, d) 四元组.

```bash
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```



思路: 首先固定 a, 然后再使用 3Sum 的方法求解.

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        if (nums.size() < 4)
            return {};

        std::sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> path;
        for (int i = 0; i < nums.size() - 3; ++i) {
          for (int j = i + 1; j < nums.size() - 2; ++j) {
            int lo = j + 1, hi = nums.size() - 1;
            while (lo < hi) {
              int sum = nums[i] + nums[j] + nums[lo] + nums[hi];
              if (sum == target) {
                path = {nums[i], nums[j], nums[lo], nums[hi]};
                res.push_back(path);
                while (lo < hi && nums[lo] == nums[lo + 1]) lo ++;
                while (lo < hi && nums[hi] == nums[hi - 1]) hi --;
                lo ++;
                hi --;
              }
              else if (sum < target)
                lo ++;
              else
                hi --;
            }
            while (j + 1 < nums.size() - 2 && nums[j + 1] == nums[j]) ++j;
          }
          while (i + 1 < nums.size() - 3 && nums[i + 1] == nums[i]) ++i;
        }
        return res;
    }
};
```

不知道为什么, 下面 leetcode 上的解答和我的逻辑类似, 但是运算速度比我的快:

[4Sum C++ solution with explanation and comparison with 3Sum problem. Easy to understand.](https://leetcode.com/problems/4sum/discuss/8714/4Sum-C++-solution-with-explanation-and-comparison-with-3Sum-problem.-Easy-to-understand.)

```cpp
class Solution {
public:
    vector<vector<int> > fourSum(vector<int> &num, int target) {
    
        vector<vector<int> > res;
    
        if (num.empty())
            return res;
    
        std::sort(num.begin(),num.end());
    
        for (int i = 0; i < num.size(); i++) {
        
            int target_3 = target - num[i];
        
            for (int j = i + 1; j < num.size(); j++) {
            
                int target_2 = target_3 - num[j];
            
                int front = j + 1;
                int back = num.size() - 1;
            
                while(front < back) {
                
                    int two_sum = num[front] + num[back];
                
                    if (two_sum < target_2) front++;
                
                    else if (two_sum > target_2) back--;
                
                    else {
                    
                        vector<int> quadruplet(4, 0);
                        quadruplet[0] = num[i];
                        quadruplet[1] = num[j];
                        quadruplet[2] = num[front];
                        quadruplet[3] = num[back];
                        res.push_back(quadruplet);
                    
                        // Processing the duplicates of number 3
                        while (front < back && num[front] == quadruplet[2]) ++front;
                    
                        // Processing the duplicates of number 4
                        while (front < back && num[back] == quadruplet[3]) --back;
                
                    }
                }
                
                // Processing the duplicates of number 2
                while(j + 1 < num.size() && num[j + 1] == num[j]) ++j;
            }
        
            // Processing the duplicates of number 1
            while (i + 1 < num.size() && num[i + 1] == num[i]) ++i;
        
        }
    
        return res;
    
    }
};
```

这道题在 leetcode-cpp.pdf 上还有两种使用 hash 表进行求解的方法, 展示如下, 但都不是很快.

这是使用 `unordered_map` 的:

```cpp
// LeetCode, 4Sum
// 用一个 hashmap 先缓存两个数的和
// 时间复杂度，平均 O(n^2)，最坏 O(n^4)，空间复杂度 O(n^2)
class Solution {
public:
   vector<vector<int> > fourSum(vector<int> &num, int target) {
       vector<vector<int>> result;
       if (num.size() < 4) return result;
       sort(num.begin(), num.end());
       unordered_map<int, vector<pair<int, int> > > cache;
       for (size_t a = 0; a < num.size(); ++a) {
           for (size_t b = a + 1; b < num.size(); ++b) {
               cache[num[a] + num[b]].push_back(pair<int, int>(a, b));
           }
       }
       for (int c = 0; c < num.size(); ++c) {
           for (size_t d = c + 1; d < num.size(); ++d) {
               const int key = target - num[c] - num[d];
               if (cache.find(key) == cache.end()) continue;
               const auto& vec = cache[key];
               for (size_t k = 0; k < vec.size(); ++k) {
                   if (c <= vec[k].second)
                       continue; // 有重叠
                   result.push_back( { num[vec[k].first],
                           num[vec[k].second], num[c], num[d] });
               }
           }
       }
       sort(result.begin(), result.end());
       result.erase(unique(result.begin(), result.end()), result.end());
       return result;
   }
};
```

下面是使用 multimap 的:

```cpp
// LeetCode, 4Sum
// 用一个 hashmap 先缓存两个数的和
// 时间复杂度 O(n^2)，空间复杂度 O(n^2)
// @author 龚陆安 (http://weibo.com/luangong)
class Solution {
public:
   vector<vector<int>> fourSum(vector<int>& num, int target) {
       vector<vector<int>> result;
       if (num.size() < 4) return result;
       sort(num.begin(), num.end());
       unordered_multimap<int, pair<int, int>> cache;
       for (int i = 0; i + 1 < num.size(); ++i)
           for (int j = i + 1; j < num.size(); ++j)
               cache.insert(make_pair(num[i] + num[j], make_pair(i, j)));
       for (auto i = cache.begin(); i != cache.end(); ++i) {
           int x = target - i->first;
           auto range = cache.equal_range(x);
           for (auto j = range.first; j != range.second; ++j) {
               auto a = i->second.first;
               auto b = i->second.second;
               auto c = j->second.first;
               auto d = j->second.second;
               if (a != c && a != d && b != c && b != d) {
                   vector<int> vec = { num[a], num[b], num[c], num[d] };
                   sort(vec.begin(), vec.end());
                   result.push_back(vec);
               }
           }
       }
       sort(result.begin(), result.end());
       result.erase(unique(result.begin(), result.end()), result.end());
       return result;
   }
};
```





### 454. 4Sum II

https://leetcode.com/problems/4sum-ii/description/

给定 4 个整型数组, 计算有多少个 `(i, j, k, l)` 四元组使得 `A[i] + B[j] + C[k] + D[l]` 的结果为 0.

(为了让问题简单一些, 假设所有的数组中元素数量为 0 <= N <= 500, 并且和的结果不超过 `2^31 - 1`), 比如:

```bash
Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```



思路: 使用一个查找表, 记录 `A[i] + B[j]` 的和, 然后分析 C 和 D 中元素的和, 判断查找表中是否存在 `0 - C[k] - D[l]`.

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        // 使用 record 记录 A[i] + B[j] 的和有多少个
        unordered_map<int, int> record;
        for (int i = 0; i < A.size(); ++i)
            for (int j = 0; j < B.size(); ++j)
                record[A[i] + B[j]] ++;

        int res = 0;
        for (int i = 0; i < C.size(); ++i) {
            for (int j = 0; j < D.size(); ++j) {
                auto iter = record.find(0 - C[i] - D[j]);
                if (iter != record.end())
                    res += iter->second;
            }
        }
        return res;
    }
};
```





### 653. Two Sum IV - Input is a BST(未完)

https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/

依然是 two sum, 但是在一棵二叉搜索树上查找, 返回 True 或 False. 比如

```bash
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
```



### 88. *Merge Sorted Array

https://leetcode.com/problems/merge-sorted-array/description/

给定两个有序数组 num1 和 num2, 将两个数组中的元素有序的合并到 num1 中. 注意 nums1 的大小可以认为比 `m + n` 要大.

思路: 就是归并排序的思路, 但是要注意, 由于并没有额外的申请新的空间, 而是将数组保存到 nums1 上, 因此在 nums1 中需要从后向前开始排序, 并且还要将 nums1 中元素中与 nums2 的元素中选出最大的开始比较. 另外还需要注意 m 和 n 不能同时为 0, 但可以有一个为 0.

```cpp
class Solution {
public:
    // 注意题目已经假设 nums1 的大小至少和 m + n 一样大
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
      	// 这里在两者都小于 1 的情况下才返回, leetcode 有一个测试用例就是 m = 0,
      	// n = 1 这样也是可以的.
        if (m < 1 && n < 1)
            return;
		// 在 nums1 的末尾开始, 实现两个数组的归并.
        int k = m + n - 1;
        int i = m - 1, j = n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] < nums2[j])
                nums1[k--] = nums2[j--];
            else
                nums1[k--] = nums1[i--];
        }

        while (i >= 0)
            nums1[k--] = nums1[i--];
        while (j >= 0)
            nums1[k--] = nums2[j--];
    }
};
```



### 215. Kth Largest Element in an Array

https://leetcode.com/problems/kth-largest-element-in-an-array/description/

在一个未排序的数组中找到第 k 个最大的元素. 这个 k 指的是排好序后的第 k 个最大元素. 比如:

Given `[3,2,1,5,6,4]` and k = 2, return 5. (可以假设 `1 <= k <= arr.size()`)

思路: 目前的思路是使用快排的思路, 利用 partition 找到第 (k - 1) 个元素(将元素从大到小排序). 另外的思路可以使用一个优先队列, 返回第 k - 1 个元素.

```cpp
class Solution {
private:
  	// 使用两路快排的思路, 注意在 while 循环中, 我使用 >= v 的
  	// 元素放在前头, 使得左边的元素大于 v, 右边的元素小于 v
    int partition(vector<int> &nums, int l, int r) {
        if (l > r)
            return -1;

        int v = nums[l];
        // 注意 arr[l.... i) >= v, arr(j.... r] <= v
        // 以及i 和 j 的初始化, 要使得这两个集合都是空集.
        int i = l + 1, j = r;
        while (true) {
            while (i <= r && nums[i] >= v) i++;
            while (j >= l+1 && nums[j] <= v) j--;
            if (i > j)
                break;
            std::swap(nums[i++], nums[j--]);
        }
        std::swap(nums[l], nums[j]);
        return j;
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        if (nums.empty())
            return -1;
		
      	//while 中使用 index + 1 是因为数组从 0 开始计数, 而
      	// k 从 1 开始计数.
        int index = partition(nums, 0, nums.size() - 1);
        while ((index + 1) != k) {
            if ((index + 1) < k)
                index = partition(nums, index + 1, nums.size() - 1);
            else
                index = partition(nums, 0, index - 1);
        }
        return nums[index];
    }
};
```

下面是使用优先队列的代码:

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq(nums.begin(), nums.end());
        for(int i = 0; i < k-1; i++){
            pq.pop();
        }
        return pq.top();
    }
};
```



### 11. **Container With Most Water

https://leetcode.com/problems/container-with-most-water/description/

使容器盛上最多的水. 给定 n 个非负的整数 $a_1, a_2, ..., a_n$, 每一个表示位于 $(i, a_i)$ 处的点. 以 $(i, 0)$ 和 $(i, a_i)$ 为端点可以作 n 条垂直的直线. 其中, 每两条直线和 x 轴可以组成一个容器, 现在要找到两条直线, 它们和 x 轴形成的容器容量最大.

思路: 这个问题我第一次提交写错了, 给出我在给出的数组为 `height = {2,3,10,5,7,8,9}` 时报错, 正确的结果是 36, 可以看出是当 `i = 2, j = 6, height[i] = 10, height[j] = 9` 时得到最大值. 这道题应该采用双指针对撞的技术来减少考虑的情况. 但问题的关键是以什么标准来让两个指针进行移动. 通过仔细观察 height 可以发现, 当 `i = 0, j = n - 1` 时, 假设最大值 `res` 就是当前的容量, 那么之后 i he j 要怎样移动呢? 注意到 2 要比 9 小, 移动是必然要做的, 不管是 i 向右移动, 还是 j 向左移动, x 轴的大小总是要减小 1 的, 但是由于 2 比 9 小, 那么应该将 i 向右移动, 因为下一个 `height[i + 1]` 可能会使得容量最大, 因为如果 `height[i + 1]` 足够高, 而 9 也是一个比较大的值, 那么就有可能获得更大的容量. 

通过以上的分析, 就知道了 i 和 j 的移动规律, 也就是如果 `height[i] < height[j]`, 那么就将 i 向右移动, 反之, 则将 j 向左移动.

```cpp
class Solution {
private:
  	// 用于计算面积
    int Area(int i, int j, int ai, int aj) {
        return (j - i) * min(ai, aj);
    }
public:
    int maxArea(vector<int>& height) {
        if (height.empty())
            return 0;
		// res 保存最大值
        int i = 0, j = height.size() - 1;
        int res = Area(i, j, height[i], height[j]);
      	// 关于循环结束的条件, 是 i 和 j 至少有一个距离
      	// 在 if 后面的语句中, 即使 ++i == j, 也没有关系
      	// 这个时候的 Area 就是 0, 依然能得到正确的最大容量.
        while (i < j) {
            if (height[i] < height[j]) {
                ++i;
                res = max(res, Area(i, j, height[i], height[j]));
            }
            else {
                --j;
                res = max(res, Area(i, j, height[i], height[j]));
            }
        }
        return res;
    }
};
```



### 387. First Unique Character in a String

https://leetcode.com/problems/first-unique-character-in-a-string/description/

给定一个字符串, 查找第一个在字符串中没有重复的字符, 并返回它的索引; 如果不存在就返回 -1. 比如:

**Examples:**

```bash
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
```

**Note:** You may assume the string contain only lowercase letters.



思路: 由于可以认为字符串中只含有小写字母, 那么可以使用大小为 `vector<int>(26, 0)` 的数组保存字符的索引(如果不是小写字母, 那么就使用 `vector<int>(256, 0)`). 为什么保存索引能成功呢? 因为索引都是正数, 如果遇到重复的字符, 我就把索引设置为负数, 那么之后只要遍历一遍数组, 专门处理值大于 0 的值, 就可以找到最小的索引. 这里需要注意的是索引 0, 如果数组初始化为 -1, 可以避免这个尴尬. 当然也可以初始化为 0.

```cpp
// 这是我第二次提交的代码
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty())
            return -1;

        vector<int> records(26, 0);

        for (int i = 0; i < s.size(); ++i) {
            int index = s[i] - 'a';
            if (records[index] == 0)
                records[index] = i + 1; // 保存索引+1, 以免和 0 误会
            else if (records[index] > 0)
                records[index] = -1; // 如果有重复, 就设置为 -1.
        }
        int first = INT32_MAX;
        for (const auto &index : records) {
            if (index > 0)
                first = min(first, index);
        }

        if (first == INT32_MAX)
            return -1;
        return first - 1; // 最后要减 1
    }
};


// 下面是我第一次提交的代码, 比上面竟然还快...
// 但我觉得有个地方有问题, 注释中给出
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty())
            return -1;

        vector<int> records(26, -1);

        for (int i = 0; i < s.size(); ++i) {
            int index = s[i] - 'a';
            if (records[index] == -1)
                records[index] = i; // 保存索引
            else if (records[index] >= 0)
              	// 这里不断的减小可能会出问题, 如果 s.size() 太大的话.
                records[index] -= s.size();
        }
        int first = INT32_MAX;
        for (const auto &index : records) {
            if (index >= 0)
                first = min(first, index);
        }

        if (first == INT32_MAX)
            return -1;
        return first;
    }
};

// 看 leetcode 上有更简洁的做法
// 只要查找第一个出现次数为 1 的元素的索引即可.
class Solution {
public:
    int firstUniqChar(string s) {
        int ascii[256] = {0};
        
        for (char c : s) ascii[c - '0']++;
        for (int i = 0; i < s.size(); i++) {
            if (ascii[s[i] - '0'] == 1) return i;
        }
        
        return -1;
    }
};
```



### 561. *Array Partition I

https://leetcode.com/problems/array-partition-i/description/

给定 2n 个整数, 现在要将它们分成 n 个数对 (a1, b1), (a2, b2), ..., (an, bn), 使得 min(ai, bi) 的和 (`i = 1 ... n`) 尽可能大. 比如:

**Example 1:**

```bash
Input: [1,4,3,2]

Output: 4
Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
```

**Note:**

1. **n** is a positive integer, which is in the range of [1, 10000].
2. All the integers in the array will be in the range of [-10000, 10000].

思路: 这道题的关键是要观察到这样一个现象: 较大的数要聚在一起, 那么 min(ai, bi) 才会比较大. 比如上面的例子中, 如果 4 和 1 组成数对, 那么 min(1, 4) 就是 1, 相比 min(3, 4) 就小了. 因此, 思路就是将这个数组排序, 然后将 `0 ~ 2n - 1` 索引中偶数位置的元素相加即可.

```cpp
class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        if (nums.empty() || nums.size() % 2 == 1)
            throw invalid_argument("nums' size must be even");

        std::sort(nums.begin(), nums.end());
        int sum = 0;
        for (int i = 0; i < nums.size(); i += 2)
            sum += nums[i];
        return sum;
    }
};
```

leetcode 上有对这一思路的证明: [Java Solution, Sorting. And rough proof of algorithm.](https://leetcode.com/problems/array-partition-i/discuss/102170/Java-Solution-Sorting.-And-rough-proof-of-algorithm.)



### 566. *Reshape the Matrix

https://leetcode.com/problems/reshape-the-matrix/description/

类似于 matlab 中的 reshape 函数, 将一个矩阵给 reshape. 如果无法 reshape, 就返回原矩阵. 两个矩阵以行来遍历的话相同.



思路: 对于元素个数为 `rows * cols` 的矩阵, 在 `[0 ~ rows * cols - 1]` 范围内的元素 k, 对应于矩阵中的位置为 `(k/cols, k%cols)`, 知道这一点后, 解法很简单. 另外, 发现使用两个循环还更快.

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        int rows = nums.size(), cols = nums[0].size();
        if ((rows * cols) != (r * c) || r <= 0 || c <= 0)
            return nums;

        vector<vector<int>> res(r, vector<int>(c));
        for (int k = 0; k < rows * cols; ++k) {
            res[k/c][k%c] = nums[k/cols][k%cols];
        }
        return res;
    }
};
```

下面是使用两个循环的:

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        int row = nums.size();
        int column = nums[0].size();
        if(row * column != r * c) return nums;
        
        vector<vector<int>> ans(r, vector<int>(c));
        
        for(int i = 0; i < r; i++)
            for(int j = 0; j < c; j++)
                ans[i][j] = nums[(i * c + j) / column][(i * c + j) % column];
        return ans;
    }
};
```



### 448. *Find All Numbers Disappeared in an Array

https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/

感觉这道题像智力题. 这是一道很好的题目; 非常巧妙.

Given an array of integers where 1 ≤ a[i] ≤ *n* (*n* = size of array), some elements appear twice and others appear once.

Find all the elements of [1, *n*] inclusive that do not appear in this array.

Could you do it without extra space and in O(*n*) runtime? You may assume the returned list does not count as extra space.

**Example:**

```bash
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
```



leetcode 上的解答:

[Java accepted simple solution](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution)

The basic idea is that we iterate through the input array and mark elements as negative using `nums[nums[i] -1] = -nums[nums[i]-1]`. In this way all the numbers that we have seen will be marked as negative. In the second iteration, if a value is not marked as negative, it implies we have never seen that index before, so just add it to the return list.

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> ret = new ArrayList<Integer>();
        
        for(int i = 0; i < nums.length; i++) {
            int val = Math.abs(nums[i]) - 1;
            if(nums[val] > 0) {
                nums[val] = -nums[val];
            }
        }
        
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] > 0) {
                ret.add(i+1);
            }
        }
        return ret;
    }
```

最为关键的是下面的解释:

大致意思可以理解为, 对于 nums 中的每个元素, 将 nums[i] - 1 对应的那个元素设置为负值, 表示那个元素已经被访问过, 之后判断 nums 中哪些值为正的, 如果为正, 说明对应的索引 i + 1 不存在在 nums 中.

https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution/97460

A more detailed explanation for those who might still be confused:

This solution is using the relation between array index ([0, n-1]) and the given value range [1,n].

Each time when a new value X is read, it changes the corresponding Xth number (value at index X-1) into negative, indicating value X is read for the first time.
For example. using the given test case [4,3,2,7,8,2,3,1], when it comes to i = 2 in the first loop, this solution marks the 2nd number (index = 1), indicating we’ve found number 2 for the first time.

When we encounter a redundant number Y, because we’ve marked the Yth position (index Y -1) when we saw Y for the first time, the if clause won’t let us flip it again. This leaves the already marked Yth number (number at index Y-1) negative.
For example, in the given test case, when i = 5, val = |2| - 1 = 1, nums[1] = -3 < 0. No flip operation is needed because we’ve found value 2 before.

Looping through the 1st loop takes O(n) time, flipping signs won’t take extra space.

The second loop checks the signs of the values at indices. If the sign at index P is negative, it means value P + 1 is in the array. e.g. nums[0] = -4, so value 0+1 = 1 is in the array. If the value at index Q is positive, then value Q + 1 is not in the array. e.g. nums[4] = 8 > 0, value 4 + 1 = 5, we add 5 into the ret list.



### 724. *Find Pivot Index

https://leetcode.com/problems/find-pivot-index/description/

给定一个整型数组, 返回这个数组的 pivot 索引 i, 使得它左边的所有数 nums[0,...., i - 1] 与右边所有数 nums[i + 1,..., n - 1] 的和相等. 如果没有这样的索引, 返回 -1. 比如:

**Example 1:**

```bash
Input: 
nums = [1, 7, 3, 6, 5, 6]
Output: 3
Explanation: 
The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.
Also, 3 is the first index where this occurs.
```

**Example 2:**

```bash
Input: 
nums = [1, 2, 3]
Output: -1
Explanation: 
There is no index that satisfies the conditions in the problem statement.
```

**Note:**

The length of `nums` will be in the range `[0, 10000]`.

Each element `nums[i]` will be an integer in the range `[-1000, 1000]`.

思路: 好吧, 这道题我做错了多遍...这里直接给出 leetcode 的解答. 首先求出整个数组的和 sum, 然后依次遍历每一个索引 i, 判断左边的和 leftsum 是否等于 `sum - nums[i] - leftsum` (即右边的和, 注意不包括 nums[i]), 如果不相等, 那么 leftsum += nums[i].

https://leetcode.com/problems/find-pivot-index/solution/

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = 0, leftsum = 0;
        for (auto &d : nums) sum += d;

        for (int i = 0; i < nums.size(); ++i) {
            if (leftsum == sum - nums[i] - leftsum)
                return i;
            else
                leftsum += nums[i];
        }
        return -1;
    }
};
```





### 118. *Pascal's Triangle

https://leetcode.com/problems/pascals-triangle/description/

杨辉三角形.

Given *numRows*, generate the first *numRows* of Pascal's triangle.

For example, given *numRows* = 5,
Return

```bash
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

思路: 仔细观察, 末尾的 1 就是上一行的最后一位加上 0, 所以要判断是否为最后一位.

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        if (numRows <= 0)
            return vector<vector<int>>{};

        vector<int> prev{1};
        vector<vector<int>> res{prev};

        for (int i = 1; i < numRows; ++i) {
            vector<int> path(i + 1, 0);
            path[0] = 1;
            for (int j = 0; j < prev.size(); ++j) {
                if (j + 1 == prev.size())
                    path[j + 1] = prev[j] + 0;
                else
                    path[j + 1] = prev[j] + prev[j + 1];
            }
            res.push_back(path);
            prev = path;
        }
        return res;
    }
};
```

经下面 119. Pascal's Triangle II 这道题的启发, 我们可以从后向前计算, 代码看起来会更简洁:

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        if (numRows <= 0)
            return vector<vector<int>>{};

        vector<int> prev{1};
        vector<vector<int>> res{prev};

        for (int i = 1; i < numRows; ++i) {
            vector<int> path(i + 1, 0);
            path[0] = 1;
            path[i] = 1;
            for (int j = i - 1; j > 0; --j)
                path[j] = prev[j] + prev[j - 1];
            res.push_back(path);
            prev = path;
        }

        return res;
    }
};
```



### 119. *Pascal's Triangle II

https://leetcode.com/problems/pascals-triangle-ii/description/

```bash
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

给定index k, 返回杨辉三角形中的第 k 行. 比如给定 k = 3, 返回 `[1, 3, 3, 1]`.



思路: 这道题如果从前往后计算就特别麻烦, 我等下会给出这个思路的方法. 在 leetcode 上看到如下的解法, 从后向前计算, 非常简洁:

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> result(rowIndex+1, 0);
        result[0] = 1;
        for(int i = 1; i <= rowIndex; i++) {
            for(int j = i; j >= 1; j--) {
                result[j] = result[j] + result[j-1];
            }
        }
        return result;
    }
};
```

下面是我的解法: 不过多解释, 调试了半天...

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        if (rowIndex < 0)
            return vector<int>{};

        vector<int> res(rowIndex + 1, 0);
        res[0] = 1;

        int prev = res[0], now = 0;;
        for (int i = 1; i <= rowIndex; ++i) {
            for (int j = 1; j < i + 1; ++j) {
                now = res[j];
                res[j] += prev;
                prev = now;
            }
            prev = res[0];
        }
        res.erase(res.begin() + rowIndex + 1, res.end());
        return res;
    }
};
```



### 485. *Max Consecutive Ones

https://leetcode.com/problems/max-consecutive-ones/description/

给定一个只包含 0-1 的数组, 找出 1 的连续个数最多是多少?

```bash
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
```

**Note:**

- The input array will only contain `0` and `1`.
- The length of input array is a positive integer and will not exceed 10,000



思路: 解法一: 使用 [i, j] 来标识只包含 1 的连续子数组的范围. 如果当前访问的元素(其中 `j + 1` 表示当前访问的元素)是 1, 那么 `j++`, 否则, `i = ++j + 1`;

```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int i = 0, j = -1;
        int res = 0;
        while (i < nums.size()) {
            if (nums[j + 1] == 1)
                j ++;
            else {
                res = max(res, j - i + 1);
                i = ++j + 1;
            }
        }
        return res;
    }
};
```



