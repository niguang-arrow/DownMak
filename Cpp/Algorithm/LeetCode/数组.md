# Array

## 数组

### 287. **Find the Duplicate Number

表面上这道题标定的是 medium, 实际上要想出来太难... 

先给出关于这道题比较清晰的参考:

[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/solution/) leetcode 的官方解答

[leetcode笔记：Find the Duplicate Number](https://blog.csdn.net/liyuefeilong/article/details/50719741)

[Find the Duplicate Number 找到重复数字](https://segmentfault.com/a/1190000003817671)

[Find the Duplicate Number](http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/) 牛人博客, LeetCode 有六百多题的解答.

题目的大意是，给定一个包含`n + 1`个整数的数组，其中每一个整数的大小均在`[1, n]`之间，证明其中至少有一个重复元素存在。同时假设数组中只有一个数字出现重复，找出这个重复的数字。

注意事项：

- 不可以修改数组（假设数组是只读的）
- 只能使用常数空间
- 运行时间复杂度应该小于`O(n^2)`
- 数组中只存在一个重复数，但是该数可能重复多次



思路: 首先, 使用鸽笼(抽屉)原理可以证明, 这 n + 1 个数字中必然有重复数字. 可以将 n + 1 个位置想象成 n + 1 双袜子, 1 ~ n 这 n 个数相当于抽屉, 要让 n + 1 双袜子放到 n 个抽屉中, 必然有一个抽屉要放置两双袜子, 翻译过来就是数组中至少有两个位置要取相同的数.

```bash
解决本题需要的主要技巧就是要注意到：由于数组的n + 1个元素范围从1到n，我们可以将数组考虑成一个从集合{1, 2, ..., n}到其本身(即集合本身)的函数f。这个函数的定义为f(i) = A[i]。基于这个设定，重复元素对应于一对下标 i != j 满足 f(i) = f(j)。我们的任务就变成了寻找一对(i, j)。一旦我们找到这个值对，只需通过f(i) = A[i] 即可获得重复元素。这变成了计算机科学界一个广为人知的“环检测”问题。

由于数组元素范围1到n，不存在值为 0 的元素, 因此环的形状必然是 P 型的:
                x_0 -> x_1 -> ... x_k -> x_{k+1} ... -> x_{k+j}
                                    ^                       |
                                    |                       |
                                    +-----------------------+
由Robert Floyd提出的一个著名算法，给定一个ρ型序列，在线性时间，只使用常数空间寻找环的起点。这个算法经常被称为“龟兔”算法.                                    
```

当我看完 [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/) 的解法后(这道检测链表中环的问题的解答可以参考 Gitbooks : [Linked List Cycle](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/)), 再来解决这道题就轻松很多.

为了用检测链表环的思路来解决这道题, 我们可以发现, 比如对于序列 `{3, 1, 2, 3, 4}`, 可以得到如下链表:

```bash
0  ->  3  -> 
	   |___|	   
```

也就是说, 存在 `(i, j)` 为 `(0, 3)`, 使得 `f[0] == f[3] == 3`. 所以环是索引 3, 而值是 `f[3] = 3`. (举出这个例子是想说明, 当存在环时, 后面的 2, 4 之类的值也许不会访问到).

那检测链表中的环, 思路是设置快慢指针 (fast 与 slow), fast 每次移动两步, 而 slow 每次移动一步, 当 fast 和 slow 重合时(除了起始的时候), 说明链表中存在环, 而要找到环的位置, 详情见:

Gitbooks : [Linked List Cycle](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/) 摘录下来:

譬如下面这个，环的起点就是n2。

```bash
        n6-----------n5
        |            |
  n1--- n2---n3--- n4|
```

我们仍然可以使用两个指针fast和slow，fast走两步，slow走一步，判断是否有环，当有环重合之后，譬如上面在n5重合了，那么如何得到n2呢？

首先我们知道，fast每次比slow多走一步，所以重合的时候，fast移动的距离是slot的两倍，我们假设n1到n2距离为a，n2到n5距离为b，n5到n2距离为c，fast走动距离为`a + b + c + b`，而slow为`a + b`，有方程`a + b + c + b = 2 x (a + b)`，可以知道`a = c`，所以我们只需要在重合之后，一个指针从n1，而另一个指针从n5，都每次走一步，那么就可以在n2重合了。

综上, 代码为: 注意初始的情况

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
      	// 初始的时候, slow 和 fast 都应该是 nums[0] 的, 但由于这里使用的是 
      	// while 循环而不是 do...while, 所以 slow 和 fast 写成了下面的形式,
      	// do...while 的写法参见 leetcode 的官方解答.
      	// 下面先将 fast 移动两格, 而 slow 只移动一格
        int slow = nums[nums[0]], fast = nums[nums[nums[0]]];
        while (fast != slow) {
            fast = nums[nums[fast]];
            slow = nums[slow];
        }
		
      	// 当 fast 和 slow 相遇后, 要开始查找环的入口. 参见上面思路中 n1, n2, 的
      	// 图示, 这里将 fast 指向 n1, 而 slow 目前指向的是 n5, 然后每次让它们移动
      	// 一格, 最终相遇在 n2.
        fast = nums[0];
        while (fast != slow) {
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
};
```



### 142. **Linked List Cycle II

https://leetcode.com/problems/linked-list-cycle-ii/description/

在链表中找环并返回环的节点. 这道题是链表的题, 但由于和上一道 287 Find the Duplicate Number 联系紧密, 所以放在这里.

解析的话就看  [Linked List Cycle](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/) 写得很精彩易懂. (另外看完 287 后, 其实我们知道, 使用龟兔算法来解决此类问题, 要注意这个环是 P 型的)

+ 双指针方法

```bash
链表问题中的一个重要的方法叫双指针法。定义两个指针，一个叫慢指针，另一个叫快指针。通常慢指针每次向前移动一个节点，而快指针每次向前移动若干个节点。这个方法通常用于寻找链表中特定的位置。比如找到链表的中点，可以让快指针每次移动两个节点。这样当快指针到达链表末尾时，慢指针刚好在链表中间的位置。
```

假设环的起点就是n2。

```bash
        n6-----------n5
        |            |
  n1--- n2---n3--- n4|
```

我们仍然可以使用两个指针fast和slow，fast走两步，slow走一步，判断是否有环，当有环重合之后，譬如上面在n5重合了，那么如何得到n2呢？

首先我们知道，fast每次比slow多走一步，所以重合的时候，fast移动的距离是slot的两倍，我们假设n1到n2距离为a，n2到n5距离为b，n5到n2距离为c，fast走动距离为`a + b + c + b`，而slow为`a + b`，有方程`a + b + c + b = 2 x (a + b)`，可以知道`a = c`，所以我们只需要在重合之后，一个指针从n1，而另一个指针从n5，都每次走一步，那么就可以在n2重合了。

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head || !head->next)
            return nullptr;

        ListNode *fast = head;
        ListNode *slow = head;

        // 首先判断是否存在环
        while (fast->next && fast->next->next) {
            fast = fast->next->next;
            slow = slow->next;
            // 如果存在环, 那么开始找环
            if (fast == slow) {
                fast = head;
                while (fast != slow) {
                    fast = fast->next;
                    slow = slow->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
};
```



### 448. *Find All Numbers Disappeared in an Array

https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/

感觉这道题像智力题. 这是一道很好的题目; 非常巧妙.

Given an array of integers where 1 ≤ a[i] ≤ *n* (*n* = size of array), some elements appear twice and others appear once.

Find all the elements of [1, *n*] inclusive that do not appear in this array.

Could you do it without extra space and in O(*n*) runtime? You may assume the returned list does not count as extra space.

**Example:**

```bash
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
```



思路: **看到类似这种数组中的元素的值限定在 1 ~ N 之间的, 可能就可以考虑使用将元素值作为索引的方法...** 由于每个元素值的大小都是 `1 <= a[i] <= N`, 那么访问 `a[a[i] - 1]` 是没有问题的. 考虑上面这个数组:

```bash
# 假设数组的索引从 1 开始
index : 1   2   3   4   5   6   7   8
value : 4   3   2   7   8   2   3   1
```

现在从索引 1 开始, 如果依次将 `a[abs(a[i])]` 的值改为负数, 但如果 `a[abs(a[i])]` 已经是负数了, 那么就不用修改了.

```bash
# 假设数组的索引从 1 开始
index :  1    2    3     4   5   6     7    8
value : -4   -3   -2    -7   8   2    -3   -1
```

可以看到只有 `{5, 6}` 处的元素依然是正数, 那么消失的数字就是 `{5, 6}`. 由于下面的代码中索引从 0 开始, 所以最后要加 1.

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for (auto &d : nums)
            if (nums[abs(d) - 1] > 0)
                nums[abs(d) - 1] = -nums[abs(d) - 1];
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i)
            if (nums[i] > 0)
                res.push_back(i + 1);
        return res;
    }
};
```



leetcode 上的解答:

[Java accepted simple solution](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution)

The basic idea is that we iterate through the input array and mark elements as negative using `nums[nums[i] -1] = -nums[nums[i]-1]`. In this way all the numbers that we have seen will be marked as negative. In the second iteration, if a value is not marked as negative, it implies we have never seen that index before, so just add it to the return list.

```java
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> ret = new ArrayList<Integer>();
        
        for(int i = 0; i < nums.length; i++) {
            int val = Math.abs(nums[i]) - 1;
            if(nums[val] > 0) {
                nums[val] = -nums[val];
            }
        }
        
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] > 0) {
                ret.add(i+1);
            }
        }
        return ret;
    }
```

最为关键的是下面的解释:

大致意思可以理解为, 对于 nums 中的每个元素, 将 nums[i] - 1 对应的那个元素设置为负值, 表示那个元素已经被访问过, 之后判断 nums 中哪些值为正的, 如果为正, 说明对应的索引 i + 1 不存在在 nums 中.

https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution/97460

A more detailed explanation for those who might still be confused:

This solution is using the relation between array index ([0, n-1]) and the given value range [1,n].

Each time when a new value X is read, it changes the corresponding Xth number (value at index X-1) into negative, indicating value X is read for the first time.
For example. using the given test case [4,3,2,7,8,2,3,1], when it comes to i = 2 in the first loop, this solution marks the 2nd number (index = 1), indicating we’ve found number 2 for the first time.

When we encounter a redundant number Y, because we’ve marked the Yth position (index Y -1) when we saw Y for the first time, the if clause won’t let us flip it again. This leaves the already marked Yth number (number at index Y-1) negative.
For example, in the given test case, when i = 5, val = |2| - 1 = 1, nums[1] = -3 < 0. No flip operation is needed because we’ve found value 2 before.

Looping through the 1st loop takes O(n) time, flipping signs won’t take extra space.

The second loop checks the signs of the values at indices. If the sign at index P is negative, it means value P + 1 is in the array. e.g. nums[0] = -4, so value 0+1 = 1 is in the array. If the value at index Q is positive, then value Q + 1 is not in the array. e.g. nums[4] = 8 > 0, value 4 + 1 = 5, we add 5 into the ret list.



### 442. **Find All Duplicates in an Array

https://leetcode.com/problems/find-all-duplicates-in-an-array/description/

找出数组中所有的重复数字. 这道题可以认为承接上题 448. Find All Numbers Disappeared in an Array.

Given an array of integers, 1 ≤ a[i] ≤ *n* (*n* = size of array), some elements appear **twice** and others appear **once**.

Find all the elements that appear **twice** in this array.

Could you do it without extra space and in O(*n*) runtime?

**Example:**

```bash
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
```



思路: 参考 448. Find All Numbers Disappeared in an Array 这道题的笔记, 注意到数组中的元素的范围在 1 ~ N, 所以, 可以考虑使用将 `nums[nums[i] - 1]` 的值设置为负数的做法. 

考虑上面这个数组:

```bash
# 假设数组的索引从 1 开始
index : 1   2   3   4   5   6   7   8
value : 4   3   2   7   8   2   3   1
```

现在从索引 1 开始, 如果依次将 `a[abs(a[i])]` 的值改为负数, 但如果 `a[abs(a[i])]` 已经是负数了, 那么就不用修改了. 当 index = 6 时, 问题就出现了, 下图用 `|6|` 标注出来了.

```bash
# 假设数组的索引从 1 开始
index :  1    2    3     4   5  |6|    7    8
value :  4   -3   -2    -7   8   2     3   -1
```

因为此时 `nums[nums[6]]` 即 `nums[2]` 已经是负数了, 另外可以观察到如果 index 进行到 7 的时候, `nums[nums[7]]` 即 `nums[3]` 的值也是负数, 而 2, 3 就是我们要找的重复数字, 我们便意识到, 如果当 `nums[abs(nums[i])]` 已经是负数了, 我们就需要把 `abs(nums[i])` 给记录下来, 因为它就是重复数字.

```cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[abs(nums[i]) - 1] > 0) 
                // 不要使用乘法, 直接写成负数的形式提高性能.
                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1];
            else
                res.push_back(abs(nums[i]));
        }
        return res;
    }
};
```



### 283. *Move Zeros

https://leetcode.com/problems/move-zeroes/

(刚刚发现 283, 27, 26, 80 这四题其实是同一类型的题, 都是将元素从数组中删除)

将数组中的 0 都挪到数组的尾部, 并且保持原来非零元素在数组中的顺序.

思路是: 要引入一个索引 k 来使得 `nums[0....k]` 范围内的元素原数组中大于零的值, `nums[k+1...n-1]` 范围内的值等于零. 对于当前访问的元素 `nums[i]` 来说, 如果它等于零, 我们只要访问下一个元素即可. 而当 `nums[i]` 不等于 0 时, 只要和 `nums[k + 1]` 交换即可.(我明白了, 到这里可以得到这样的结论, 比如我明确了 `nums[0...k]` 的意义, 那么后面的操作就是很正常了)

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if (nums.empty())
            return;

        // arr[0...k] 保存所有非零元素
      	// 初始为 -1 说明 arr[0, k] 中无元素. 如果初始化为 0, 
      	// 那么下面使用 nums[k++]
        int k = -1; 
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != 0) {
                if (i != (k + 1))
                    swap(nums[i], nums[++k]);
                else
                    ++k;
            }
        }
    }
};
```



### 27. *Remove Element

https://leetcode.com/problems/remove-element/description/

将数组中等于 val 的所有元素给删除(移到数组末尾), 并返回其他非 val 元素的长度.

思路: 其实这道题就是 283. move zeros 的变形, 只不过前面是将 0 移到末尾, 这里是将 val 移到末尾.

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if (nums.empty())
            return nums.size();

        // arr[0...k] 保存不等于 val 的元素
        int k = -1;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != val) {
                if (i != (k + 1))
                    swap(nums[i], nums[++k]);
                else
                    ++k;
            }
        }
        return k + 1;
    }
};
```



### 26. *Remove Duplicates from Sorted Array

https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/

将排序数组中的重复数字给去除, 并返回新数组的长度. 注意只能原地修改数组, 使用 O(1) 的额外空间.

思路: 其实和 283. Move Zeros 的思路一致, 要使用两个下标, 一个下标 i 用于遍历数组, 另一个下标 k 用于记录不重复数组的范围, 比如下面的代码中, 我令 `arr[0....k]` 范围内的元素是不重复的. 这样的话, 访问到当前元素 `arr[i]` 时, 就得和 `arr[k]` 进行比较, 如果等于 `arr[k]` 的话, 说明是重复的, 因此只需遍历下一个元素; 而如果当前元素与 `arr[k]` 不相等, 那么就使 `arr[k+1] = arr[i]`, 并且 k 要移动到下一位.

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
            if (nums.empty())
                return 0;

            int k = 0;
            // nums[0, k] 范围内的数应是没有重复的
            for (int i = 1; i < nums.size(); ++i) {
                if (nums[i] != nums[k]) {
                  	// 有的答案没有下面这个 if else 条件判断, 直接使用
                  	// nums[++k] = nums[i]; 我是说, 如果当前访问的元素
                  	// 就是 arr[k] 的下一位, 并且和 arr[k] 不相等, 那么
                  	// 直接将 k 移向下一位即可.
                    if (i != (k + 1))
                        nums[++k] = nums[i];
                    else
                        ++k;
                }
            }
      		// nums.resize(k + 1) 实际上不需要
            nums.resize(k + 1);
            return k + 1;
    }
};
```

### 80. **Remove Duplicates from Sorted Array II

https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/

承接上面的 26 题, 但是这次允许数组中重复数字最多出现两次. 比如 `nums = {1, 1, 1, 2, 2, 3}` 时, 结果为 5, `{1, 1, 2, 2, 3}`. 首

首先思路是, 当访问 `nums[i]` 时, 它要和 `nums[k - 1]` 进行比较, 其中 `nums[0....k]` 保存着满足条件的元素. 这样的话, 代码能允许重复数字最多出现两次.

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
            if (nums.size() <= 2)
                return nums.size();

            int k = 1;
            for (int i = 2; i < nums.size(); ++i) {
                if (nums[i] != nums[k - 1]) {
                    nums[++k] = nums[i];
                }
            }
            return k + 1;

    }
};
```

### 33. Search in Rotated Sorted Array

https://leetcode.com/problems/search-in-rotated-sorted-array/description/

将一个排序数组进行旋转, 然后在其中搜索某个数. 比如 `[0, 1, 2, 3, 4, 5]` 旋转后为 `[3, 4, 5, 0, 1, 2]`, 然后在旋转后的数组中搜索.

思路: 使用二分查找, 关键在于边界的确定. (参考了 leetcode-cpp.pdf 上 2.1.3 的解答)

要分情况讨论, 当访问 nums[mid] 时, 考虑两种情况, nums[mid] 是大于或等于 nums[left] 呢, 还是小于 nums[left]. 在这两种情况下, 又要考虑 target 和 nums[mid] 以及 nums[left] 的关系.

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if (nums.empty())
            return -1;

        int l = 0, r = nums.size() - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] >= nums[l]) { // 说明 nums[l...mid] 是排序好的
                if (target >= nums[l] && target < nums[mid])
                    r = mid - 1;
                else
                    l = mid + 1;
            }
            else {// 说明 nums[mid...r] 是排序好的
                if (target < nums[l] && target > nums[mid])
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return -1;
    }
};
```



### 81. Search in Rotated Sorted Array II

https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/

在上一题的基础上, 如果排序数组中有重复元素会怎样? 比如数组 `{1, 2, 2, 2, 2, 3, 4}` 旋转之后成了

`{2, 2, 3, 4, 1, 2, 2}`. 

思路: 出现重复元素的话, 那么在 33. Search in Rotated Sorted Array 中使用的 `nums[mid] >= nums[l]` 就不能判定 `nums[l....mid]` 为递增序列了. 这个时候可以将其拆分为两个条件:

- 如果 nums[mid] > nums[l], 那么 nums[l....mid] 一定是递增的;
- 如果 nums[mid] == nums[l], 无法确认状况, 那么就令 `l++`, 往下看一步即可.

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        if (nums.empty())
            return false;

        int l = 0, r = nums.size() - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target)
                return true;
            if (nums[mid] > nums[l]) {
                if (target >= nums[l] && target < nums[mid])
                    r = mid - 1;
                else
                    l = mid + 1;
            }
            else if (nums[mid] == nums[l]) {
                l ++;
            }
            else {
                if (target < nums[l] && target > nums[mid])
                    l = mid + 1;
                else
                    r = mid - 1;
            }
        }
        return false;
    }
};
```

可是我没想到下面的解法还更快... 来自 leetcode

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] == target) return true;
        }
        return false;
    }
};
```





### 75. **Sort Colors

https://leetcode.com/problems/sort-colors/description/

将只 0, 1, 2 三个元素的长度为 n 的数组排序.

思路: 一方面可以使用计数排序, 使用一个大小为 3 的数组来统计每个元素的个数; 另一方面使用三路快排的思路.

首先, 使用计数排序:

```cpp
class Solution {
public:
    // 使用计数排序
    void sortColors(vector<int>& nums) {
        if (nums.empty())
            return;

        int count[3] = {0};
        for (const auto &d : nums)
            count[d]++;

        int index = 0;
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < count[i]; j++) {
                nums[index++] = i;
            }
        }
    }
};
```

下面是使用三路快排的思路:

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        if (nums.empty())
            return;
        
        // nums[0... lt] 保存 0
        // nums[lt+1....i] 保存 1
        // nums[gt....n-1] 保存 2
        int lt = -1, gt = nums.size();
        int i = 0;
        while (i < gt) {
            if (nums[i] == 1)
                ++i;
            else if (nums[i] == 0)
                swap(nums[i++], nums[++lt]);
            else
                swap(nums[i], nums[--gt]);
        }
    }
};
```



### 1. Two Sum

https://leetcode.com/problems/two-sum/description/

给定一个整数序列, 要求返回两个索引, 它们对应的两个值的和等于 target. (此题的测试可以假设肯定是有一个解的, 另外, 不能将同一个值使用两次, 比如数组中有一个数字 4, target 为 8, 不能说 4 + 4 = 8). 比如 `[2, 7, 11, 15]`, target 为 9, 那么返回 `[0, 1]`.

思路: 等下会做另一道类似的题, 但是是在有序数组中查找两个数, 使得它们的和与 target 相等. 但这道题的不同之处在于, 它的数组是无序的, 而排序太浪费时间, 如果要在遍历过程中实现目的, 那么需要快速查找的方法, 这个时候只好考虑使用空间来换取时间, 因此引入哈希表来对元素进行查找, 时间复杂度为 O(1), 空间复杂度为 O(n), 保存元素本身以及它对应的索引. 当访问元素 `nums[i]` 时, 在哈希表中查找 `nums[target - nums[i]]` 是否存在, 如果存在, 那么就保存索引; 否则将 `nums[i]` 以及索引 i 加入到哈希表中.(代码中的 `swap(i, j)` 是为了是返回结果中的索引的顺序是从小到大的.)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        if (nums.size() < 2)
            throw invalid_argument("nums' size invalid");

        unordered_map<int, int> hash_map;
        for (int i = 0; i < nums.size(); ++i) {
            auto iter = hash_map.find(target - nums[i]);
            if (iter != hash_map.end()) {
                int j = iter->second;
                if (i > j)
                    std::swap(i, j);
                int res[2] = {i, j};
                return vector<int>(res, res+2);
            }
            else
                hash_map.insert(std::make_pair(nums[i], i));
        }
    }
};
```



### 167. *Two Sum II - Input array is sorted

https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/

与上一题不同的地方是, 数组是排序的, 因此可以使用对撞指针. 要找到两个数等于 target, 由于数组是排序的, 那么这两个数必然是一左一右, 那么可以使用两个指针, 从数组的起始和尾部开始搜索, 如果 `nums[i] + nums[j]` 刚好等于 target, 那么, 直接返回. 如果和的结果小于 target, 那么说明 `nums[i]` 小了, 要增大, 应该 `++i`; 如果结果大于 target, 说明 `nums[j]` 大了, 应该 `--j`.

另外, 注意一点: **题目中要求是返回的索引从 1 开始, 因此, i 和 j 要加 1.**

由于代码 while 外面没有 return, 编译器会给出警告, 可以使用 `return {}` 解决.

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        if (numbers.size() < 2)
            throw invalid_argument("numbers' size invalid");

        int i = 0, j = numbers.size() - 1;
        // 由于结果返回两个, 所以i和j肯定不相等
        while (i < j) {
            if (numbers[i] + numbers[j] == target) {
                int res[2] = {i+1, j+1};
                return vector<int>(res, res + 2);
            }
            else if (numbers[i] + numbers[j] < target)
                ++i;
            else
                --j;
        }
    }
};
```



### 15. 3Sum

https://leetcode.com/problems/3sum/description/

给定含 n 个整数的数组 S, 找出是否存在 3 个整数使得 a + b + c = 0. 把所有不重复的三元组给找出来. 比如:

```bash
For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```



思路: 首先给数组排序, 然后遍历整个数组(直到 `nums.size() - 2` 的位置), 每一次访问的 `nums[i]` 可以作为三元组的首位元素, 这样可以保证所有的三元组不重复(当然其实还有另外的约束, 下面谈到), 然后针对 `nums[i + 1, .... n - 1]` 范围内的元素, 进行 2sum 操作, 即使用对撞指针. 但还需要考虑的两点是, `nums[i+1, .... n-1]` 中可能有多个 pair 满足 2sum, 另外也会有大量的重复元素, 因此在进行 2sum 的时候, 要使用 while 循环将这些相同的元素给略过. 

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.size() < 3)
            return {};

        vector<vector<int>> res;
        std::sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; ++i) {
          	// 当 i == 0 时, 进行判断; 当 i > 0 时, 需要判断 nums[i]
          	// 是否和前一个元素相等, 如果相等, 就不需要考虑了.
            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {
                int lo = i + 1, hi = nums.size() - 1, target = 0 - nums[i];
                while (lo < hi) {
                    vector<int> path;
                  	// 注意, 当在 nums[i+1, .... n-1] 范围内找到了 target, 在考虑
                  	// 下一个 pair 之前, 还要使用两个 while 循环判断 nums[lo] 和 
                  	// nums[lo+1] 是否相等.
                    if (nums[lo] + nums[hi] == target) {
                        path.insert(path.end(), {nums[i], nums[lo], nums[hi]});
                        res.push_back(path);

                        while (lo < hi && nums[lo] == nums[lo + 1]) lo ++;
                        while (lo < hi && nums[hi] == nums[hi - 1]) hi --;
                        lo ++;
                        hi --;
                    }
                    else if (nums[lo] + nums[hi] < target)
                        lo ++;
                    else
                        hi --;
                }
            }
        }
        return res;
    }
};
```

针对 3元组的首个元素可能会重复的问题, 还有另外的写法:

[Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments](https://leetcode.com/problems/3sum/discuss/7402/Share-my-AC-C++-solution-around-50ms-O(N*N)-with-explanation-and-comments)

```cpp
vector<vector<int> > threeSum(vector<int> &num) {
    
    vector<vector<int> > res;

    std::sort(num.begin(), num.end());

    for (int i = 0; i < num.size(); i++) {
        
        int target = -num[i];
        int front = i + 1;
        int back = num.size() - 1;

        while (front < back) {

            int sum = num[front] + num[back];
            
            // Finding answer which start from number num[i]
            if (sum < target)
                front++;

            else if (sum > target)
                back--;

            else {
                vector<int> triplet(3, 0);
                triplet[0] = num[i];
                triplet[1] = num[front];
                triplet[2] = num[back];
                res.push_back(triplet);
                
                // Processing duplicates of Number 2
                // Rolling the front pointer to the next different number forwards
                while (front < back && num[front] == triplet[1]) front++;

                // Processing duplicates of Number 3
                // Rolling the back pointer to the next different number backwards
                while (front < back && num[back] == triplet[2]) rear--;
            }
            
        }
		// 在这里考虑三元组的首元素可能重复的问题.
        // Processing duplicates of Number 1
        while (i + 1 < num.size() && num[i + 1] == num[i]) 
            i++;

    }
    
    return res;
    
}
```



### 16. 3Sum Closet

https://leetcode.com/problems/3sum-closest/description/

给定一个整数数组 S, 在其中找到 3 个整数使得它们的和接近一个给定的 target. 返回这 3 个数的和. (可以假设所有的测试用例中只有一个解) 比如:

```bash
For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```



思路: 类似于 15. 3Sum. 为了得到最接近 target 的值, 要计算使 `std::abs(target - sum)` 最小的那个 sum. 为了得到这些 sum, 和 3Sum 一样, 首先对数组进行排序, 然后固定 nums[i], 再对后面的内容进行 2Sum.

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        if (nums.size() < 3)
            return accumulate(nums.begin(), nums.end(), 0);

        int res = nums[0] + nums[1] + nums[nums.size() - 1];
        std::sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; ++i) {
            int lo = i + 1, hi = nums.size() - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi] + nums[i];
                if (sum == target)
                    return sum;
                if (sum > target)
                    hi --;
                else {
                    lo ++;
                }
                if (std::abs(target - sum) < std::abs(target - res))
                    res = sum;
            }
        }
        return res;
    }
};
```

再看一个 leetcode 上解释非常详细的:

[A n^2 Solution, Can we do better ?](https://leetcode.com/problems/3sum-closest/discuss/7873/A-n2-Solution-Can-we-do-better)

```cpp
int threeSumClosest(vector<int> &num, int target) {        
    vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.
    int n = 0;
    int ans = 0;
    int sum;
    
    sort(v.begin(), v.end());
    
    // If less then 3 elements then return their sum
    while (v.size() <= 3) {
        return accumulate(v.begin(), v.end(), 0);
    }
    
    n = v.size();
    
    /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]
     *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. 
     * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that 
     * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.
     * if the sum of the triplet is greater then the target it implies
     * we need to reduce our sum, so we do K = K - 1, that is we reduce
     * our sum by taking a smaller number.
     * Simillarly if sum of the triplet is less then the target then we
     * increase out sum by taking a larger number, i.e. J = J + 1.
     */
    ans = v[0] + v[1] + v[2];
    for (int i = 0; i < n-2; i++) {
        int j = i + 1;
        int k = n - 1;
        while (j < k) {
            sum = v[i] + v[j] + v[k];
            if (abs(target - ans) > abs(target - sum)) {
                ans = sum;
                if (ans == target) return ans;
            }
            (sum > target) ? k-- : j++;
        }
    }
    return ans;
}
```



### 18. 4Sum

https://leetcode.com/problems/4sum/description/

给定一个整数数组和给定的 target, 是否存在 a, b, c, d 4个整数使得它们的和满足 a+b+c+d = target? 返回所有不重复的 (a, b, c, d) 四元组.

```bash
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```



思路: 首先固定 a, 然后再使用 3Sum 的方法求解.

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        if (nums.size() < 4)
            return {};

        std::sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> path;
        for (int i = 0; i < nums.size() - 3; ++i) {
          for (int j = i + 1; j < nums.size() - 2; ++j) {
            int lo = j + 1, hi = nums.size() - 1;
            while (lo < hi) {
              int sum = nums[i] + nums[j] + nums[lo] + nums[hi];
              if (sum == target) {
                path = {nums[i], nums[j], nums[lo], nums[hi]};
                res.push_back(path);
                while (lo < hi && nums[lo] == nums[lo + 1]) lo ++;
                while (lo < hi && nums[hi] == nums[hi - 1]) hi --;
                lo ++;
                hi --;
              }
              else if (sum < target)
                lo ++;
              else
                hi --;
            }
            while (j + 1 < nums.size() - 2 && nums[j + 1] == nums[j]) ++j;
          }
          while (i + 1 < nums.size() - 3 && nums[i + 1] == nums[i]) ++i;
        }
        return res;
    }
};
```

不知道为什么, 下面 leetcode 上的解答和我的逻辑类似, 但是运算速度比我的快:

[4Sum C++ solution with explanation and comparison with 3Sum problem. Easy to understand.](https://leetcode.com/problems/4sum/discuss/8714/4Sum-C++-solution-with-explanation-and-comparison-with-3Sum-problem.-Easy-to-understand.)

```cpp
class Solution {
public:
    vector<vector<int> > fourSum(vector<int> &num, int target) {
    
        vector<vector<int> > res;
    
        if (num.empty())
            return res;
    
        std::sort(num.begin(),num.end());
    
        for (int i = 0; i < num.size(); i++) {
        
            int target_3 = target - num[i];
        
            for (int j = i + 1; j < num.size(); j++) {
            
                int target_2 = target_3 - num[j];
            
                int front = j + 1;
                int back = num.size() - 1;
            
                while(front < back) {
                
                    int two_sum = num[front] + num[back];
                
                    if (two_sum < target_2) front++;
                
                    else if (two_sum > target_2) back--;
                
                    else {
                    
                        vector<int> quadruplet(4, 0);
                        quadruplet[0] = num[i];
                        quadruplet[1] = num[j];
                        quadruplet[2] = num[front];
                        quadruplet[3] = num[back];
                        res.push_back(quadruplet);
                    
                        // Processing the duplicates of number 3
                        while (front < back && num[front] == quadruplet[2]) ++front;
                    
                        // Processing the duplicates of number 4
                        while (front < back && num[back] == quadruplet[3]) --back;
                
                    }
                }
                
                // Processing the duplicates of number 2
                while(j + 1 < num.size() && num[j + 1] == num[j]) ++j;
            }
        
            // Processing the duplicates of number 1
            while (i + 1 < num.size() && num[i + 1] == num[i]) ++i;
        
        }
    
        return res;
    
    }
};
```

这道题在 leetcode-cpp.pdf 上还有两种使用 hash 表进行求解的方法, 展示如下, 但都不是很快.

这是使用 `unordered_map` 的:

```cpp
// LeetCode, 4Sum
// 用一个 hashmap 先缓存两个数的和
// 时间复杂度，平均 O(n^2)，最坏 O(n^4)，空间复杂度 O(n^2)
class Solution {
public:
   vector<vector<int> > fourSum(vector<int> &num, int target) {
       vector<vector<int>> result;
       if (num.size() < 4) return result;
       sort(num.begin(), num.end());
       unordered_map<int, vector<pair<int, int> > > cache;
       for (size_t a = 0; a < num.size(); ++a) {
           for (size_t b = a + 1; b < num.size(); ++b) {
               cache[num[a] + num[b]].push_back(pair<int, int>(a, b));
           }
       }
       for (int c = 0; c < num.size(); ++c) {
           for (size_t d = c + 1; d < num.size(); ++d) {
               const int key = target - num[c] - num[d];
               if (cache.find(key) == cache.end()) continue;
               const auto& vec = cache[key];
               for (size_t k = 0; k < vec.size(); ++k) {
                   if (c <= vec[k].second)
                       continue; // 有重叠
                   result.push_back( { num[vec[k].first],
                           num[vec[k].second], num[c], num[d] });
               }
           }
       }
       sort(result.begin(), result.end());
       result.erase(unique(result.begin(), result.end()), result.end());
       return result;
   }
};
```

下面是使用 multimap 的:

```cpp
// LeetCode, 4Sum
// 用一个 hashmap 先缓存两个数的和
// 时间复杂度 O(n^2)，空间复杂度 O(n^2)
// @author 龚陆安 (http://weibo.com/luangong)
class Solution {
public:
   vector<vector<int>> fourSum(vector<int>& num, int target) {
       vector<vector<int>> result;
       if (num.size() < 4) return result;
       sort(num.begin(), num.end());
       unordered_multimap<int, pair<int, int>> cache;
       for (int i = 0; i + 1 < num.size(); ++i)
           for (int j = i + 1; j < num.size(); ++j)
               cache.insert(make_pair(num[i] + num[j], make_pair(i, j)));
       for (auto i = cache.begin(); i != cache.end(); ++i) {
           int x = target - i->first;
           auto range = cache.equal_range(x);
           for (auto j = range.first; j != range.second; ++j) {
               auto a = i->second.first;
               auto b = i->second.second;
               auto c = j->second.first;
               auto d = j->second.second;
               if (a != c && a != d && b != c && b != d) {
                   vector<int> vec = { num[a], num[b], num[c], num[d] };
                   sort(vec.begin(), vec.end());
                   result.push_back(vec);
               }
           }
       }
       sort(result.begin(), result.end());
       result.erase(unique(result.begin(), result.end()), result.end());
       return result;
   }
};
```





### 454. 4Sum II

https://leetcode.com/problems/4sum-ii/description/

给定 4 个整型数组, 计算有多少个 `(i, j, k, l)` 四元组使得 `A[i] + B[j] + C[k] + D[l]` 的结果为 0.

(为了让问题简单一些, 假设所有的数组中元素数量为 0 <= N <= 500, 并且和的结果不超过 `2^31 - 1`), 比如:

```bash
Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
```



思路: 使用一个查找表, 记录 `A[i] + B[j]` 的和, 然后分析 C 和 D 中元素的和, 判断查找表中是否存在 `0 - C[k] - D[l]`.

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        // 使用 record 记录 A[i] + B[j] 的和有多少个
        unordered_map<int, int> record;
        for (int i = 0; i < A.size(); ++i)
            for (int j = 0; j < B.size(); ++j)
                record[A[i] + B[j]] ++;

        int res = 0;
        for (int i = 0; i < C.size(); ++i) {
            for (int j = 0; j < D.size(); ++j) {
                auto iter = record.find(0 - C[i] - D[j]);
                if (iter != record.end())
                    res += iter->second;
            }
        }
        return res;
    }
};
```





### 653. Two Sum IV - Input is a BST(未完)

https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/

依然是 two sum, 但是在一棵二叉搜索树上查找, 返回 True 或 False. 比如

```bash
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
```



### 88. *Merge Sorted Array

https://leetcode.com/problems/merge-sorted-array/description/

给定两个有序数组 num1 和 num2, 将两个数组中的元素有序的合并到 num1 中. 注意 nums1 的大小可以认为比 `m + n` 要大.

思路: 就是归并排序的思路, 但是要注意, 由于并没有额外的申请新的空间, 而是将数组保存到 nums1 上, 因此在 nums1 中需要从后向前开始排序, 并且还要将 nums1 中元素中与 nums2 的元素中选出最大的开始比较. 另外还需要注意 m 和 n 不能同时为 0, 但可以有一个为 0.

```cpp
class Solution {
public:
    // 注意题目已经假设 nums1 的大小至少和 m + n 一样大
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
      	// 这里在两者都小于 1 的情况下才返回, leetcode 有一个测试用例就是 m = 0,
      	// n = 1 这样也是可以的.
        if (m < 1 && n < 1)
            return;
		// 在 nums1 的末尾开始, 实现两个数组的归并.
        int k = m + n - 1;
        int i = m - 1, j = n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] < nums2[j])
                nums1[k--] = nums2[j--];
            else
                nums1[k--] = nums1[i--];
        }

        while (i >= 0)
            nums1[k--] = nums1[i--];
        while (j >= 0)
            nums1[k--] = nums2[j--];
    }
};
```



### 215. Kth Largest Element in an Array

https://leetcode.com/problems/kth-largest-element-in-an-array/description/

在一个未排序的数组中找到第 k 个最大的元素. 这个 k 指的是排好序后的第 k 个最大元素. 比如:

Given `[3,2,1,5,6,4]` and k = 2, return 5. (可以假设 `1 <= k <= arr.size()`)

思路: 目前的思路是使用快排的思路, 利用 partition 找到第 (k - 1) 个元素(将元素从大到小排序). 另外的思路可以使用一个优先队列, 返回第 k - 1 个元素.

```cpp
class Solution {
private:
  	// 使用两路快排的思路, 注意在 while 循环中, 我使用 >= v 的
  	// 元素放在前头, 使得左边的元素大于 v, 右边的元素小于 v
    int partition(vector<int> &nums, int l, int r) {
        if (l > r)
            return -1;

        int v = nums[l];
        // 注意 arr[l.... i) >= v, arr(j.... r] <= v
        // 以及i 和 j 的初始化, 要使得这两个集合都是空集.
        int i = l + 1, j = r;
        while (true) {
            while (i <= r && nums[i] >= v) i++;
            while (j >= l+1 && nums[j] <= v) j--;
            if (i > j)
                break;
            std::swap(nums[i++], nums[j--]);
        }
        std::swap(nums[l], nums[j]);
        return j;
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        if (nums.empty())
            return -1;
		
      	//while 中使用 index + 1 是因为数组从 0 开始计数, 而
      	// k 从 1 开始计数.
        int index = partition(nums, 0, nums.size() - 1);
        while ((index + 1) != k) {
            if ((index + 1) < k)
                index = partition(nums, index + 1, nums.size() - 1);
            else
                index = partition(nums, 0, index - 1);
        }
        return nums[index];
    }
};
```

下面是使用优先队列的代码:

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq(nums.begin(), nums.end());
        for(int i = 0; i < k-1; i++){
            pq.pop();
        }
        return pq.top();
    }
};
```



### 11. **Container With Most Water

https://leetcode.com/problems/container-with-most-water/description/

使容器盛上最多的水. 给定 n 个非负的整数 $a_1, a_2, ..., a_n$, 每一个表示位于 $(i, a_i)$ 处的点. 以 $(i, 0)$ 和 $(i, a_i)$ 为端点可以作 n 条垂直的直线. 其中, 每两条直线和 x 轴可以组成一个容器, 现在要找到两条直线, 它们和 x 轴形成的容器容量最大.

思路: 这个问题我第一次提交写错了, 给出我在给出的数组为 `height = {2,3,10,5,7,8,9}` 时报错, 正确的结果是 36, 可以看出是当 `i = 2, j = 6, height[i] = 10, height[j] = 9` 时得到最大值. 这道题应该采用双指针对撞的技术来减少考虑的情况. 但问题的关键是以什么标准来让两个指针进行移动. 通过仔细观察 height 可以发现, 当 `i = 0, j = n - 1` 时, 假设最大值 `res` 就是当前的容量, 那么之后 i he j 要怎样移动呢? 注意到 2 要比 9 小, 移动是必然要做的, 不管是 i 向右移动, 还是 j 向左移动, x 轴的大小总是要减小 1 的, 但是由于 2 比 9 小, 那么应该将 i 向右移动, 因为下一个 `height[i + 1]` 可能会使得容量最大, 因为如果 `height[i + 1]` 足够高, 而 9 也是一个比较大的值, 那么就有可能获得更大的容量. 

通过以上的分析, 就知道了 i 和 j 的移动规律, 也就是如果 `height[i] < height[j]`, 那么就将 i 向右移动, 反之, 则将 j 向左移动.

```cpp
class Solution {
private:
  	// 用于计算面积
    int Area(int i, int j, int ai, int aj) {
        return (j - i) * min(ai, aj);
    }
public:
    int maxArea(vector<int>& height) {
        if (height.empty())
            return 0;
		// res 保存最大值
        int i = 0, j = height.size() - 1;
        int res = Area(i, j, height[i], height[j]);
      	// 关于循环结束的条件, 是 i 和 j 至少有一个距离
      	// 在 if 后面的语句中, 即使 ++i == j, 也没有关系
      	// 这个时候的 Area 就是 0, 依然能得到正确的最大容量.
        while (i < j) {
            if (height[i] < height[j]) {
                ++i;
                res = max(res, Area(i, j, height[i], height[j]));
            }
            else {
                --j;
                res = max(res, Area(i, j, height[i], height[j]));
            }
        }
        return res;
    }
};
```



### 387. First Unique Character in a String

https://leetcode.com/problems/first-unique-character-in-a-string/description/

给定一个字符串, 查找第一个在字符串中没有重复的字符, 并返回它的索引; 如果不存在就返回 -1. 比如:

**Examples:**

```bash
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
```

**Note:** You may assume the string contain only lowercase letters.



思路: 由于可以认为字符串中只含有小写字母, 那么可以使用大小为 `vector<int>(26, 0)` 的数组保存字符的索引(如果不是小写字母, 那么就使用 `vector<int>(256, 0)`). 为什么保存索引能成功呢? 因为索引都是正数, 如果遇到重复的字符, 我就把索引设置为负数, 那么之后只要遍历一遍数组, 专门处理值大于 0 的值, 就可以找到最小的索引. 这里需要注意的是索引 0, 如果数组初始化为 -1, 可以避免这个尴尬. 当然也可以初始化为 0.

```cpp
// 这是我第二次提交的代码
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty())
            return -1;

        vector<int> records(26, 0);

        for (int i = 0; i < s.size(); ++i) {
            int index = s[i] - 'a';
            if (records[index] == 0)
                records[index] = i + 1; // 保存索引+1, 以免和 0 误会
            else if (records[index] > 0)
                records[index] = -1; // 如果有重复, 就设置为 -1.
        }
        int first = INT32_MAX;
        for (const auto &index : records) {
            if (index > 0)
                first = min(first, index);
        }

        if (first == INT32_MAX)
            return -1;
        return first - 1; // 最后要减 1
    }
};


// 下面是我第一次提交的代码, 比上面竟然还快...
// 但我觉得有个地方有问题, 注释中给出
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty())
            return -1;

        vector<int> records(26, -1);

        for (int i = 0; i < s.size(); ++i) {
            int index = s[i] - 'a';
            if (records[index] == -1)
                records[index] = i; // 保存索引
            else if (records[index] >= 0)
              	// 这里不断的减小可能会出问题, 如果 s.size() 太大的话.
                records[index] -= s.size();
        }
        int first = INT32_MAX;
        for (const auto &index : records) {
            if (index >= 0)
                first = min(first, index);
        }

        if (first == INT32_MAX)
            return -1;
        return first;
    }
};

// 看 leetcode 上有更简洁的做法
// 只要查找第一个出现次数为 1 的元素的索引即可.
class Solution {
public:
    int firstUniqChar(string s) {
        int ascii[256] = {0};
        
        for (char c : s) ascii[c - '0']++;
        for (int i = 0; i < s.size(); i++) {
            if (ascii[s[i] - '0'] == 1) return i;
        }
        
        return -1;
    }
};
```



### 561. *Array Partition I

https://leetcode.com/problems/array-partition-i/description/

给定 2n 个整数, 现在要将它们分成 n 个数对 (a1, b1), (a2, b2), ..., (an, bn), 使得 min(ai, bi) 的和 (`i = 1 ... n`) 尽可能大. 比如:

**Example 1:**

```bash
Input: [1,4,3,2]

Output: 4
Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
```

**Note:**

1. **n** is a positive integer, which is in the range of [1, 10000].
2. All the integers in the array will be in the range of [-10000, 10000].

思路: 这道题的关键是要观察到这样一个现象: 较大的数要聚在一起, 那么 min(ai, bi) 才会比较大. 比如上面的例子中, 如果 4 和 1 组成数对, 那么 min(1, 4) 就是 1, 相比 min(3, 4) 就小了. 因此, 思路就是将这个数组排序, 然后将 `0 ~ 2n - 1` 索引中偶数位置的元素相加即可.

```cpp
class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        if (nums.empty() || nums.size() % 2 == 1)
            throw invalid_argument("nums' size must be even");

        std::sort(nums.begin(), nums.end());
        int sum = 0;
        for (int i = 0; i < nums.size(); i += 2)
            sum += nums[i];
        return sum;
    }
};
```

leetcode 上有对这一思路的证明: [Java Solution, Sorting. And rough proof of algorithm.](https://leetcode.com/problems/array-partition-i/discuss/102170/Java-Solution-Sorting.-And-rough-proof-of-algorithm.)



### 566. *Reshape the Matrix

https://leetcode.com/problems/reshape-the-matrix/description/

类似于 matlab 中的 reshape 函数, 将一个矩阵给 reshape. 如果无法 reshape, 就返回原矩阵. 两个矩阵以行来遍历的话相同.



思路: 对于元素个数为 `rows * cols` 的矩阵, 在 `[0 ~ rows * cols - 1]` 范围内的元素 k, 对应于矩阵中的位置为 `(k/cols, k%cols)`, 知道这一点后, 解法很简单. 另外, 发现使用两个循环还更快.

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        int rows = nums.size(), cols = nums[0].size();
        if ((rows * cols) != (r * c) || r <= 0 || c <= 0)
            return nums;

        vector<vector<int>> res(r, vector<int>(c));
        for (int k = 0; k < rows * cols; ++k) {
            res[k/c][k%c] = nums[k/cols][k%cols];
        }
        return res;
    }
};
```

下面是使用两个循环的:

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        int row = nums.size();
        int column = nums[0].size();
        if(row * column != r * c) return nums;
        
        vector<vector<int>> ans(r, vector<int>(c));
        
        for(int i = 0; i < r; i++)
            for(int j = 0; j < c; j++)
                ans[i][j] = nums[(i * c + j) / column][(i * c + j) % column];
        return ans;
    }
};
```



### 724. *Find Pivot Index

https://leetcode.com/problems/find-pivot-index/description/

给定一个整型数组, 返回这个数组的 pivot 索引 i, 使得它左边的所有数 nums[0,...., i - 1] 与右边所有数 nums[i + 1,..., n - 1] 的和相等. 如果没有这样的索引, 返回 -1. 比如:

**Example 1:**

```bash
Input: 
nums = [1, 7, 3, 6, 5, 6]
Output: 3
Explanation: 
The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.
Also, 3 is the first index where this occurs.
```

**Example 2:**

```bash
Input: 
nums = [1, 2, 3]
Output: -1
Explanation: 
There is no index that satisfies the conditions in the problem statement.
```

**Note:**

The length of `nums` will be in the range `[0, 10000]`.

Each element `nums[i]` will be an integer in the range `[-1000, 1000]`.

思路: 好吧, 这道题我做错了多遍...这里直接给出 leetcode 的解答. 首先求出整个数组的和 sum, 然后依次遍历每一个索引 i, 判断左边的和 leftsum 是否等于 `sum - nums[i] - leftsum` (即右边的和, 注意不包括 nums[i]), 如果不相等, 那么 leftsum += nums[i].

https://leetcode.com/problems/find-pivot-index/solution/

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = 0, leftsum = 0;
        for (auto &d : nums) sum += d;

        for (int i = 0; i < nums.size(); ++i) {
            if (leftsum == sum - nums[i] - leftsum)
                return i;
            else
                leftsum += nums[i];
        }
        return -1;
    }
};
```





### 118. *Pascal's Triangle

https://leetcode.com/problems/pascals-triangle/description/

杨辉三角形.

Given *numRows*, generate the first *numRows* of Pascal's triangle.

For example, given *numRows* = 5,
Return

```bash
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

思路: 仔细观察, 末尾的 1 就是上一行的最后一位加上 0, 所以要判断是否为最后一位.

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        if (numRows <= 0)
            return vector<vector<int>>{};

        vector<int> prev{1};
        vector<vector<int>> res{prev};

        for (int i = 1; i < numRows; ++i) {
            vector<int> path(i + 1, 0);
            path[0] = 1;
            for (int j = 0; j < prev.size(); ++j) {
                if (j + 1 == prev.size())
                    path[j + 1] = prev[j] + 0;
                else
                    path[j + 1] = prev[j] + prev[j + 1];
            }
            res.push_back(path);
            prev = path;
        }
        return res;
    }
};
```

经下面 119. Pascal's Triangle II 这道题的启发, 我们可以从后向前计算, 代码看起来会更简洁:

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        if (numRows <= 0)
            return vector<vector<int>>{};

        vector<int> prev{1};
        vector<vector<int>> res{prev};

        for (int i = 1; i < numRows; ++i) {
            vector<int> path(i + 1, 0);
            path[0] = 1;
            path[i] = 1;
            for (int j = i - 1; j > 0; --j)
                path[j] = prev[j] + prev[j - 1];
            res.push_back(path);
            prev = path;
        }

        return res;
    }
};
```



### 119. *Pascal's Triangle II

https://leetcode.com/problems/pascals-triangle-ii/description/

```bash
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

给定index k, 返回杨辉三角形中的第 k 行. 比如给定 k = 3, 返回 `[1, 3, 3, 1]`.



思路: 这道题如果从前往后计算就特别麻烦, 我等下会给出这个思路的方法. 在 leetcode 上看到如下的解法, 从后向前计算, 非常简洁:

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> result(rowIndex+1, 0);
        result[0] = 1;
        for(int i = 1; i <= rowIndex; i++) {
            for(int j = i; j >= 1; j--) {
                result[j] = result[j] + result[j-1];
            }
        }
        return result;
    }
};
```

下面是我的解法: 不过多解释, 调试了半天...

```cpp
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        if (rowIndex < 0)
            return vector<int>{};

        vector<int> res(rowIndex + 1, 0);
        res[0] = 1;

        int prev = res[0], now = 0;;
        for (int i = 1; i <= rowIndex; ++i) {
            for (int j = 1; j < i + 1; ++j) {
                now = res[j];
                res[j] += prev;
                prev = now;
            }
            prev = res[0];
        }
        res.erase(res.begin() + rowIndex + 1, res.end());
        return res;
    }
};
```



### 485. *Max Consecutive Ones

https://leetcode.com/problems/max-consecutive-ones/description/

给定一个只包含 0-1 的数组, 找出 1 的连续个数最多是多少?

```bash
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
```

**Note:**

- The input array will only contain `0` and `1`.
- The length of input array is a positive integer and will not exceed 10,000



思路: 解法一: 使用 [i, j] 来标识只包含 1 的连续子数组的范围. 如果当前访问的元素(其中 `j + 1` 表示当前访问的元素)是 1, 那么 `j++`, 否则, `i = ++j + 1`;

```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int i = 0, j = -1;
        int res = 0;
        while (i < nums.size()) {
            if (nums[j + 1] == 1)
                j ++;
            else {
                res = max(res, j - i + 1);
                i = ++j + 1;
            }
        }
        return res;
    }
};
```

如果只用一个索引来遍历数组, 而不是像上面使用两个索引(i 和 j)来标识范围, 那么可以看看下面的解法:

[Java 4 lines concise solution with explanation](https://leetcode.com/problems/max-consecutive-ones/discuss/96693/Java-4-lines-concise-solution-with-explanation/101261)

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0;
        int sum = 0;
        for(int i = 0 ; i< nums.length; i ++){
            sum += nums[i];
            if(nums[i] == 0)    // reset sum to zero when encounters zeros
                sum = 0;
            else                // keep update max
                max = Math.max(max, sum);
        }
        return max;
    }
}
```



### 169. *Majority Element

https://leetcode.com/problems/majority-element/description/

给定一个长度为 n 的数组, 找出出现次数超过 `⌊ n/2 ⌋` 的元素(它被称为 majority element).

You may assume that the array is non-empty and the majority element always exist in the array.

思路: 这道题复杂在若用 O(n) 的方法解决. 最直观的思路是, 我可以排序, 然后找中间的元素:

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        std::sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```

[6 Suggested Solutions in C++ with Explanations](https://leetcode.com/problems/majority-element/discuss/51612/6-Suggested-Solutions-in-C++-with-Explanations) 给出了 6 种方法:

1. 使用 Hash 表统计元素个数, 下面的写法可以借鉴, 很简洁:

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           unordered_map<int, int> counts; 
           int n = nums.size();
           for (int i = 0; i < n; i++)
             	// 一方面将元素加入到表中, 同时将比较完成.
               if (++counts[nums[i]] > n / 2) 
                   return nums[i];
       }
   };
   ```

2. 对数组进行排序, 取中间的那个数. 代码上面有.

3. 从数组中随机选取某个数, 然后判断它是不是 Majority element, 多次重复这个过程. 链接中说速度很快.

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           int n = nums.size();
           srand(unsigned(time(NULL)));
           while (true) {
               int idx = rand() % n;
               int candidate = nums[idx];
               int counts = 0; 
               for (int i = 0; i < n; i++)
                   if (nums[i] == candidate)
                       counts++; 
               if (counts > n / 2) return candidate;
           }
       }
   };
   ```

4. **Divide and Conquer** 分治法. 每次将数组分成两个部分, 类似于归并排序, 即进行 divide, 然后判断 left 和 right 中哪个值的数量最多. 注意边界条件是, 当 divide 后只有一个元素时, majority element 就是该元素本身.

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           return majority(nums, 0, nums.size() - 1);
       }
   private:
       int majority(vector<int>& nums, int left, int right) {
           if (left == right) return nums[left];
           int mid = left + ((right - left) >> 1);
           int lm = majority(nums, left, mid);
           int rm = majority(nums, mid + 1, right);
           if (lm == rm) return lm;
           return count(nums.begin() + left, nums.begin() + right + 1, lm) > count(nums.begin() + left, nums.begin() + right + 1, rm) ? lm : rm;
       }
   }; 
   ```

5. **Moore Voting Algorithm** 

   这个方法太牛啦! 使用 O(n) 以及 O(1) 的时间以及空间复杂度.

   A brilliant and easy-to-implement algorithm! It also runs very fast, about 20ms.

   使用 counts 用于记录票数, 使用 major 用于记录出现可能是 majority element 的元素. 当 counts 为 0 的时候, 设置当前访问的 `nums[i]` 为 major, 之后访问新的元素时, 如果新元素与 major 相等, 那么就 counts 加 1; 否则将 counts 减 1. 从程序中可以看出, 对于 2n + 1 个元素, 如果 majority element 的个数是 n + 1, 那么最后 counts 的值就是 1. 有点像使用 `nums[i....n - 1]` 这些元素来对 major 进行投票, 值相等才增加票数, 值不等那么就消减票数.rug

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           int major, counts = 0, n = nums.size();
           for (int i = 0; i < n; i++) {
               if (!counts) {
                   major = nums[i];
                   counts = 1;
               }
               else counts += (nums[i] == major) ? 1 : -1;
           }
           return major;
       }
   };
   ```

6. **Bit Manipulation** (没看懂)

   Another nice idea! The key lies in how to count the number of `1`'s on a specific bit. Specifically, you need a `mask` with a `1` on the `i`-the bit and `0` otherwise to get the `i`-th bit of each element in `nums`. The code is as follows.

   ```cpp
   class Solution {
   public:
       int majorityElement(vector<int>& nums) {
           int major = 0, n = nums.size();
           for (int i = 0, mask = 1; i < 32; i++, mask <<= 1) {
               int bitCounts = 0;
               for (int j = 0; j < n; j++) {
                   if (nums[j] & mask) bitCounts++;
                   if (bitCounts > n / 2) {
                       major |= mask;
                       break;
                   }
               }
           } 
           return major;
       } 
   };
   ```



### 611. **Valid Triangle Number

https://leetcode.com/problems/valid-triangle-number/description/

给定一个由非负整数组成的数组, 要求出所有能组成三角形的三元组的个数. 比如:

```bash
Input: [2,2,3,4]
Output: 3
Explanation:
Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
```



思路: 这道题的话, 先对数组进行从小到大排序的话, 思考会轻松一些. 这样的话, 就要找到 `i < j < k`, 使得 `nums[i] + nums[j] > nums[k]`. 当 i 和 j 确定之后, 对于 k 的话, 从 `(i + 2)` 这个索引开始搜索, 一直找到第一个不满足上面不等式条件的 k 值. 然后再考虑下一个 j. 说不清楚了, 直接看代码. 注意下面代码中很重要的一点, `k = i + 2` 放在 `for(int i = 0;...)` 的下面而不是放在 `for(int j = 0;...)` 的下面, 这是一步非常非常重要的优化. 当然 `k = i + 2` 可以放在  `for(int j = 0;...)`  的下面, 但是这样会极其耗时, 方法退化到 `O(n^3)`. 按照如下代码所写, 那么当 `++j` 后, 对于当前的 k 值, `nums[i+2,....k-1]` 仍然是满足 `nums[i] + nums[j] > nums[k]` 的, 不需要重复判断 `nums[i+2,...k-1]` 这些值是否仍按照这个 > 条件.

```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        if (nums.size() < 3)
            return 0;

        int count = 0;
        std::sort(nums.begin(), nums.end());
      	// 三元组 (i, j, k), 那么 i 最多到 nums.size() - 2
      	// k 的初始值为 i + 2. k 最多移动到 nusm.size() - 1;
      	// 当确定 j 之后, 使用 while 循环知道第一个不满足 > 条件的 k,
      	// 那么满足条件的三角形就是 k - j - 1.
      	// 注意 k = i + 2 放置的位置, 当 j 发生变化时, nums[i+2,...,k-1]
      	// 肯定满足 nums[i] + nums[j] > nums[k] 的, 所以不需要重复累加.
        for (int i = 0; i < nums.size() - 2; ++i) {
            int k = i + 2;
            for (int j = i + 1; j < nums.size() - 1 && nums[i] != 0; ++j) {
                while (k < nums.size() && nums[i] + nums[j] > nums[k])
                    k ++;
                count += k - j - 1;
            }
        }
        return count;
    }
};
```

leetcode 有官方解答, 非常清晰:

https://leetcode.com/problems/valid-triangle-number/solution/

在 leetcode 提交之后还看到一个新奇的解法, 如下:

排序之后, 从后向前考虑. 简洁精彩啊.

```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        sort(nums.begin(),nums.end());
        int count = 0;
        int n = nums.size();
        for(int k = n-1; k >= 0; k--){
            int i = 0;
            int j = k-1;
            while(i < j){
                if(nums[i] + nums[j] > nums[k]) {
                    count += j-i;
                    j--;
                }
                else i++;                    
            }
        }
        return count;
    }
};
```



### 56. **Merge Intervals

https://leetcode.com/problems/merge-intervals/description/

给定一些区间, 将有重合部分的区间合并. 比如:

Given a collection of intervals, merge all overlapping intervals.

For example,
Given `[1,3],[2,6],[8,10],[15,18]`,
return `[1,6],[8,10],[15,18]`.



思路: 我这里使用优先队列来解决. 按 Interval 的 `end` 值的大小, 将区间加入到最大堆中. 这样每次弹出的区间总是坐标轴上最右边的, 如果当前弹出来的区间 `small` 与已经弹出来的区间 `large` 比较, 如果它们有重合(这个时候很好比较了, 只要看 small 的 start 与 large 的 start 即可), 那么合并, 否则, 将 large 存入 res 中, 然后将 small 设置为 large, 用于下一次比较.

```cpp
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
private:
    struct Comp {
        bool operator()(const Interval &lhs, const Interval &rhs) {
            return lhs.end < rhs.end;
        }
    };
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        if (intervals.empty())
            return {};
        priority_queue<Interval, vector<Interval>, Comp> Queue(intervals.begin(), intervals.end());
        vector<Interval> res;
        Interval large = Queue.top();
        Queue.pop();
        while (!Queue.empty()) {
            Interval small = Queue.top();
            Queue.pop();
            if (small.end >= large.start)
                large.start = small.start < large.start ? small.start : large.start;
            else {
                res.push_back(large);
                large = small;
            }
        }
        res.push_back(large);
        return res;
    }
};
```









## 回溯法(Backtracking)

回溯, 沿着路径寻找答案, 一旦到底的话就回去继续去寻找
回溯法是暴力解法的一个主要实现手段. 一般来讲，会设置一个递归函数，函数的参数会携带一些当前的可能解的信息，根据这些参数得出可能解或者不可能而回溯。

[回溯算法（Backtracking）说明与实例](https://blog.csdn.net/leoleocs/article/details/47311283#t2) 这个博客关于回溯算法的介绍非常清晰.

### 78. **Subsets

https://leetcode.com/problems/subsets/description/

给定一个数组, 其中的元素都不相同, 返回这个数组所有的子集. 比如:

If **nums** = `[1,2,3]`, a solution is:

```bash
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```



思路: 给定一个长度为 n 的数组, 那么总共有 2 的 n 次方个子集. 如果使用 res 来保存这些子集的话, 

假设 A 表示 res 中的所有子集, 当访问元素 `nums[i]` 时, 将 `nums[i]` 加入到 A 的每个元素中, 就形成了新的子集 B, 然后更新 res 为 `A + B`. 即可.

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        vector<vector<int>> res;
        vector<int> cur;
        res.push_back(cur); // 初始时保存空子集
        while (i < n) {
          	// start 来遍历 res 中的每个子集.
          	// 下面注释看不懂那就不用管, 记录我曾写的一个 bug.
          	// 注意不要使用迭代器, 因为会在 res 中插入新的元素,
          	// 尾部迭代器 end 会失效. 所以这里使用索引 end.
            int start = 0;
            int end = res.size();
			// 依次访问 res 中的每个子集, 并将 nums[i] 加入到这些子集中
            while (start < end) { 
                cur = res[start];
                cur.push_back(nums[i]);
                ++start;
                res.push_back(cur);
            }
            ++i;
        }
        return res;
    }
};
```

leetcode 上给出了特别详细的讨论和总结:

[C++ Recursive/Iterative/Bit-Manipulation Solutions with Explanations](https://leetcode.com/problems/subsets/discuss/27278/C++-RecursiveIterativeBit-Manipulation-Solutions-with-Explanations)



### 17.  **Letter Combinations of a Phone Number

https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/

给定一个由数字组成的字符串, 返回这些数字所能表示的所有的字符组合. 这道题有个图, 即原来的诺基亚手机上每个数字下面对应多个字符, 把这些字符和数字对应起来就是: (其中 1 没有对应任何字符, 而 0 对应空格)

```c++
{'2', {"a", "b", "c"}},
{'3', {"d", "e", "f"}},
{'4', {"g", "h", "i"}},
{'5', {"j", "k", "l"}},
{'6', {"m", "n", "o"}},
{'7', {"p", "q", "r", "s"}},
{'8', {"t", "u", "v"}},
{'9', {"w", "x", "y", "z"}}
```

现在, 我给定数字组成的字符串 "23", 那么就能得到如下字符组合:

```bash
Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```



思路: 这是一个树型问题, 拿 "23" 来说, 2 对应的字符有 "a", "b", "c", 而 3 对应的字符有 "d", "e", "f". 组合在一起就有 9 种情况. 那么对于任意输入的数字串 digits, 思路一: 如果我能得到由 digits[1....n-1] 中的所有组合 A, 那么只要把 digits[0] 对应的每个字母, 加在 A 中的每个组合前即可. 下面两种解法的时间复杂度为 3^n = O(2^n)

解法一: 按照思路一的介绍, 可以理解为这是一棵向上生长的树, 直到生长到根(digit[0])为止.

```cpp
class Solution {
private:
    unordered_map<char, vector<string>> phone = {
        {'2', {"a", "b", "c"}},
        {'3', {"d", "e", "f"}},
        {'4', {"g", "h", "i"}},
        {'5', {"j", "k", "l"}},
        {'6', {"m", "n", "o"}},
        {'7', {"p", "q", "r", "s"}},
        {'8', {"t", "u", "v"}},
        {'9', {"w", "x", "y", "z"}}
    };
    vector<string> combinations(string &s, int i) {
      	// s 为空的时候, 返回的是空结果
        if (i >= s.size())
            return vector<string>{};
		// 这应该是真正的边界情况, 如果只剩最后一个数字了, 那么
      	// 返回去该数字对应的单个字符.
        if (i == s.size() - 1)
            return phone[s[i]];

        vector<string> res;
      	// combinations(s, i + 1) 求出了 digits[i+1, ...n-1] 的所有组合
      	// 只要将 digits[i] 对应的字符加在那些组合前面即可.
        for (auto &str : combinations(s, i + 1))
            for (auto &c : phone[s[i]])
                res.push_back(c + str);
        return res;
    }
public:
    vector<string> letterCombinations(string digits) {
        return combinations(digits, 0);
    }
};
```

思路二: 构建一棵向下生长的树, 即考虑完 digits[i] 后, 然后接着考虑 digits[i+1],... 持续这个过程一直到 digits[n - 1]. 这样的话, 就需要有个变量(引用), 来记录当考虑 digits[i+1] 时, 处理完 digits[i] 后得到的结果, 我在下面的代码设置为 cur.

```cpp
// 下面代码的写法有一点树往下生长的感觉
class Solution {
private:
    vector<string> res;
    unordered_map<char, vector<string>> phone = {
        {'2', {"a", "b", "c"}},
        {'3', {"d", "e", "f"}},
        {'4', {"g", "h", "i"}},
        {'5', {"j", "k", "l"}},
        {'6', {"m", "n", "o"}},
        {'7', {"p", "q", "r", "s"}},
        {'8', {"t", "u", "v"}},
        {'9', {"w", "x", "y", "z"}}
    };
    void combinations(string &s, int i, const string &cur) {
      	// 遍历到底的话, 就将结果加入到 res 中.
        if (i == s.size())
            res.push_back(cur);
        vector<string> letters = phone[s[i]];
        for (auto &c : letters)
          	// 注意这里产生右值, 所以 combitions 最后一个参数需要是 const 的
            combinations(s, i + 1, cur + c); 
    }
public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty())
            return {};
        res.clear(); // 初始化 res
        combinations(digits, 0, "");
        return res;
    }
};
```



### 39. **Combination Sum

https://leetcode.com/problems/combination-sum/description/

Given a **set** of candidate numbers (**C**) **(without duplicates)** and a target number (**T**), find all unique combinations in **C** where the candidate numbers sums to **T**.

The **same** repeated number may be chosen from **C** unlimited number of times.

**Note:**

- All numbers (including target) will be positive integers.
- The solution set must not contain duplicate combinations.

For example, given candidate set `[2, 3, 6, 7]` and target `7`, 
A solution set is: 

```bash
[
  [7],
  [2, 2, 3]
]
```

注意元素可以重复选取.



思路: 观察上面的例子可以看到, 由于元素可以重复选取, 可能会得到如下结果:

```bash
[2, 2, 3]
[2, 3, 2]
```

但是它们是重复的结果, 所以要舍去一个. 因此, 为了得到 unique 的结果, 最好将  candidate set 进行排序, 当选取了 3, 就不应该再选取 2 了. 也就是说, 每次选取 nums[i] 时, 之后递归只能选取 nums[i] 以及之后的数字, 而不能选取 nums[0, ... i-1] 那些数字, 否则可能发生重复.

我的回溯是假回溯. 要学真回溯应该去看看讨论组. 这里谈下我的思路. 对于 candidate set 中的每个元元素值 `nums[i]` (注意为了避免重复以及将 set 从小到大排序了), 判断它是否和 target 相等, 如果相等就可以加入到 res 中. 否则再判断 `f(target - nums[i])` 返回的满足 sum 等于 `target - nums[i]` 的序列是否为空, 如果不为空, 则将 `nums[i]` 分别加入到这些序列中即可.

```cpp
class Solution {
private:
  	// start 的使用非常关键, 因为它可以避免最后结果不唯一. 由于 candidates 先排好序了,
  	// 当当前 combinations 使用了 nums[start], 那之后递归调用 combinations 时只能使用
  	// nums[start....n-1] 中的值.
    vector<vector<int>> combinations(vector<int> &candidates, int target, int start) {
        vector<vector<int>> res;
        for (int i = start; i < candidates.size() && candidates[i] <= target; ++i) {
            if (candidates[i] == target)
                res.push_back({candidates[i]});
          	// 对于不等于 target 的 candidates[i], 判断 
          	// sum 为 target - candidates[i] 的序列有哪些.
            auto conditions = combinations(candidates, target - candidates[i], i);
            if (!conditions.empty()) {
                for (auto &condition : conditions) {
                    condition.push_back(candidates[i]);
                    res.push_back(condition);
                }
            }
        }
        return res;
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if (target <= 0)
            return {};
        std::sort(candidates.begin(), candidates.end());
        return combinations(candidates, target, 0);
    }
};
```

以下两个正宗一些的 Backtracking 可以学习:

[Accepted 16ms c++ solution use backtracking, easy understand.](https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.)

[Almost same solution for two problems Combination Sum and Combination Sum II , C++  Code with comments ,fast](https://leetcode.com/problems/combination-sum/discuss/16666/Almost-same-solution-for-two-problems-Combination-Sum-and-Combination-Sum-II-C++-Code-with-comments-fast)



### 40. **Combination Sum II

https://leetcode.com/problems/combination-sum-ii/description/

Given a collection of candidate numbers (**C**) and a target number (**T**), find all unique combinations in **C** where the candidate numbers sums to **T**.

Each number in **C** may only be used **once** in the combination.

**Note:**

- All numbers (including target) will be positive integers.
- The solution set must not contain duplicate combinations.

For example, given candidate set `[10, 1, 2, 7, 6, 1, 5]` and target `8`, 
A solution set is: 

```bash
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```



思路: 和第一题的区别是, candidate set 中存在重复元素, 但是每个元素只能用一次. 由于存在重复元素, 还是有必要先排序, 并引入 start(参见 39. Combination Sum). 之后的思路是一致的.

```cpp
class Solution {
private:
    vector<vector<int>> combinations(vector<int> &candidates, int target, int start) {
        vector<vector<int>> res;
        for (int i = start; i < candidates.size() && candidates[i] <= target; ++i) {
          	// 如果 candidates[i] 和 candidates[i - 1] 相等, 那么就没有必要再考虑了,
          	// 因为在访问 candidates[i - 1] 时, 已经把考虑 candidates[i] 时的所有情况
          	// 都包含了.
            if (i > start && candidates[i] == candidates[i - 1])
                continue;
            if (candidates[i] == target)
                res.push_back({candidates[i]});
          	// 注意 start 更新到 i+1, 因为 candidates 中的每个元素只能用一次.
          	// 当 candidates[i] 和 target 不相等时, 求出 sum 等于 
          	// target - candidates[i] 的子序列.
            auto conditions = combinations(candidates, target - candidates[i], i + 1);
            if (!conditions.empty()) {
                for (auto &condition : conditions) {
                    condition.push_back(candidates[i]);
                    res.push_back(condition);
                }
            }
        }
        return res;
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        if (target <= 0)
            return {};
        std::sort(candidates.begin(), candidates.end());
        return combinations(candidates, target, 0);
    }
};
```



### 216. **Combination Sum III

https://leetcode.com/problems/combination-sum-iii/description/

Find all possible combinations of **\*k*** numbers that add up to a number **\*n***, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

Example 1:

Input: k= 3, n = 7

Output:

```bash
[[1,2,4]]
```

Example 2:

Input: k= 3, n = 9

Output:

```bash
[[1,2,6], [1,3,5], [2,3,4]]
```

题意: 从 1 到 9 中选出 k 个数, 使它们的和等于 target n. 结果之间不重复.



思路: 这道题和 39. Combination Sum 的区别在于, 这里规定了必须是 k 个数, 由于候选数组已经确定了是 1 ~ 9 这 9 个数字, 所以不需要排序了. 当时为了防止结果之间有重复, 仍需要设置 start, 当访问到 start 时, 下次迭代只能访问 start 以及 start 之后的元素. 由于规定了必须是 k 个数组成的结果, 所以我在下面的代码中, 给 `combinations` 函数多设置了两个参数 level 以及 thisk, 分别表示当前递归调用 combinations 的次数, 以及 k 值是多少. 只有当 level 和 thisk 相等时, 说明递归调用的次数已经到了 k 次, 才可以将结果加入到 res 中.

```cpp
class Solution {
private:
    vector<vector<int>> combinations(int k, int n, int level, int thisk, int start) {
        vector<vector<int>> res;
        if (k <= 0 || n < 1)
            return res;
        for (int i = start; i < 10; ++i) {
          	// 只有当递归调用的 level 已经到了 thisk, 才可以将
          	// 结果加入到 res 中.
            if (i == n && level == thisk)
                res.push_back({i});
          	// 考虑 n - i 的返回结果, 如果 conditions 不为空的话,
          	// 说明存在使得 k - 1 个元素的和等于 n - i, 那么此时将 
          	// i 加入到 res 中即可.
            auto conditions = combinations(k - 1, n - i, level + 1, thisk, i + 1);
            if (!conditions.empty()) {
                for (auto &condition : conditions) {
                    if (condition.size() == k - 1) {
                        condition.push_back(i);
                        res.push_back(condition);
                    }
                }
            }
        }
        return res;

    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        return combinations(k, n, 1, k, 1);
    }
};
```















