# Map

## 查找表

### 349. Intersection of Two Arrays

https://leetcode.com/problems/intersection-of-two-arrays/description/

求两个数组的交集, 注意结果中的每个元素都是唯一的, 并且不用考虑元素的顺序.

比如给定: *nums1* = `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, return `[2]`.

思路: 使用 set, 将两个数组中的元素拷贝进 set 中, 那么 set1 和 set2 中的元素都是唯一的, 从而求两个 set 的交集.

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        set<int> isection1(nums1.begin(), nums1.end());
        set<int> isection2(nums2.begin(), nums2.end());

        vector<int> res;
        for (const auto &d : isection1) {
            if (isection2.find(d) != isection2.end())
                res.push_back(d);
        }
        return res;
    }
};

// 第二种方法只用一个 set, 但是每次在 set 中查找完 nums2 中的元素后,
// 应将 set 中的对应元素删除.
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> isection(nums1.begin(), nums1.end());

        vector<int> res;
        for (const auto &d : nums2) {
            if (isection.find(d) != isection.end()) {
                res.push_back(d);
                isection.erase(d);
            }
        }

        return res;
    }
};
```



### 350. Intersection of Two Arrays II

https://leetcode.com/problems/intersection-of-two-arrays-ii/description/

求两个数组的交集, 但是要尽可能保留重合的元素, 不考虑结果中元素的顺序.

**Example:**
Given *nums1* = `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, return `[2, 2]`.

思路: 这个时候就需要使用 map 而不是 set 了, 使用 map 来统计每个元素的个数. 当然还有方法就是先对数组进行排序, 然后再依次比较两个数组中当前访问元素的大小是否相等.

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
      	// 统计 nums1 中的每个元素的个数
        unordered_map<int, int> freq;
        for (const auto &d : nums1)
            freq[d] ++;

        vector<int> res;
      	// 对于 nums2 中的元素, 如果在 freq 中, 那么就要加入到 res 中,
      	// 但是由于这里没有用 erase 删除已经访问过的元素, 所以还加上了 
      	// freq[d] != 0 的判断
        for (const auto &d : nums2) {
            if (freq.find(d) != freq.end() && freq[d] != 0) {
                res.push_back(d);
                freq[d] --;
            }
        }
        return res;
    }
};


// 如果给两个数组排序, 那么可以使用如下方法求.
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res;
        std::sort(nums1.begin(), nums1.end());
        std::sort(nums2.begin(), nums2.end());
        int i = 0, j = 0;
        while (i < nums1.size() && j < nums2.size()) {
            if (nums1[i] == nums2[j]) {
                res.push_back(nums1[i]);
                i++;
                j++;
            } else if (nums1[i] < nums2[j]) {
                i++;
            } else {
                j++;
            }
        }
        return res;
    }
};
```



### 202. Happy Number

https://leetcode.com/problems/happy-number/description/

判断一个正整数是否为一个 Happy Number. Happy Number 的定义是: A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

比如: 19 是一个 Happy Number:

$1^2 + 9^2 = 82$

$8^2 + 2^2 = 68$

$6^2 + 8^2 = 100$

$1^2 + 0^2 + 0^2 = 1$

思路: 根据 Happy Number 的定义可以知道, 按照这个计算步骤处理某个数, 最后要么得到 1, 要么会无限循环, 无限循环造成的原因是, 比如第一次运算结果为 a1, 第二次运算结果为 a2,... an, 那么此时可以得到一个数组 `[a1, a2, ..., an]`, 那么当第 n + 1 次运算的结果等于这个数组中的某一个的时候, 就会出现无限循环的结果. 为了处理这种情况, 我下面使用了一个 `unordered_set` 来保存每一次运算的结果, 当算出新的结果时, 要判断新结果是否出现在历史结果中, 如果出现了, 说明会出现无限循环的情况, 函数就要返回.

```cpp
class Solution {
private:
  	// Sum 用于求平方和.
    int Sum(int n) {
        int sum = 0;
        while(n)
        {
            int a = n % 10;
            n /= 10;
            sum += a * a;
        }
        return sum;
    }
	// 判断是否会发生无限递归的情况, 如果会发生, 那么返回 true.
  	// 如果某次结果为 1, 那么说明不会发生无限递归的情况, 返回 false.
  	// 否则, 每次将结果计算出来之后, 要到 origin 中查找是否出现在历史结果中,
  	// 如果没有出现并且结果不是 1, 那么就将其加入到 origin 之中. 然后判断
  	// 新结果 sum 是否会造成无限递归或者等于 1.
    bool isRecursive(int n, unordered_set<int> &origin) {
        int sum = Sum(n);
        //cout << sum << endl;

        if (sum == 1)
            return false;
        if (origin.find(sum) != origin.end())
            return true;

        origin.insert(sum);
        return isRecursive(sum, origin);
    }
public:
    bool isHappy(int n) {
        if (n <= 0)
            return false;
        unordered_set<int> origin;
        return !isRecursive(n, origin);
    }
};
```



### 290. Word Pattern

https://leetcode.com/problems/word-pattern/description/

给定一个 pattern 和一个字符串 str, 判断 str 是否符合 pattern. 假设 pattern 中只有小写字母, str 只包含由空格分隔的小写字母. 比如:

**Examples:**

1. pattern = `"abba"`, str = `"dog cat cat dog"` should return true.
2. pattern = `"abba"`, str = `"dog cat cat fish"` should return false.
3. pattern = `"aaaa"`, str = `"dog cat cat dog"` should return false.
4. pattern = `"abba"`, str = `"dog dog dog dog"` should return false.

思路: 由于 str 是由空格分隔的字符串, 那么可以使用 `<sstream>` 中的 `stringstream` 进行处理. 另外关于字符串分割技术可以参看 [字符串分割技术](https://segmentfault.com/a/1190000002483483). 之后具体的逻辑是: 需要一张查找表 `unordered_map<char, string>` 用于记录 pattern 中每个字符和 str 中每个小字符串之间的联系, 它们之间是一一对应的, 如果遍历到 `(pattern[i], str[i])` (注意 `str[i]` 不是表示一个字符, 而是空格分开的小字符串), 判断 `pattern[i]` 是否在查找表中, 如果没有的话, 那么就可以将这个 pair 插入进去. 但插入的时候还要考虑这样一种情况: `pattern = "abba", str = "dog dog dog dog"`, 当访问到 `(b, dog)` 时, 由于查找表中当前有 `(a, dog)`, 虽然 b 和 a 不相等, 但是不能将 `(b, dog)` 插入到查找表中, 为了处理这种情况, 引入 `unordered_set<string>` 来存放已经访问过的小字符串, 只有 dog 不在这个 set 中, 那么才可以将 b 插入到查找表中.

如果 `pattern[i]` 在查找表中, 那么就需要判断 `str[i]` 是否和原来的相等.

最后, 我在代码中使用 `streams.eof()` 才返回 true, 是要保证 pattern 的大小和 str 中小字符串的个数相等.

注: 这是我写的第一道速度能 beats 100% 的提交的习题.

```cpp
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        if (pattern.empty() || str.empty())
            return false;
        
        // bijection 是映射的意思, 用于存放 pattern 和 str 的关系
      	// strset 用于记录已经处理过的 string 了.
        unordered_map<char, string> bijection;
        unordered_set<string> strset;
        string s;
        stringstream streams(str);
        for (int i = 0; i < pattern.size(); ++i) {
          	// 要保证 str 中小字符串的个数不能小于 pattern
            if (streams.eof())
                return false;
            streams >> s;
            auto iter = bijection.find(pattern[i]);
            if (iter == bijection.end()) { // 没有找到, 那就插入(当然还需要判断一下)
                if (strset.find(s) == strset.end()) {
                    bijection.insert(make_pair(pattern[i], s));
                    strset.insert(s);
                }
                else
                    return false;
            }
            else {
                if (s != iter->second)
                    return false;
            }
        }
		// 保证 str 中小字符串的个数等于 pattern 的大小.
        if (streams.eof())
            return true;
        return false;
    }
};

```



### 205. Isomorphic strings

https://leetcode.com/problems/isomorphic-strings/description/

给定字符串 s 和 t, 判断它们是不是 isomorphic 的.

Two strings are isomorphic if the characters in **s** can be replaced to get **t**.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

For example,
Given `"egg"`, `"add"`, return true.

Given `"foo"`, `"bar"`, return false.

Given `"paper"`, `"title"`, return true.

**Note:**
You may assume both **s** and **t** have the same length.

解法一: 我的想法和上一题 290. Word Pattern 相同. 不过这道题要考虑的情况稍微简单一些. 但注意仍然要设置 `unordered_set` 判断要插入的 `t[i]` 是否曾经出现过, 毕竟插入到 `bijection` 中的元素都是原来没有出现过的.

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.empty() && t.empty())
            return true;

        unordered_map<char, char> bijection;
        unordered_set<char> records;
        for (int i = 0; i < s.size(); ++i) {
            auto iter = bijection.find(s[i]);
            if (iter == bijection.end()) {
                if (records.find(t[i]) == records.end()) {
                    bijection.insert(make_pair(s[i], t[i]));
                    records.insert(t[i]);
                }
                else
                    return false;
            }
            else {
                if (t[i] != iter->second)
                    return false;
            }
        }
        return true;
    }
};
```



解法二: 更快一些, 每个字符可以用作下标, 保证对应字符的值都是 i, 如果对应字符的值不相等, 说明就不是 isomorphic 的了.

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int len = s.length();
        int m1[256], m2[256];
        for (int i = 0; i < 256; i++) {
            m1[i] = m2[i] = -1;
        }
        
        for (int i = 0; i < len; i++) {
            if (m1[s[i]] != m2[t[i]]) return false;
            m1[s[i]] = m2[t[i]] = i;
        }
        return true;
    }
};
```



### 451. Sort Characters By Frequency

https://leetcode.com/problems/sort-characters-by-frequency/description/

给定一个字符串, 将其中的字符按照出现次数递减的方式输出, 次数相同的不需要在意顺序. 另外是大小写敏感. 比如:

**Example 1:**

```bash
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

**Example 2:**

```bash
Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
```

**Example 3:**

```bash
Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
```



思路: 需要用到查找表, 记录每个字符出现的频次. 另外一个需要注意的点是: string 类提供的 [append](http://www.cplusplus.com/reference/string/string/append/) 方法, 它有多个重载, 其中 `str.append(n, c)` 可以将 n 个 c 连接到 str 的后面. 那从查找表中获得每个字符的频次之后, 为了给频次排序, 可以再引入一个 vector, 大小为 `s.size() + 1`, 这是因为, 如果 s 中字符都相同, 那么频次就是 `s.size()`, 那么可以放在 vector 中的索引为 `s.size()` 处. 最后反向遍历 vector, 就能获得题中的要求.

这题一开始写不出来... 参考了 [C++ O(n) solution without sort()](https://leetcode.com/problems/sort-characters-by-frequency/discuss/93404/C++-O(n)-solution-without-sort())

```cpp
class Solution {
public:
    string frequencySort(string s) {
        if (s.empty())
            return s;

        unordered_map<char, int> freq;
        for (const auto &c : s)
            freq[c] ++;

        vector<string> records(s.size() + 1, "");
        for (auto iter = freq.begin(); iter != freq.end(); ++iter) {
            char c = iter->first;
            int n = iter->second;
            records[n].append(n, c);
        }

        string res;
        for (int i = s.size(); i >= 0; --i) {
            if (!records[i].empty())
                res += records[i];
        }
        return res;
    }
};
```



### 347. Top K Frequent Elements

https://leetcode.com/problems/top-k-frequent-elements/description/

给定一个非空的整型数组, 返回前 k 个出现频率最高的元素. 比如:

For example,
Given `[1,1,1,2,2,3]` and k = 2, return `[1,2]`.

另外, 可以假设 `1 <= k <= nums.size()`, 另外算法的时间复杂度必须比 `O(nlogn)` 好.



思路: 实现肯定要统计每个元素在数组中出现的频次. 但复杂的地方在于如何根据频次排序, 从而找到前 k 个出现最频繁的. 可以参考上一题 451. Sort Characters By Frequency 中的做法, 使用一个大小为 `vector<string>(nums.size() + 1)` 大小的 vector 来保存元素, 而坐标表示索引. 可是, 与 451 题不同的是, 频次相同的字符串可以使用 append 累加起来, 而本题频次相同的整型数如何保存起来呢? 当然可以使用 `vector<vector<int>> count`. 之后只要从后向前遍历 count, 当然对于 `count[i]` 还要计算其大小, 使得不超过 k.

```cpp
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> res;
        if (nums.empty())
            return res;
        
        unordered_map<int, int> freq;
        for (const auto &n : nums)
            freq[n] ++;

        vector<vector<int>> count(nums.size() + 1, vector<int>());
        for (auto &iter : freq) {
            count[iter.second].push_back(iter.first);
        }

        int total = 0;
        for (int i = nums.size(); i >= 0; --i) {
            if (!count[i].empty()) {
                total += count[i].size();
                if (total <= k)
                    res.insert(res.end(), count[i].begin(), count[i].end());
                else { // 如果此时 total 超过了 k, 说明 count[i] 中的数据很多, 
                  // 只需要一部分, 这个数值就是 k - (total - count[i].size())
                  // 遍历完之后 res 中的数量就是 k 了, 此时必须 break
                    for (int j = 0; j < k - (total - count[i].size()); ++j) {
                        res.push_back(count[i][j]);
                    }
                    break;
                }
            }
        }
        return res;
    }
};

// 上面代码提交后发现速度有点慢, 我找了一个比我快的方法:
// 其实思路和我一样, 只是最后用了两层循环来做... 好吧, 其实我也
// 用了两层循环.
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int>mp;
        vector<int>res;
        vector<vector<int> >v(nums.size()+1);
        for(auto x:nums)   mp[x]++;
        for(auto it:mp){
            v[it.second].push_back(it.first);
        }
        int tm = 0;
        for(int i=v.size()-1;i>0;i--){
            for(int j=0;j<v[i].size();j++){
                res.push_back(v[i][j]);
                if(++tm==k) return res;
            }
        }
    }
};

// 下面是使用优先队列的方法,
// 想不到优先队列还可以处理 pair, 果然厉害, 其实我就是想这样搞的...
// 这样的代码才简洁.
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
         unordered_map<int, int> m;
        priority_queue<pair<int, int>> q;
        vector<int> res;
        for (auto a : nums) ++m[a];
        for (auto it : m) q.push({it.second, it.first});
        for (int i = 0; i < k; ++i) {
            res.push_back(q.top().second); q.pop();
        }
        return res;
    }
};
```



### 217. *Contains Duplicate

https://leetcode.com/problems/contains-duplicate/description/

判断整型数组中是否包含重复元素.

解法一: 使用查找表

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        if (nums.empty())
            return false;

        unordered_set<int> records;
        for (const auto &n : nums) {
            if (records.find(n) != records.end())
                return true;
            else
                records.insert(n);
        }
        return false;
    }
};
```

解法二: 先排序, 后判断.

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
      sort(nums.begin(), nums.end());
    for (int i=0; i<int(nums.size())-1; i++) {
        if (nums[i]==nums[i+1])
            return true;
    }
    return false;
    }
};
```





### 219. *Contains Duplicate II

https://leetcode.com/problems/contains-duplicate-ii/description/

给定整型数组和整数 k, 找出数组中是否存在两个索引 i 和 j, 使得 `nums[i] == nums[j]` 并且 i 和 j 的绝对值之差不超过 k.(可以等于 k).



思路: 使用滑动窗口和查找表. 首先给出一个非常简单的思路, 然后再放出我的思路, 最后再给出一个简单的思路.

解法一: 使用滑动窗口和查找表, 需要注意这个滑动窗口的大小是固定的, 那么只要判断查找表的大小是不是 k + 1, 才向右移动窗口(为何是 k + 1 呢? 比如 l = 0, r = k, 符合条件, 但此时 nums[l...r] 中有 k + 1 个元素.), 这里所谓向右移动窗口, 就是要将查找表中最左侧的值给删除. **注意这里最左侧的值为 nums[i - k].**

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_set<int> record;
        
        for (int i = 0; i < nums.size(); ++i) {
            if (record.find(nums[i]) != record.end())
                return true;
            
            record.insert(nums[i]);
            
            if (record.size() == (k + 1))
                record.erase(nums[i - k]); // 将窗口最左侧的值给删去
        }
        return false;
    }
};
```

下面介绍我的想法, 更为暴力麻烦 : ). 也是使用滑动窗口和查找表, 设置 `nums[l...r)` 为滑动窗口, 对于将要访问的 `nums[r]`, 如果在查找表中找到了它并且它和 l 的索引小于或等于 k, 那么就返回 true. 否则就将该元素插入到表中, 并删除最左边的元素; 如果没有找到, 那么不断插入即可, 当插入到 r 和 l 的距离大于 k 时, 便将最左边元素删除. 我的思路就是太麻烦, 没上面解法简洁.

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        if (nums.empty())
            return false;

        // 使用滑动窗口和查找表
        // nums[l....r) 为滑动窗口
        int l = 0, r = 1;
        unordered_set<int> records;
        records.insert(nums[0]);
        while (r < nums.size()) {
            if (records.find(nums[r]) != records.end()) {
                if (r - l <= k)
                    return true;
                else {
                    records.insert(nums[r++]);
                    records.erase(nums[l++]);
                }
            }
            else {
                records.insert(nums[r++]);
                if (r - l > k) {
                    records.erase(nums[l++]);
                }
            }
        }
        return false;
    }
};
```

最后是 leetcode 上某个解答: 使用 map 来存储索引.

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) 
    {
        unordered_map<int, int> m;
        for(int i = 0; i < nums.size(); ++i)
        {
            if(m.find(nums[i]) != m.end() &&  i - m[nums[i]] <= k) return true;
            else m[nums[i]] = i;
        }
        return false;
    }
};
```



### 3. Longest Substring Without Repeating Characters

https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

给定一个字符串, 找出其中最长的不包含重复字符的子串. 注意 substring 和 subsequence 的区别. substring 需要是连续的.



思路: 使用滑动窗口和查找表. 查找表保存滑动窗口中的字符, 当访问一个新的字符, 判断它是否在查找表中, 如果在的话, 那么就移动窗口的左边界, 这个时候, 窗口的宽度是在不断缩小的; 如果不在查找表中, 那么就将该元素插入到查找表中.

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.empty())
            return 0;

        // s[l...r) 是滑动窗口
        int l = 0, r = 0;
        int res = 0;
        unordered_set<int> record;
        while (r < s.size()) {
            if (record.find(s[r]) != record.end())
                record.erase(s[l++]);
            else
                record.insert(s[r++]);
            res = max(res, r - l);
        }

        return res;
    }
};
```

再给一个 leetcode 上比我的快一些的方法:

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int maxlen = 0, left = 1;
        int sz = s.length();
        int prev[256] = { 0 };

        for (int i = 1; i <= sz; i++) {
            if (prev[s[i-1]] >= left) {
                left = prev[s[i-1]] + 1;
            }
            prev[s[i-1]] = i;
            maxlen = max(maxlen, i - left + 1);
        }
        return maxlen;
    }
};
```



### 763. Partition Labels

https://leetcode.com/problems/partition-labels/description/

给定一个由小写字符组成的字符串, 我们希望尽可能将字符串分成多块, 使得每个字符最多出现在一个块中, 然后返回这些字符块的大小. 比如:

**Example 1:**

```bash
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
```

**Note:**

1. `S` will have length in range `[1, 500]`.
2. `S` will consist of lowercase letters (`'a'` to `'z'`) only.

思路: 首先要分析如何进行分块. 仔细观察可以发现, 就拿 `S = "ababcbacadefegdehijhklij"` 来说, 当访问 `S[0] = 'a'` 时, 要找到一种分法, 使得 a 只出现在一个字符块中, 那么我们要到 S 中找到最右边的 a, 即 `S[8]`, 那么 a 只出现在字符块 `ababcbaca` 中, 不会出现在 `S[9,....]` 中. 但注意, 这只是其中一个需要满足的条件, 另一个条件是, 还需要判断 `ababcbaca` 中除了第一个 a 以外, 剩余的字符最远的索引是多少, 比如目前由于 `S[1...8]` 中, 每一个字符, 比如 b 和 c, 它们最远的索引都小于 8, 那么说明它们一定会出现在 `S[0,...8]` 中.

根据以上的分析, 我们发现可以这样做: 首先当访问到 `S[start]` 时, 判断 `S[start]` 最远的索引是 end, 那么 `S[start,..., end]` 就是我们要考察的字符块, 这是初始的状态. 然后一次判断 `S[start+1...end - 1]` 中的元素, 看看它们的最远的索引是什么, 如果所有这些元素的最远索引都小于 end, 那么 `S[start,..., end]` 就是我们需要的; 但若存在某个索引(newend)大于当前的 end, 那么就需要将字符块的区间扩大, 即令 `end = newend`, 然后再判断 `S[++start,...newend]` 中的元素的最大索引是不是大于 newend. 不断重复这个过程.

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
      	// cmap 保存字符, 以及该字符的索引,
      	// 注意, 由于是从左向右遍历, 所以 vector<int> 中的值是从小到大的, 
      	// 那么使用 .back() 就可以获得最远的索引. 使用 front() 计算开始的
      	// 索引用于计算长度.
        unordered_map<char, vector<int>> cmap;
        for (int i = 0; i < S.size(); ++i) {
            auto iter = cmap.find(S[i]);
            if (iter != cmap.end())
                iter->second.push_back(i);
            else
                cmap.insert(make_pair(S[i], vector<int>{i}));
        }

        int start = 0;
        vector<int> res;
        while (start != S.size()) {
          	// 考虑区间 S[start,..., end]
            auto iter = cmap.find(S[start]);
            int end = iter->second.back();
          	// 判断 S[start+1,...end - 1] 返回内
          	// 元素的最远索引, 并和 end 比较.
            while (start < end) {
                auto next = cmap.find(S[++start]);
                int newend = next->second.back();
                if (newend > end)
                    end = newend;
            }
            int len = end - iter->second.front() + 1;
            res.push_back(len);
            ++start;
        }

        return res;
    }
};
```

leetcode 上对于 end 的处理还可以像下面这样:

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<pair<int, int> > info(26, make_pair(-1, -1));
        vector<int> res;
        string seq = "";
        int size = S.size();
        for (int i = 0; i < size; i++) {
            if (info[S[i] - 'a'].first == -1) {
                info[S[i] - 'a'].first = info[S[i] - 'a'].second = i;
                seq += S[i];
            } else {
                info[S[i] - 'a'].second = i;
            }
        }
        int begin = info[seq[0] - 'a'].first;
        int end = info[seq[0] - 'a'].second;
        for (int i = 1; i < seq.size(); i++) {
            int left = info[seq[i] - 'a'].first;
            int right = info[seq[i] - 'a'].second;
            if (left < end) {
                end = end > right? end : right;
            } else {
                res.push_back(end - begin + 1);
                begin = left;
                end = right;
            }
        }
        res.push_back(end - begin + 1);
        return res;
    }
};
```

根据上面的代码对我开始写的程序进行适当的修改如下, 但不知为何, 速度反而慢了:

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        if (S.empty())
            return vector<int>();
        unordered_map<char, vector<int>> cmap;
        for (int i = 0; i < S.size(); ++i) {
            auto iter = cmap.find(S[i]);
            if (iter != cmap.end())
                iter->second.push_back(i);
            else
                cmap.insert(make_pair(S[i], vector<int>{i}));
        }

        vector<int> res;

        auto iter = cmap.find(S[0]);
        int begin = iter->second.front();
        int end = iter->second.back();
        for (int i = 1; i < S.size(); ++i) {
            auto it = cmap.find(S[i]);
            int left = it->second.front();
            int right = it->second.back();
            if (left < end) {
                end = end > right ? end : right;
            }
            else {
                int len = end - begin + 1;
                res.push_back(len);
                begin = left;
                end = right;
            }
        }
        int len = end - begin + 1;
        res.push_back(len);
        return res;
    }
};
```



### 532. *K-diff Pairs in an Array

https://leetcode.com/problems/k-diff-pairs-in-an-array/description/

给定整型数组 array 以及一个整数 k, 需要找到数组中唯一的 k-diff pairs 有多少个. k-diff pairs 定义为对于数组中的任意两个数 `(i, j)`, 它们的差的绝对值为 k.

**Example 1:**

```bash
Input: [3, 1, 4, 1, 5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of unique pairs.
```

**Example 2:**

```bash
Input:[1, 2, 3, 4, 5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
```

**Example 3:**

```bash
Input: [1, 3, 1, 5, 4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).
```

**Note:**

1. The pairs (i, j) and (j, i) count as the same pair.
2. The length of the array won't exceed 10,000.
3. All the integers in the given input belong to the range: [-1e7, 1e7].

思路: 其实这道题并不复杂, 但是需要注意一下陷阱: 首先当 k 是 0 的时候, 对于数组 `{1, 3, 5}` 来说, k-diff pairs 的个数实际上是 0; 但是对于 `{1, 3, 5, 1}` 来说, 个数是 1. 这提示我们需要使用 map 来统计数组中每个元素的个数, 当 k = 0 时, 只有个数超过 1 的元素, 才会对 k-diff pairs 的个数做出贡献. 另外还需要注意, 当 k < 0 时, 结果总是返回 0 的, 因为题目中要求 k >= 0.

```cpp
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        unordered_map<int, int> record;
        for (auto &d : nums) {
            auto iter = record.find(d);
            if (iter != record.end())
                iter->second ++;
            else
                record.insert(make_pair(d, 1));
        }

        int count = 0;
        if (k == 0) {
            for (auto &elem : record) {
                if (elem.second > 1)
                    count ++;
            }
        }
        else if (k > 0) {
            for (auto &elem : record) {
                auto iter = record.find(elem.first + k);
                if (iter != record.end()) {
                    count ++;
                }
            }
        }
        return count;
    }

};
```

下面的代码和我逻辑上一样, 看起来稍微精简一些.

```cpp
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        if (nums.size() <= 1 || k < 0) {
            return 0;
        }
        
        unordered_map<int, int> mp;
        for (int num : nums) ++mp[num]; 
                
        int res = 0;
        for (auto m: mp) {
            if (k == 0 && m.second > 1) {
                ++res;
            }
            if (k > 0 && mp.count(m.first + k)) {
                ++res;
            }
        }
        return res;
    }
};
```



