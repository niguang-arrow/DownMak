# Map

## 查找表

### 349. *Intersection of Two Arrays

https://leetcode.com/problems/intersection-of-two-arrays/description/

求两个数组的交集, 注意结果中的每个元素都是唯一的, 并且不用考虑元素的顺序.

比如给定: *nums1* = `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, return `[2]`.

思路: 使用 set, 将两个数组中的元素拷贝进 set 中, 那么 set1 和 set2 中的元素都是唯一的, 从而求两个 set 的交集.

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        set<int> isection1(nums1.begin(), nums1.end());
        set<int> isection2(nums2.begin(), nums2.end());

        vector<int> res;
        for (const auto &d : isection1) {
            if (isection2.find(d) != isection2.end())
                res.push_back(d);
        }
        return res;
    }
};

// 第二种方法只用一个 set, 但是每次在 set 中查找完 nums2 中的元素后,
// 应将 set 中的对应元素删除.
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> isection(nums1.begin(), nums1.end());

        vector<int> res;
        for (const auto &d : nums2) {
            if (isection.find(d) != isection.end()) {
                res.push_back(d);
                isection.erase(d);
            }
        }

        return res;
    }
};
```



### 350. *Intersection of Two Arrays II

https://leetcode.com/problems/intersection-of-two-arrays-ii/description/

求两个数组的交集, 但是要尽可能保留重合的元素, 不考虑结果中元素的顺序.

**Example:**
Given *nums1* = `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, return `[2, 2]`.

思路: 这个时候就需要使用 map 而不是 set 了, 使用 map 来统计每个元素的个数. 当然还有方法就是先对数组进行排序, 然后再依次比较两个数组中当前访问元素的大小是否相等.

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
      	// 统计 nums1 中的每个元素的个数
        unordered_map<int, int> freq;
        for (const auto &d : nums1)
            freq[d] ++;

        vector<int> res;
      	// 对于 nums2 中的元素, 如果在 freq 中, 那么就要加入到 res 中,
      	// 但是由于这里没有用 erase 删除已经访问过的元素, 所以还加上了 
      	// freq[d] != 0 的判断
        for (const auto &d : nums2) {
            if (freq.find(d) != freq.end() && freq[d] != 0) {
                res.push_back(d);
                freq[d] --;
            }
        }
        return res;
    }
};


// 如果给两个数组排序, 那么可以使用如下方法求.
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res;
        std::sort(nums1.begin(), nums1.end());
        std::sort(nums2.begin(), nums2.end());
        int i = 0, j = 0;
        while (i < nums1.size() && j < nums2.size()) {
            if (nums1[i] == nums2[j]) {
                res.push_back(nums1[i]);
                i++;
                j++;
            } else if (nums1[i] < nums2[j]) {
                i++;
            } else {
                j++;
            }
        }
        return res;
    }
};
```



### 389. *Find the Difference

https://leetcode.com/problems/find-the-difference/description/

给定两个只含有小写字母的字符串 s 和 t, t 是由 s 中的字符随机 shuffle 得到的字符串, 然后再在任意位置插入一个新的字符, 现在要找到新加入到 t 中的字符. 比如:

```bash
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
```

注意 e 是可以插入到任意位置的.



思路: 统计两个字符串中字符的个数即可, 然后对应字符的个数相减, 最后只会有一个字符的个数为 1, 那这个字符就是新插入的字符.

```cpp
class Solution {
public:
    char findTheDifference(string s, string t) {

        unordered_map<char, int> record;
        for (int i = 0; i < s.size(); ++i) {
            record[t[i]] ++;
            record[s[i]] --;
        }
      	// 由于 t 比 s 大 1, 所以还要将 t 中剩下的元素插入.
        record[t[t.size() - 1]] ++;
        char res = '\0';
        for (auto &iter : record)
            if (iter.second != 0)
                res = iter.first;
        return res;
    }
};
```

或者下面这样也行:

```cpp
class Solution {
public:
    char findTheDifference(string s, string t) {

        unordered_map<char, int> record;
        for (auto &c : t)
            record[c] ++;
        for (auto &c : s)
            record[c] --;
        char res;
        for (auto &iter : record)
            if (iter.second != 0)
                res = iter.first;
        return res;
    }
};
```







### 202. *Happy Number

https://leetcode.com/problems/happy-number/description/

判断一个正整数是否为一个 Happy Number. Happy Number 的定义是: A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

比如: 19 是一个 Happy Number:

$1^2 + 9^2 = 82$

$8^2 + 2^2 = 68$

$6^2 + 8^2 = 100$

$1^2 + 0^2 + 0^2 = 1$

思路: 根据 Happy Number 的定义可以知道, 按照这个计算步骤处理某个数, 最后要么得到 1, 要么会无限循环, 无限循环造成的原因是, 比如第一次运算结果为 a1, 第二次运算结果为 a2,... an, 那么此时可以得到一个数组 `[a1, a2, ..., an]`, 那么当第 n + 1 次运算的结果等于这个数组中的某一个的时候, 就会出现无限循环的结果. 为了处理这种情况, 我下面使用了一个 `unordered_set` 来保存每一次运算的结果, 当算出新的结果时, 要判断新结果是否出现在历史结果中, 如果出现了, 说明会出现无限循环的情况, 函数就要返回.

```cpp
class Solution {
private:
  	// Sum 用于求平方和.
    int Sum(int n) {
        int sum = 0;
        while(n)
        {
            int a = n % 10;
            n /= 10;
            sum += a * a;
        }
        return sum;
    }
	// 判断是否会发生无限递归的情况, 如果会发生, 那么返回 true.
  	// 如果某次结果为 1, 那么说明不会发生无限递归的情况, 返回 false.
  	// 否则, 每次将结果计算出来之后, 要到 origin 中查找是否出现在历史结果中,
  	// 如果没有出现并且结果不是 1, 那么就将其加入到 origin 之中. 然后判断
  	// 新结果 sum 是否会造成无限递归或者等于 1.
    bool isRecursive(int n, unordered_set<int> &origin) {
        int sum = Sum(n);
        //cout << sum << endl;

        if (sum == 1)
            return false;
        if (origin.find(sum) != origin.end())
            return true;

        origin.insert(sum);
        return isRecursive(sum, origin);
    }
public:
    bool isHappy(int n) {
        if (n <= 0)
            return false;
        unordered_set<int> origin;
        return !isRecursive(n, origin);
    }
};
```



### 290. *Word Pattern

https://leetcode.com/problems/word-pattern/description/

给定一个 pattern 和一个字符串 str, 判断 str 是否符合 pattern. 假设 pattern 中只有小写字母, str 只包含由空格分隔的小写字母. 比如:

**Examples:**

1. pattern = `"abba"`, str = `"dog cat cat dog"` should return true.
2. pattern = `"abba"`, str = `"dog cat cat fish"` should return false.
3. pattern = `"aaaa"`, str = `"dog cat cat dog"` should return false.
4. pattern = `"abba"`, str = `"dog dog dog dog"` should return false.

思路: 由于 str 是由空格分隔的字符串, 那么可以使用 `<sstream>` 中的 `stringstream` 进行处理. 另外关于字符串分割技术可以参看 [字符串分割技术](https://segmentfault.com/a/1190000002483483). 之后具体的逻辑是: 需要一张查找表 `unordered_map<char, string>` 用于记录 pattern 中每个字符和 str 中每个小字符串之间的联系, 它们之间是一一对应的, 如果遍历到 `(pattern[i], str[i])` (注意 `str[i]` 不是表示一个字符, 而是空格分开的小字符串), 判断 `pattern[i]` 是否在查找表中, 如果没有的话, 那么就可以将这个 pair 插入进去. 但插入的时候还要考虑这样一种情况: `pattern = "abba", str = "dog dog dog dog"`, 当访问到 `(b, dog)` 时, 由于查找表中当前有 `(a, dog)`, 虽然 b 和 a 不相等, 但是不能将 `(b, dog)` 插入到查找表中, 为了处理这种情况, 引入 `unordered_set<string>` 来存放已经访问过的小字符串, 只有 dog 不在这个 set 中, 那么才可以将 b 插入到查找表中.

如果 `pattern[i]` 在查找表中, 那么就需要判断 `str[i]` 是否和原来的相等.

最后, 我在代码中使用 `streams.eof()` 才返回 true, 是要保证 pattern 的大小和 str 中小字符串的个数相等.

注: 这是我写的第一道速度能 beats 100% 的提交的习题.

```cpp
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        if (pattern.empty() || str.empty())
            return false;
        
        // bijection 是映射的意思, 用于存放 pattern 和 str 的关系
      	// strset 用于记录已经处理过的 string 了.
        unordered_map<char, string> bijection;
        unordered_set<string> strset;
        string s;
        stringstream streams(str);
        for (int i = 0; i < pattern.size(); ++i) {
          	// 要保证 str 中小字符串的个数不能小于 pattern
            if (streams.eof())
                return false;
            streams >> s;
            auto iter = bijection.find(pattern[i]);
            if (iter == bijection.end()) { // 没有找到, 那就插入(当然还需要判断一下)
                if (strset.find(s) == strset.end()) {
                    bijection.insert(make_pair(pattern[i], s));
                    strset.insert(s);
                }
                else
                    return false;
            }
            else {
                if (s != iter->second)
                    return false;
            }
        }
		// 保证 str 中小字符串的个数等于 pattern 的大小.
        if (streams.eof())
            return true;
        return false;
    }
};

```



### 205. *Isomorphic strings

https://leetcode.com/problems/isomorphic-strings/description/

给定字符串 s 和 t, 判断它们是不是 isomorphic 的.

Two strings are isomorphic if the characters in **s** can be replaced to get **t**.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

For example,
Given `"egg"`, `"add"`, return true.

Given `"foo"`, `"bar"`, return false.

Given `"paper"`, `"title"`, return true.

**Note:**
You may assume both **s** and **t** have the same length.

解法一: 我的想法和上一题 290. Word Pattern 相同. 不过这道题要考虑的情况稍微简单一些. 但注意仍然要设置 `unordered_set` 判断要插入的 `t[i]` 是否曾经出现过, 毕竟插入到 `bijection` 中的元素都是原来没有出现过的.

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.empty() && t.empty())
            return true;

        unordered_map<char, char> bijection;
        unordered_set<char> records;
        for (int i = 0; i < s.size(); ++i) {
            auto iter = bijection.find(s[i]);
            if (iter == bijection.end()) {
                if (records.find(t[i]) == records.end()) {
                    bijection.insert(make_pair(s[i], t[i]));
                    records.insert(t[i]);
                }
                else
                    return false;
            }
            else {
                if (t[i] != iter->second)
                    return false;
            }
        }
        return true;
    }
};
```



解法二: 更快一些, 每个字符可以用作下标, 保证对应字符的值都是 i, 如果对应字符的值不相等, 说明就不是 isomorphic 的了.

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int len = s.length();
        int m1[256], m2[256];
        for (int i = 0; i < 256; i++) {
            m1[i] = m2[i] = -1;
        }
        
        for (int i = 0; i < len; i++) {
            if (m1[s[i]] != m2[t[i]]) return false;
            m1[s[i]] = m2[t[i]] = i;
        }
        return true;
    }
};
```



### 451. Sort Characters By Frequency

https://leetcode.com/problems/sort-characters-by-frequency/description/

给定一个字符串, 将其中的字符按照出现次数递减的方式输出, 次数相同的不需要在意顺序. 另外是大小写敏感. 比如:

**Example 1:**

```bash
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

**Example 2:**

```bash
Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
```

**Example 3:**

```bash
Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
```



思路: 需要用到查找表, 记录每个字符出现的频次. 另外一个需要注意的点是: string 类提供的 [append](http://www.cplusplus.com/reference/string/string/append/) 方法, 它有多个重载, 其中 `str.append(n, c)` 可以将 n 个 c 连接到 str 的后面. 那从查找表中获得每个字符的频次之后, 为了给频次排序, 可以再引入一个 vector, 大小为 `s.size() + 1`, 这是因为, 如果 s 中字符都相同, 那么频次就是 `s.size()`, 那么可以放在 vector 中的索引为 `s.size()` 处. 最后反向遍历 vector, 就能获得题中的要求.

这题一开始写不出来... 参考了 [C++ O(n) solution without sort()](https://leetcode.com/problems/sort-characters-by-frequency/discuss/93404/C++-O(n)-solution-without-sort())

```cpp
class Solution {
public:
    string frequencySort(string s) {
        if (s.empty())
            return s;

        unordered_map<char, int> freq;
        for (const auto &c : s)
            freq[c] ++;

        vector<string> records(s.size() + 1, "");
        for (auto iter = freq.begin(); iter != freq.end(); ++iter) {
            char c = iter->first;
            int n = iter->second;
            records[n].append(n, c);
        }

        string res;
        for (int i = s.size(); i >= 0; --i) {
            if (!records[i].empty())
                res += records[i];
        }
        return res;
    }
};
```



### 347. Top K Frequent Elements

https://leetcode.com/problems/top-k-frequent-elements/description/

给定一个非空的整型数组, 返回前 k 个出现频率最高的元素. 比如:

For example,
Given `[1,1,1,2,2,3]` and k = 2, return `[1,2]`.

另外, 可以假设 `1 <= k <= nums.size()`, 另外算法的时间复杂度必须比 `O(nlogn)` 好.



思路: 实现肯定要统计每个元素在数组中出现的频次. 但复杂的地方在于如何根据频次排序, 从而找到前 k 个出现最频繁的. 可以参考上一题 451. Sort Characters By Frequency 中的做法, 使用一个大小为 `vector<string>(nums.size() + 1)` 大小的 vector 来保存元素, 而坐标表示索引. 可是, 与 451 题不同的是, 频次相同的字符串可以使用 append 累加起来, 而本题频次相同的整型数如何保存起来呢? 当然可以使用 `vector<vector<int>> count`. 之后只要从后向前遍历 count, 当然对于 `count[i]` 还要计算其大小, 使得不超过 k.

```cpp
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> res;
        if (nums.empty())
            return res;
        
        unordered_map<int, int> freq;
        for (const auto &n : nums)
            freq[n] ++;

        vector<vector<int>> count(nums.size() + 1, vector<int>());
        for (auto &iter : freq) {
            count[iter.second].push_back(iter.first);
        }

        int total = 0;
        for (int i = nums.size(); i >= 0; --i) {
            if (!count[i].empty()) {
                total += count[i].size();
                if (total <= k)
                    res.insert(res.end(), count[i].begin(), count[i].end());
                else { // 如果此时 total 超过了 k, 说明 count[i] 中的数据很多, 
                  // 只需要一部分, 这个数值就是 k - (total - count[i].size())
                  // 遍历完之后 res 中的数量就是 k 了, 此时必须 break
                    for (int j = 0; j < k - (total - count[i].size()); ++j) {
                        res.push_back(count[i][j]);
                    }
                    break;
                }
            }
        }
        return res;
    }
};

// 上面代码提交后发现速度有点慢, 我找了一个比我快的方法:
// 其实思路和我一样, 只是最后用了两层循环来做... 好吧, 其实我也
// 用了两层循环.
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int>mp;
        vector<int>res;
        vector<vector<int> >v(nums.size()+1);
        for(auto x:nums)   mp[x]++;
        for(auto it:mp){
            v[it.second].push_back(it.first);
        }
        int tm = 0;
        for(int i=v.size()-1;i>0;i--){
            for(int j=0;j<v[i].size();j++){
                res.push_back(v[i][j]);
                if(++tm==k) return res;
            }
        }
    }
};

// 下面是使用优先队列的方法,
// 想不到优先队列还可以处理 pair, 果然厉害, 其实我就是想这样搞的...
// 这样的代码才简洁.
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
         unordered_map<int, int> m;
        priority_queue<pair<int, int>> q;
        vector<int> res;
        for (auto a : nums) ++m[a];
        for (auto it : m) q.push({it.second, it.first});
        for (int i = 0; i < k; ++i) {
            res.push_back(q.top().second); q.pop();
        }
        return res;
    }
};
```



### 217. *Contains Duplicate

https://leetcode.com/problems/contains-duplicate/description/

判断整型数组中是否包含重复元素.

解法一: 使用查找表

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        if (nums.empty())
            return false;

        unordered_set<int> records;
        for (const auto &n : nums) {
            if (records.find(n) != records.end())
                return true;
            else
                records.insert(n);
        }
        return false;
    }
};
```

解法二: 先排序, 后判断.

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
      sort(nums.begin(), nums.end());
    for (int i=0; i<int(nums.size())-1; i++) {
        if (nums[i]==nums[i+1])
            return true;
    }
    return false;
    }
};
```





### 219. *Contains Duplicate II

https://leetcode.com/problems/contains-duplicate-ii/description/

给定整型数组和整数 k, 找出数组中是否存在两个索引 i 和 j, 使得 `nums[i] == nums[j]` 并且 i 和 j 的绝对值之差不超过 k.(可以等于 k).



思路: 使用滑动窗口和查找表. 首先给出一个非常简单的思路, 然后再放出我的思路, 最后再给出一个简单的思路.

解法一: 使用滑动窗口和查找表, 需要注意这个滑动窗口的大小是固定的, 那么只要判断查找表的大小是不是 k + 1, 才向右移动窗口(为何是 k + 1 呢? 比如 l = 0, r = k, 符合条件, 但此时 nums[l...r] 中有 k + 1 个元素.), 这里所谓向右移动窗口, 就是要将查找表中最左侧的值给删除. **注意这里最左侧的值为 nums[i - k].**

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_set<int> record;
        
        for (int i = 0; i < nums.size(); ++i) {
            if (record.find(nums[i]) != record.end())
                return true;
            
            record.insert(nums[i]);
            
            if (record.size() == (k + 1))
                record.erase(nums[i - k]); // 将窗口最左侧的值给删去
        }
        return false;
    }
};
```

下面介绍我的想法, 更为暴力麻烦 : ). 也是使用滑动窗口和查找表, 设置 `nums[l...r)` 为滑动窗口, 对于将要访问的 `nums[r]`, 如果在查找表中找到了它并且它和 l 的索引小于或等于 k, 那么就返回 true. 否则就将该元素插入到表中, 并删除最左边的元素; 如果没有找到, 那么不断插入即可, 当插入到 r 和 l 的距离大于 k 时, 便将最左边元素删除. 我的思路就是太麻烦, 没上面解法简洁.

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        if (nums.empty())
            return false;

        // 使用滑动窗口和查找表
        // nums[l....r) 为滑动窗口
        int l = 0, r = 1;
        unordered_set<int> records;
        records.insert(nums[0]);
        while (r < nums.size()) {
            if (records.find(nums[r]) != records.end()) {
                if (r - l <= k)
                    return true;
                else {
                    records.insert(nums[r++]);
                    records.erase(nums[l++]);
                }
            }
            else {
                records.insert(nums[r++]);
                if (r - l > k) {
                    records.erase(nums[l++]);
                }
            }
        }
        return false;
    }
};
```

最后是 leetcode 上某个解答: 使用 map 来存储索引.

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) 
    {
        unordered_map<int, int> m;
        for(int i = 0; i < nums.size(); ++i)
        {
            if(m.find(nums[i]) != m.end() &&  i - m[nums[i]] <= k) return true;
            else m[nums[i]] = i;
        }
        return false;
    }
};
```



### 3. Longest Substring Without Repeating Characters

https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

给定一个字符串, 找出其中最长的不包含重复字符的子串. 注意 substring 和 subsequence 的区别. substring 需要是连续的.



思路: 使用滑动窗口和查找表. 查找表保存滑动窗口中的字符, 当访问一个新的字符, 判断它是否在查找表中, 如果在的话, 那么就移动窗口的左边界, 这个时候, 窗口的宽度是在不断缩小的; 如果不在查找表中, 那么就将该元素插入到查找表中.

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.empty())
            return 0;

        // s[l...r) 是滑动窗口
        int l = 0, r = 0;
        int res = 0;
        unordered_set<int> record;
        while (r < s.size()) {
            if (record.find(s[r]) != record.end())
                record.erase(s[l++]);
            else
                record.insert(s[r++]);
            res = max(res, r - l);
        }

        return res;
    }
};
```

再给一个 leetcode 上比我的快一些的方法:

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int maxlen = 0, left = 1;
        int sz = s.length();
        int prev[256] = { 0 };

        for (int i = 1; i <= sz; i++) {
            if (prev[s[i-1]] >= left) {
                left = prev[s[i-1]] + 1;
            }
            prev[s[i-1]] = i;
            maxlen = max(maxlen, i - left + 1);
        }
        return maxlen;
    }
};
```



### 763. Partition Labels

https://leetcode.com/problems/partition-labels/description/

给定一个由小写字符组成的字符串, 我们希望尽可能将字符串分成多块, 使得每个字符最多出现在一个块中, 然后返回这些字符块的大小. 比如:

**Example 1:**

```bash
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
```

**Note:**

1. `S` will have length in range `[1, 500]`.
2. `S` will consist of lowercase letters (`'a'` to `'z'`) only.

思路: 首先要分析如何进行分块. 仔细观察可以发现, 就拿 `S = "ababcbacadefegdehijhklij"` 来说, 当访问 `S[0] = 'a'` 时, 要找到一种分法, 使得 a 只出现在一个字符块中, 那么我们要到 S 中找到最右边的 a, 即 `S[8]`, 那么 a 只出现在字符块 `ababcbaca` 中, 不会出现在 `S[9,....]` 中. 但注意, 这只是其中一个需要满足的条件, 另一个条件是, 还需要判断 `ababcbaca` 中除了第一个 a 以外, 剩余的字符最远的索引是多少, 比如目前由于 `S[1...8]` 中, 每一个字符, 比如 b 和 c, 它们最远的索引都小于 8, 那么说明它们一定会出现在 `S[0,...8]` 中.

根据以上的分析, 我们发现可以这样做: 首先当访问到 `S[start]` 时, 判断 `S[start]` 最远的索引是 end, 那么 `S[start,..., end]` 就是我们要考察的字符块, 这是初始的状态. 然后一次判断 `S[start+1...end - 1]` 中的元素, 看看它们的最远的索引是什么, 如果所有这些元素的最远索引都小于 end, 那么 `S[start,..., end]` 就是我们需要的; 但若存在某个索引(newend)大于当前的 end, 那么就需要将字符块的区间扩大, 即令 `end = newend`, 然后再判断 `S[++start,...newend]` 中的元素的最大索引是不是大于 newend. 不断重复这个过程.

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
      	// cmap 保存字符, 以及该字符的索引,
      	// 注意, 由于是从左向右遍历, 所以 vector<int> 中的值是从小到大的, 
      	// 那么使用 .back() 就可以获得最远的索引. 使用 front() 计算开始的
      	// 索引用于计算长度.
        unordered_map<char, vector<int>> cmap;
        for (int i = 0; i < S.size(); ++i) {
            auto iter = cmap.find(S[i]);
            if (iter != cmap.end())
                iter->second.push_back(i);
            else
                cmap.insert(make_pair(S[i], vector<int>{i}));
        }

        int start = 0;
        vector<int> res;
        while (start != S.size()) {
          	// 考虑区间 S[start,..., end]
            auto iter = cmap.find(S[start]);
            int end = iter->second.back();
          	// 判断 S[start+1,...end - 1] 返回内
          	// 元素的最远索引, 并和 end 比较.
            while (start < end) {
                auto next = cmap.find(S[++start]);
                int newend = next->second.back();
                if (newend > end)
                    end = newend;
            }
            int len = end - iter->second.front() + 1;
            res.push_back(len);
            ++start;
        }

        return res;
    }
};
```

leetcode 上对于 end 的处理还可以像下面这样:

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        vector<pair<int, int> > info(26, make_pair(-1, -1));
        vector<int> res;
        string seq = "";
        int size = S.size();
        for (int i = 0; i < size; i++) {
            if (info[S[i] - 'a'].first == -1) {
                info[S[i] - 'a'].first = info[S[i] - 'a'].second = i;
                seq += S[i];
            } else {
                info[S[i] - 'a'].second = i;
            }
        }
        int begin = info[seq[0] - 'a'].first;
        int end = info[seq[0] - 'a'].second;
        for (int i = 1; i < seq.size(); i++) {
            int left = info[seq[i] - 'a'].first;
            int right = info[seq[i] - 'a'].second;
            if (left < end) {
                end = end > right? end : right;
            } else {
                res.push_back(end - begin + 1);
                begin = left;
                end = right;
            }
        }
        res.push_back(end - begin + 1);
        return res;
    }
};
```

根据上面的代码对我开始写的程序进行适当的修改如下, 但不知为何, 速度反而慢了:

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        if (S.empty())
            return vector<int>();
        unordered_map<char, vector<int>> cmap;
        for (int i = 0; i < S.size(); ++i) {
            auto iter = cmap.find(S[i]);
            if (iter != cmap.end())
                iter->second.push_back(i);
            else
                cmap.insert(make_pair(S[i], vector<int>{i}));
        }

        vector<int> res;

        auto iter = cmap.find(S[0]);
        int begin = iter->second.front();
        int end = iter->second.back();
        for (int i = 1; i < S.size(); ++i) {
            auto it = cmap.find(S[i]);
            int left = it->second.front();
            int right = it->second.back();
            if (left < end) {
                end = end > right ? end : right;
            }
            else {
                int len = end - begin + 1;
                res.push_back(len);
                begin = left;
                end = right;
            }
        }
        int len = end - begin + 1;
        res.push_back(len);
        return res;
    }
};
```



### 532. *K-diff Pairs in an Array

https://leetcode.com/problems/k-diff-pairs-in-an-array/description/

给定整型数组 array 以及一个整数 k, 需要找到数组中唯一的 k-diff pairs 有多少个. k-diff pairs 定义为对于数组中的任意两个数 `(i, j)`, 它们的差的绝对值为 k.

**Example 1:**

```bash
Input: [3, 1, 4, 1, 5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of unique pairs.
```

**Example 2:**

```bash
Input:[1, 2, 3, 4, 5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
```

**Example 3:**

```bash
Input: [1, 3, 1, 5, 4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).
```

**Note:**

1. The pairs (i, j) and (j, i) count as the same pair.
2. The length of the array won't exceed 10,000.
3. All the integers in the given input belong to the range: [-1e7, 1e7].

思路: 其实这道题并不复杂, 但是需要注意一下陷阱: 首先当 k 是 0 的时候, 对于数组 `{1, 3, 5}` 来说, k-diff pairs 的个数实际上是 0; 但是对于 `{1, 3, 5, 1}` 来说, 个数是 1. 这提示我们需要使用 map 来统计数组中每个元素的个数, 当 k = 0 时, 只有个数超过 1 的元素, 才会对 k-diff pairs 的个数做出贡献. 另外还需要注意, 当 k < 0 时, 结果总是返回 0 的, 因为题目中要求 k >= 0.

```cpp
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        unordered_map<int, int> record;
        for (auto &d : nums) {
            auto iter = record.find(d);
            if (iter != record.end())
                iter->second ++;
            else
                record.insert(make_pair(d, 1));
        }

        int count = 0;
        if (k == 0) {
            for (auto &elem : record) {
                if (elem.second > 1)
                    count ++;
            }
        }
        else if (k > 0) {
            for (auto &elem : record) {
                auto iter = record.find(elem.first + k);
                if (iter != record.end()) {
                    count ++;
                }
            }
        }
        return count;
    }

};
```

下面的代码和我逻辑上一样, 看起来稍微精简一些.

```cpp
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        if (nums.size() <= 1 || k < 0) {
            return 0;
        }
        
        unordered_map<int, int> mp;
        for (int num : nums) ++mp[num]; 
                
        int res = 0;
        for (auto m: mp) {
            if (k == 0 && m.second > 1) {
                ++res;
            }
            if (k > 0 && mp.count(m.first + k)) {
                ++res;
            }
        }
        return res;
    }
};
```



### 599. *Minimum Index Sum of Two Lists

https://leetcode.com/problems/minimum-index-sum-of-two-lists/description/

Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.

You need to help them find out their **common interest** with the **least list index sum**. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.

**Example 1:**

```bash
Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
Output: ["Shogun"]
Explanation: The only restaurant they both like is "Shogun".
```

**Example 2:**

```bash
Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["KFC", "Shogun", "Burger King"]
Output: ["Shogun"]
Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).
```

**Note:**

1. The length of both lists will be in the range of [1, 1000].
2. The length of strings in both lists will be in the range of [1, 30].
3. The index is starting from 0 to the list length minus 1.
4. No duplicates in both lists.



思路: 要找到两个集合的交集, 并且交集中每个元素在两个集合中的索引之和是最小的. 首先, 可以将 list1 中的每个元素放入到 `unordered_map<string, int>` record 中, int 表示索引. 再来考虑 list2 中的元素, 如果 record 中的第二个参数保存的是索引之和的话, 那么何如怎样体现两个 list 中存在相同的元素呢? 因此可以想到使用负数, 如果 list2 中存在和 list1 中相同的元素, 那么它们的索引之和就修改为负数, 那么之后访问 record 时, 只要找出其中的负数即可. 但是由于索引从 0 开始, 如果两个 list 中的第一个元素相等, 那么求负仍为 0, 因此, 保存在 record 中的索引从 1 开始计数.

```cpp
class Solution {
public:
    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
        unordered_map<string, int> record;
        for (int i = 0; i < list1.size(); ++i)
            record[list1[i]] = i + 1;
		
      	// 将相同元素的索引之和改为负数.
        for (int i = 0; i < list2.size(); ++i) {
            if (record.count(list2[i])) {
                record[list2[i]] = -record[list2[i]];
                record[list2[i]] += -(i + 1);
            }
        }
		
      	// 为了找到最小的索引和, 改成负数之后就是找最大的索引了.
        vector<string> res;
        int imax = INT32_MIN;
        for (auto &iter : record) {
            if (iter.second < 0) {
                if (iter.second == imax)
                    res.push_back(iter.first);
                else if (iter.second > imax) {
                    imax = iter.second; // 注意这里要更新 imax 最大值.
                    res = vector<string>{iter.first};
                }
            }
        }
        return res;
    }
};
```

leetcode 上另一种解答:

```cpp
class Solution {
public:
    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
        vector<string> res;
        unordered_map<string, int> map;
        
      	// sum 初始化为一个较大的值, 可以是 INT32_MAX
        int sum = list1.size() + list2.size();        
        for(int i = 0; i< list1.size();++i)
        {
            map[list1[i]] = i;
        }
        
        for(int i = 0; i < list2.size();i++)
        {
            auto iter = map.find(list2[i]);            
            if(iter != map.end()) // 找相同元素
            {	
              	// 如果存在索引和较小的元素, 那么清除原来的 res, 并求新的和
                if(iter->second + i < sum)
                {
                    res.clear();
                    sum = iter->second+i;                  
                }
              	// 之后还要执行这个 if 语句.
                if(iter->second + i == sum) res.push_back(iter->first);
            }
        }
        return res;
    }
};
```



### 409. *Longest Palindrome

https://leetcode.com/problems/longest-palindrome/description/

给定一个由大小写字母组成的字符串, 问用这个字符串能组成的最长的回文字符串的长度是多少? 注意大小写敏感, 比如 "aA" 就不是回文串.

**Note:**
Assume the length of given string will not exceed 1,010.

**Example:**

```bash
Input:
"abccccdd"

Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
```



思路: 统计每个字符的个数, 只要个数超过 2, 那么就能用 `2 * (n / 2)` 个字符组成回文字符串. 但是要注意, 如果最后得到的长度为 len, 并且小于给定字符串的长度, 那么就需要 `len + 1`, 因为这个时候可以在最中间插入一个字符, 比如 `aaabaaa`.

```cpp
class Solution {
public:
    int longestPalindrome(string s) {
        unordered_map<char, int> record;
        for (auto &c : s)
            record[c] ++;

        int len = 0;
        for (auto &iter : record) {
            if (iter.second >= 2)
                len += 2 * (iter.second / 2);
        }
        // len % 2 == 0 是多余的. 因为上面的结果就是偶数.
      	// 只要判断 len 是否小于 s.size() 即可.
        if (len < s.size()) // && (len % 2 == 0))
            len += 1;
        return len;
    }
};
```



### 575. *Distribute Candies

https://leetcode.com/problems/distribute-candies/description/

给定长度为偶数的数组, 其中每个不同数字表示不同类型的糖, 每一个数字都表示一种类型的糖. 现在要将这些糖平均分发给男孩和女孩, 问女孩最多能得到多少种类型的糖? 比如:

**Example 1:**

```bash
Input: candies = [1,1,2,2,3,3]
Output: 3
Explanation:
There are three different kinds of candies (1, 2 and 3), and two candies for each kind.
Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. 
The sister has three different kinds of candies. 
```

**Example 2:**

```bash
Input: candies = [1,1,2,3]
Output: 2
Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. 
The sister has two different kinds of candies, the brother has only one kind of candies. 
```

**Note:**

1. The length of the given array is in range [2, 10,000], and will be even.
2. The number in given array is in range [-100,000, 100,000].



思路: 这道题其实非常容易, 不要被题目描述给骗了. 首先, 要统计出这个数组中到底有多少种类型的糖, 也就是说, 要求出不同的数字有多少个, 这可以使用 `unordered_set` 做到. 然后, 由于糖是平均分的, 假设数组的长度为 size, 那么女孩分到的糖为 size / 2 个, 如果糖的种类 k 小于或等于 size/2, 那么就可以从每种类型的糖中各取一颗, 这样, 女孩可以得到所有类型的糖. 而另一方面, 如果 k 大于 size/2, 说明糖的种类非常多, 那么女孩最多得到 size/2 种类型的糖.

先给出我粗糙的做法, 然后给出 leetcode 上一个简洁的两行代码:

这里用 `unordered_map` 统计每种糖的数量, 其实没有必要, 可以直接使用 `unordered_set`. 但是, 它们的大小都是糖的种类 k.

```cpp
class Solution {
public:
    int distributeCandies(vector<int>& candies) {
        unordered_map<int, int> record;
        int size = candies.size();
        for (auto &d : candies)
            record[d] ++;
        // record.size() 表示种类的数量, 如果种类比较少, 那么每样取一颗总是可以的,
        // 这样就可以得到所有的种类
        if (record.size() <= size / 2)
            return record.size();
        // 但要是种类比较多, 那么应该
        return size / 2;
    }
};
```

leetcode 上简洁的做法:

```cpp
class Solution {
public:
    int distributeCandies(vector<int>& candies) {
        unordered_set<int>s(candies.begin(),candies.end());
        return min(candies.size()/2,s.size());
    }
};
```

leetcode 的官方解答:

https://leetcode.com/articles/distribute-candies/



### 811. *Subdomain Visit Count

https://leetcode.com/problems/subdomain-visit-count/description/

A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly.

Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com".

We are given a list `cpdomains` of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.

```bash
Example 1:
Input: 
["9001 discuss.leetcode.com"]
Output: 
["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]
Explanation: 
We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.
```

```bash
Example 2:
Input: 
["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
Output: 
["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
Explanation: 
We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.
```

**Notes:**

- The length of `cpdomains` will not exceed `100`. 
- The length of each domain name will not exceed `100`.
- Each address will have either 1 or 2 "." characters.
- The input count in any count-paired domain will not exceed `10000`.
- The answer output can be returned in any order.

思路: 题目描述一大堆, 但实际非常简单. 使用 Hash Table.

```cpp
class Solution {
private:
  	// 将 domain 中的 "." 的位置给找出来, 注意 res 初始化为 -1, 
  	// 是因为下面代码中求子串时使用的是: domain.substr(idx + 1, len - idx - 1)
  	// 要得到比如 google.mail.com 这样的完整域名, 需要从索引 0 开始.
    vector<int> dotIndex(string &domain) {
        vector<int> res{-1};
        for (int i = 0; i < domain.size(); ++i)
            if (domain[i] == '.')
                res.push_back(i);
        return res;
    }
public:
  	// 后面不说了, 找到了 dot 的位置, 非常简单.
    vector<string> subdomainVisits(vector<string>& cpdomains) {
        unordered_map<string, int> record;
        for (auto &cp : cpdomains) {
            stringstream ss(cp);
            int count;
            string domain;
            ss >> count >> domain;
            vector<int> indes = dotIndex(domain);
            int len = domain.size();
            for (auto &idx : indes) {
                record[domain.substr(idx + 1, len - idx - 1)] += count;
            }
        }

        vector<string> res;
        for (auto &iter : record) {
            string ans = to_string(iter.second) + " " + iter.first;
            res.push_back(ans);
        }
        return res;
    }
};
```



### 594. *Longest Harmonious Subsequence

https://leetcode.com/problems/longest-harmonious-subsequence/description/

We define a harmonious array is an array where the difference between its maximum value and its minimum value is **exactly** 1.

Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible [subsequences](https://en.wikipedia.org/wiki/Subsequence).

**Example 1:**

```bash
Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
```

**Note:** The length of the input array will not exceed 20,000.



思路 1: 使用查找表思路最为直观, 将元素在查找表中进行统计, 然后针对查找表中的每个元素 a, 判断 a + 1 是否存在于查找表中.

```cpp
class Solution {
public:
    int findLHS(vector<int>& nums) {
        unordered_map<int, int> record;
        for (auto &i : nums)
            record[i] ++;
        int res = 0;
        for (auto iter : record)
            if (record.count(iter.first + 1))
                res = max(res, iter.second + record[iter.first + 1]);
        return res;
    }
};
```

思路 2: 先对数组进行排序, 然后统计最长的 Harmonious 序列. 先给出代码, 然后讲解. 因为细节有点多.

1. 首先对数组进行排序;
2. `pre_count` 表示前一组相同元素的个数, res 表示最长 Harmonious 序列的长度. 
3. 不多说了, 按这种方法, 稍不注意就容易产生 bug... 虽然排序要 O(nlogn) 然后我提交之后, 速度竟然比上面一种方法快.

```cpp
class Solution {
public:
    int findLHS(vector<int>& nums) {
        std::sort(nums.begin(), nums.end());
        int pre_count = 1, res = 0;
      	// 注意 i 从 0 开始而不是 1 开始, 
        for (int i = 0; i < nums.size(); ++i) {
            int count = 1;
          	// 统计比 nums[i - 1] 大 1 的元素个数.
            if (i > 0 && nums[i] - nums[i - 1] == 1) {
                while (i < nums.size() - 1 && nums[i] == nums[i + 1]) {
                    count ++;
                    i ++;
                }
              	// 由于已经找到了一个 Harmonious 序列, 因此需要更新 res 的值.
                res = max(res, count + pre_count);
                pre_count = count;
            }
            else { // 统计和 nums[i-1] 相同的元素个数
                while (i < nums.size() - 1 && nums[i] == nums[i + 1]) {
                    count ++;
                    i ++;
                }
                pre_count = count;
            }
        }
        return res;
    }
};
```

leetcode 的官方解答如下:

[Longest Harmonious Subsequence](https://leetcode.com/articles/longest-harmonious-subsequence/)



## 链表

### 2. **Add Two Numbers

https://leetcode.com/problems/add-two-numbers/description/

给定两个非空的链表, 它们的每个节点中只包含一个 0 ~ 9 之间的数字, 两个表的逆序表示两个整数, 现在要将这两个整数相加, 并将和保存在新链表中. 比如:

```bash
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```



思路: 这道题不是很复杂, 原因是每个节点只保存了一个数字, 所以主要考虑进位的问题, 当求和时, 下一个节点的值应该是 `sum % 10`, 进位 `carry_over` 是 `sum / 10`. 另外, 关于链表的问题, 最好设置一个虚拟头结点, 这样可以省很多麻烦. 还需要注意一点是: `list1: {5}, list2: {5}`, 结果为 `result: {0, 1}` 表示 10, 这启示我们, 即使两个链表遍历完了, 还需要考虑 `carry_over` 是否大于 0. 另外, 当两个链表的长度不相等时, 也是要考虑的情况.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int carry_over = 0;

        ListNode *dummy = new ListNode(0);
        auto ptr = dummy;
		
      	// 如果最后 carry_over 不为 0, 那么仍要继续求值.
        while (l1 || l2 || carry_over) {
          	// 如果某链表访问完了, 那么就不要将其求和, part 设置为 0.
            int part1 = l1 ? l1->val : 0;
            int part2 = l2 ? l2->val : 0;

            int sum = carry_over + part1 + part2;
          	// 设立 dummy, 这里就很方便了.
            ptr->next = new ListNode(sum % 10);
            ptr = ptr->next;
            carry_over = sum / 10;

            l1 = l1 ? l1->next : nullptr;
            l2 = l2 ? l2->next : nullptr;
        }

        ListNode *res = dummy->next;
        delete dummy;
        return res;
    }
};
```

再给出 leetcode 上的解答, 这里的 `flag` 就是 `carry_over`.

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        auto ptr = dummy;
        int flag = 0;
        while(l1 || l2 || flag)
        {
            int sum = flag;
            if(l1)
            {
                sum += l1->val;
                l1 = l1->next;
            }
            if(l2)
            {
                sum += l2->val;
                l2 = l2->next;
            }
            ptr->next = new ListNode(sum % 10);
            ptr = ptr->next;
            flag = sum / 10;
        }
        return dummy->next;
    }
};
```



### 445. **Add Two Numbers II

https://leetcode.com/problems/add-two-numbers-ii/description/

给定两个非空的链表, 它们表示两个非负整数, 每个节点只包含一个数字, 与题 2 Add Two Numbers 不同的是, 链表不是逆序表示一个整数, 而是 the most significant digit comes first. 现在要将两个链表表示的整数相加, 同时将结果连链表的形式返回. 可以假设链表中不存在以 0 开头的数, 除非这个链表本身就表示 0. 例子:

**Example:**

```
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
```

Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.



思路: 本来一开始想的是如果将两个链表反转, 那么就变成了和题 2 Add Two Numbers 同样的处理方式. 但是 follow up 中要求不能将链表反转, 那么我另一个思路是使用两个栈, 将数据保存下来. 但这里还是可以使用反转链表的方式处理, 所以代码都给出如下:

思路一: 对两个链表反转:

```cpp
class Solution {
private:
  	// 反转一个链表, 没啥说的, 必须熟练.
    ListNode* reverse(ListNode *head) {
        ListNode *pre = nullptr;
        auto ptr = head;
        while (ptr) {
            ListNode *tmp = ptr->next;
            ptr->next = pre;
            pre = ptr;
            ptr = tmp;
        }
        return pre;
    }
public:
  	// 具体还可以参考一下题 2 Add Two Numbers 中的解答.
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        l1 = reverse(l1);
        l2 = reverse(l2);

        int carry_over = 0;
        ListNode *dummy = new ListNode(0);
        auto ptr = dummy;
        while (l1 || l2 || carry_over) {
            int part1 = l1 ? l1->val : 0;
            int part2 = l2 ? l2->val : 0;

            int sum = carry_over + part1 + part2;
            ptr->next = new ListNode(sum % 10);
            ptr = ptr->next;
            carry_over = sum / 10;

            l1 = l1 ? l1->next : nullptr;
            l2 = l2 ? l2->next : nullptr;
        }
        return reverse(dummy->next);
    }
};
```

思路二: 使用栈:

```cpp
class Solution {
private:
  	// 在链表中插入元素.
    void insert(ListNode *head, int val) {
        ListNode *node = new ListNode(val);
        node->next = head->next;
        head->next = node;
    }
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2;
      	// 将链表中的元素分别推入栈中
        while (l1) {
            s1.push(l1->val);
            l1 = l1->next;
        }
        while (l2) {
            s2.push(l2->val);
            l2 = l2->next;
        }
		
      	// 出栈进行相加运算
        int carry_over = 0;
        ListNode *dummy = new ListNode(0);
        while (!s1.empty() || !s2.empty() || carry_over) {
            int part1 = 0, part2 = 0;
            if (!s1.empty()) {
                part1 = s1.top();
                s1.pop();
            }
            if (!s2.empty()) {
                part2 = s2.top();
                s2.pop();
            }

            int sum = part1 + part2 + carry_over;
            insert(dummy, sum % 10);
            carry_over = sum / 10;
        }
        return dummy->next;
    }
};
```





### 21. *Merge Two Sorted Lists

https://leetcode.com/problems/merge-two-sorted-lists/description/

将两个有序链表合并成一个有序链表.

题目中其实要求说新的链表需要是两个输入链表的节点组成的, 但我看答案中有些代码是直接 new, 感觉这样不对. 因此下面我是直接使用节点的地址.

思路: 和归并排序的思路类似, 另外不得不说, 对于链表的题目, 最好是使用一个 dummy 头结点, 可以省掉很多麻烦, 参考上一题 2. Add Two Number 中使用 dummy 头结点后, 再使用 `ptr = dummy` 来遍历新的链表. 和归并排序不同的是, 如果其中一个输入链表遍历完了, 那么对于剩下的那个链表, 就不必再遍历了, 只需要设置 `ptr->next = l1 ? l1 : l2`, 将节点连接起来即可.

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(0);
        auto ptr = dummy;

        while (l1 && l2) {
            if (l1->val < l2->val) {
                ptr->next = l1;
                l1 = l1->next;
            }
            else {
                ptr->next = l2;
                l2 = l2->next;
            }
            ptr = ptr->next;
        }

        ptr->next = l1 ? l1 : l2;

        ListNode *res = dummy->next;
        delete dummy;
        return res;
    }
};
```



### 23. ***Merge k Sorted Lists

https://leetcode.com/problems/merge-k-sorted-lists/description/

类似于上一题, 但此处是将 k 个已排序的链表归并起来.

思路: 首先我想到的是使用优先队列, 将每个链表中的头结点插入到队列中, 弹出最小的那个 `minNode`, 如果 minNode 的 next 节点不为空, 那么将该节点 push 到队列中继续进行处理. 第二种思路就是复用上面的 21. Merge 2 sorted lists 中的代码, 将链表两两合并, 但时间复杂度稍高.

```cpp
class Solution {
private:
  	// 优先队列默认弹出最大值, 使用的默认比较函数是: 
  	// std::less<typename Container::value_type>
  	// 因此, 这里改成如果 p1 比 p2 要大的话, 那么就后弹出.
    struct cmp {
        bool operator()(ListNode *p1, ListNode *p2) {
            return (p1->val) > (p2->val);
        }
    };
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;

        priority_queue<ListNode*, vector<ListNode*>, cmp> Queue;
      	// 注意, lists 中可以有些 node 是空的, 不需要考虑这些空节点
        for (auto &ptr : lists)
            if (ptr)
                Queue.push(ptr);

        ListNode *dummy = new ListNode(0);
        auto ptr = dummy;

        while (!Queue.empty()) {
            auto minNode = Queue.top();
            Queue.pop();

            ptr->next = minNode;
            if (minNode->next)
                Queue.push(minNode->next);
            ptr = ptr->next;
        }

        ListNode *head = dummy->next;
        delete dummy;
        return head;
    }
};
```

第二种思路, 基于 merge 2 sorted lists:

```cpp
class Solution {
private:
    ListNode* mergeTwoLists(ListNode *p, ListNode *q) {

        ListNode *dummy = new ListNode(0);
        auto ptr = dummy;

        while (p && q) {
            if (p->val < q->val) {
                ptr->next = p;
                p = p->next;
            }
            else {
                ptr->next = q;
                q = q->next;
            }
            ptr = ptr->next;
        }

        ptr->next = p ? p : q;

        ListNode *head = dummy->next;
        delete dummy;
        return head;
    }
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;
        // 复用 mergeTwoLists
        ListNode *p = lists[0];
        for (int i = 1; i < lists.size(); ++i)
            p = mergeTwoLists(p, lists[i]);

        return p;
    }
};
```





### 147. **Insertion Sort List

https://leetcode.com/problems/insertion-sort-list/description/

对链表使用插入排序.

思路: 首先要明确插入排序的定义. 比如数组中, 对于当前访问的元素 `arr[i]`, 它要和它前面的已排好序的元素 `arr[0...i - 1]` 进行比较, 并插入合适的位置. 现在考虑链表, 第一: 设置虚拟头结点 dummy 减少插入元素的麻烦; 第二, 如何定义已排好序的元素的, 下面我使用 `[dummy->next,..., end]` 来表示排好序的元素的范围, 使用 `list[end->next]` 表示当前访问的元素, 然后将该元素和前面的元素依次(使用 start 来遍历已排好序的元素)比较, 插入到合适的位置, 并将链表中节点间的顺序设置好; 但是如果当前访问的元素比前面所有的元素都大(也就是 `start` 已经访问到 `end` 了, 在链表中实际表现为 `start->next == end->next`), 那么只要将该元素纳入到已排序的链表中, 即 `end = node`.

```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if (!head)
            return nullptr;
        ListNode *dummy = new ListNode(0);
        dummy->next = head;

        ListNode *end = head;
        while (end->next) {
          	// 使用 start 来遍历 [dummy->next,... end]
          	// node 表示当前访问的未排序的元素.
            ListNode *start = dummy;
            ListNode *node = end->next;
            while (start->next != end->next) {
                if (node->val < start->next->val) {
                    end->next = node->next;
                    node->next = start->next;
                    start->next = node;
                    break;
                }
                else {
                    start = start->next;
                }
            }
            
            if (start->next == end->next)
                end = node;
        }

        head = dummy->next;
        delete dummy;
        return head;
    }
};
```



### 86. Partition List

https://leetcode.com/problems/partition-list/description/

给定一个链表和一个值 x, 将这个链表分成两个部分, 其中所有小于 x 的节点都放在所有大于或等于 x 的节点的前面. 另外, 在这两个部分中, 还要保留节点的相对位置. 比如:

Given `1->4->3->2->5->2` and *x* = 3,
return `1->2->2->4->3->5`.

思路: 使用 `ptr` 来遍历原链表, 比较每个节点和 x 的值的相对大小. 然后设置两个虚拟节点 less 和 greater, 用于连接小于 x 的所有节点以及大于或等于 x 的所有节点, 最后只要将 `greater->next` 接到 less 的末尾即可.

注意下面代码中 `gptr->next` 最后一定要设置为空, 否则会形成一个带环的链表...

```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *less = new ListNode(0);
        ListNode *greater = new ListNode(0);

        auto ptr = head;
        auto lptr = less;
        auto gptr = greater;

        while (ptr) {
            if (ptr->val < x) {
                lptr->next = ptr;
                lptr = lptr->next;
            }
            else {
                gptr->next = ptr;
                gptr = gptr->next;
            }
            ptr = ptr->next;
        }

        // 下面这行设置 gptr->next 为空的代码必须存在,
        // 否则会无限输出. 可以在此之前打印 gptr->next->val
        // 便可以知道缘由.
        gptr->next = nullptr;
        lptr->next = greater->next;
        ListNode *res = less->next;
        delete less;
        delete greater;
        return res;
    }
};
```



### 19. Remove Nth Node From End of List

https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/

给定一个链表, 将倒数第 n 个节点给删除. 比如:

```bash
Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
```

**Note:**
Given *n* will always be valid.
Try to do this in one pass.

思路: 这道题麻烦在不知道倒数第 n 个节点怎么找, 这个时候需要使用两个指针, `p1` 和 `p2`, 让它们俩之间有 n 个节点(这样的话, 加上它们两个节点就有 n + 2 个节点). 此时, 当 p2 指向链表的尾部 nullptr 时, p1 就刚好指向要删除节点的前一个节点.

```bash
				   p1               p2      -- end 结束的状态
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nullptr
 p1                p2                       -- start 一开始的状态
```

但注意只有当 p2 移动到距离 p1 有 3 个节点的间隔时, p1 才会开始向右移动, 否则它一直指向 dummy.

这就是为什么我在下面的代码中令 `count > n + 1` (上面是 n = 2 时的情况).

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if (!head)
            return nullptr;

        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        int count = 0;
        auto p1 = dummy, p2 = dummy;

        while (p2) {
            p2 = p2->next;
            count ++;

            // 这里只有当 count > n + 1 才移动, 是因为这样做的话,
            // p1 能移动到要删除节点的前一个节点, 如果是 count > n,
            // 那么 p1 会移到要删除的节点.
            if (count > n + 1)
                p1 = p1->next;
        }

        ListNode *delNode = p1->next;
        p1->next = delNode->next;
        delete delNode;

        head = dummy->next;
        delete dummy;
        return head;
    }
};
```

感觉下面的思路可能更好理解: 见 leetcode-cpp.pdf 2.2.7

思路: 设两个指针 p; q，让 q 先走 n 步，然后 p 和 q 一起走，直到 q 走到尾节点，删除 p->next 即可。

```cpp
// LeetCode, Remove Nth Node From End of List
// 时间复杂度 O(n)，空间复杂度 O(1)
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {
        ListNode dummy{-1};
        dummy.next = head;
        ListNode *p = &dummy, *q = &dummy;
        for (int i = 0; i < n; i++) // q 先走 n 步
            q = q->next;
        while(q->next) { // 一起走
            p = p->next;
            q = q->next;
        }
        ListNode *tmp = p->next;
        p->next = p->next->next;
        delete tmp;
        return dummy.next;
    }
};
```



### 83. Remove Duplicates from Sorted List

https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/

给定一个排序好的链表, 将其中的重复元素给删除, 使得相同元素只出现一次. 比如:

Given `1->1->2`, return `1->2`.
Given `1->1->2->3->3`, return `1->2->3`.

思路: 这道题比较简单, 但是我想复杂了... 先给出 leetcode 的上一个简洁的求解:

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* temp_node = head;
        while (temp_node != NULL && temp_node->next != NULL) {
            if (temp_node->next->val == temp_node->val) {
                temp_node->next = temp_node->next->next;
            }else {
                    temp_node = temp_node->next;
            }
        }
        return head;        
    }
};
```

然后说明我的想法, 使用 bound 节点来表示它前面的节点都是没有重复的, ptr 表示当前要考察的节点.

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head)
            return head;

        ListNode *dummy = new ListNode(0);
        dummy->next = head;

        ListNode *bound = head, *ptr = head->next;

        while (ptr) {
            if (ptr->val != bound->val) {
                bound->next = ptr;
                bound = bound->next;
            }
            ptr = ptr->next;
        }
		// 注意最后要将 bound->next 设置为 nullptr.
        bound->next = nullptr;

        return dummy->next;
    }
};

```



### 82. Remove Duplicates from Sorted List II

https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/

给定一个排好序的链表, 将所有有重复元素的节点都删除, 只保留只有单独一个元素的节点. 比如:

Given `1->2->3->3->4->4->5`, return `1->2->5`.
Given `1->1->1->2->3`, return `2->3`.

思路: 首先, 通过画图可以明确这样一点, 需要使用 3 个指针来遍历这个链表, 我这里每次考虑的是 `ptr->next` 这个节点, 所以需要判断这个节点是否满足:

```cpp
// 即 ptr->next 的值是否与它前一个元素不相等, 并且和它后一个元素也不相等.
// third 为 ptr->next->next.
ptr->next->val != ptr->val && third->val != ptr->next->val
```

但是这里还需要考虑如 `{1}`, `{1, 1}` 以及 `{1, 2}` 这样的只有少于两个元素的两种情况. 另外由于要访问 `third`, 所以还需要判断 `third` 是否为空, 如果是的话, 那么说明此时 `ptr` 指向的是倒数第二个节点. 另外注意最后 `ele->next` 要设置为空.

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head)
            return nullptr;

        ListNode *dummy = new ListNode(0);
        auto ele = dummy;
        auto ptr = head;

        if (!head->next || (head->next && (head->val != head->next->val))) {
            ele->next = head;
            ele = ele->next;
        }

        while (ptr->next) {
            auto third = ptr->next->next;
            if (!third) {
                if (ptr->next->val == ptr->val)
                    break;
                else {
                    ele->next = ptr->next;
                    ele = ele->next;
                }
            }
            else {
                if (ptr->next->val != ptr->val && third->val != ptr->next->val) {
                    ele->next = ptr->next;
                    ele = ele->next;
                }
            }
            ptr = ptr->next;
        }

        ele->next = nullptr; 
        return dummy->next;
    }
};
```

leetcode 上还有一种思路是考虑当前访问的节点是否满足条件, 那么它就要和 `prev` 以及它下一个节点比较: 这里注意 : `dummy.val = head->val == 1 ? -1 : 1;` 当 cur 为 head 时, 由于需要 prev, 所以令 dummy 的值和 head 的值不同.

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) return nullptr;
        ListNode dummy(-1);
        dummy.val = head->val == 1 ? -1 : 1;
        ListNode *prev = &dummy, *curr = head, *first = &dummy;
        prev->next = curr;
        while (curr && curr->next) {
            if (prev->val != curr->val && curr->val != curr->next->val) {
                first->next = curr;
                first = first->next;
            }
            prev = curr;
            curr = curr->next;
        }
        if (curr->val != prev->val)
            first->next = curr;
        else first->next = nullptr;
        return dummy.next;
    }
};
```

最后给出一种精彩的使用递归进行求解的方法: 见 leetcode-cpp.pdf 2.2.5 节

```cpp
// LeetCode, Remove Duplicates from Sorted List II
// 递归版，时间复杂度 O(n)，空间复杂度 O(1)
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if (!head || !head->next) return head;
        ListNode *p = head->next;
        if (head->val == p->val) {
            while (p && head->val == p->val) {
                ListNode *tmp = p;
                p = p->next;
                delete tmp;
            }
            delete head;
            return deleteDuplicates(p);
        } else {
            head->next = deleteDuplicates(head->next);
            return head;
        }
    }
};
```



### 24. **Swap Nodes in Pairs

https://leetcode.com/problems/swap-nodes-in-pairs/description/

给定一个链表, 将链表中所有相邻两个节点交换, 并返回头结点. 比如:

Given `1->2->3->4`, you should return the list as `2->1->4->3`.

Your algorithm should use only constant space. You may **not** modify the values in the list, only nodes itself can be changed.

思路: 目测使用递归的话会非常简单. 需要判断头结点的下一个节点是否存在. 当交换完一开始的两个节点之后, 就使用递归交换剩下的节点.

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (!head || !head->next)
            return head;

        ListNode *dummy = new ListNode(0);
        ListNode *post = head->next->next;
        dummy->next = head->next;
        dummy->next->next = head;
        dummy->next->next->next = swapPairs(post);

        ListNode *res = dummy->next;
        delete dummy;
        return res;
    }
};
```

好吧, 把它改成非递归版的似乎快了 1ms.

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (!head || !head->next)
            return head;

        ListNode *dummy = new ListNode(0);
        auto path = dummy;
        auto ptr = head;
      	// 要交换两个节点, 先要判断 ptr 以及 ptr->next 均存在,
      	// 之后用 post 记录第三个节点, 也就是下一次交换的开始.
        while (ptr && ptr->next) {
            auto post = ptr->next->next;
            path->next = ptr->next;
            path->next->next = ptr;
            path = path->next->next;
            ptr = post;
        }
      	// 不管最后 ptr 是不是为空, 使用 path->next 指向它就可以了.
        path->next = ptr;
        ListNode *res = dummy->next;
        delete dummy;
        return res;
    }
};
```



### 25. ***Reverse Nodes in k-Group

https://leetcode.com/problems/reverse-nodes-in-k-group/description/

给定一个链表, 每次将其中连续的 k 个节点进行反转, 返回修改后的链表. k 是一个小于或等于链表长度的正数. 如果链表的长度无法整除 k, 那么剩下的节点应该保持原样. (注意不能改变节点本身的值, 只允许 O(1) 的空间复杂度), 比如:

Given this linked list: `1->2->3->4->5`

For *k* = 2, you should return: `2->1->4->3->5`

For *k* = 3, you should return: `3->2->1->4->5`



思路: 下面的第一个思路有点不厚道, 因为我使用了 stack 来简化 k 个节点的反转, 所以看起来很简单.(好吧, 写完后才发现只运行 O(1) 的空间复杂度). 那么之后看第二个思路, 真是非常简洁漂亮.

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (!head)
            return nullptr;

        stack<ListNode*> Stack;
        auto end = head;
        for (int i = 0; i < k; ++i) {
            if (!end)
                return head;
            Stack.push(end);
            end = end->next;
        }

        auto post = end;
        ListNode *dummy = new ListNode(0);
        auto path = dummy;
        while (!Stack.empty()) {
            path->next = Stack.top();
            Stack.pop();
            path = path->next;
        }
        path->next = reverseKGroup(post, k);
        ListNode *res = dummy->next;
        delete dummy;
        return res;
    }
};
```

下面这个代码真的很简洁, reverse 的写法要学习: leetcode 上的讨论

[C++ Elegant and Small](https://leetcode.com/problems/reverse-nodes-in-k-group/discuss/11435/C++-Elegant-and-Small)

思路和我的一样, 使用递归, 但是 reverse 写的很简洁精妙,

```bash
 # 假设要反转的是 (1, 2, 3), 那么 pre 指向的是 4
 # 使用 first 去遍历 1, 2, 3, tmp 用于保存 first 下一个要遍历的值.
 # 当处理完 1 之后, 就要把 1 放在 3 后面, 此时还要将 prev 移动到 1 上,
 # 这样的话, 当 first 移动到 2 上之后, prev 将移动到 1 上, 表示
 # 已反转好的节点的地址.
  1   ->  2   -> 3  ->  4  ->  5  -> 6 -> 7 -> NULL
first    tmp          prev
					  last
```

下面是具体代码:(注意while 循环中判断条件是 `first != last`, 不要写成了 `first != prev`, prev 用于记录已反转节点的首地址. last 可以为空.)

```cpp
class Solution 
{
public:
    
    ListNode* reverse(ListNode* first, ListNode* last)
    {
        ListNode* prev = last;
        
        while ( first != last )
        {
            auto tmp = first->next;
            first->next = prev;
            prev = first;
            first = tmp;
        }
        
        return prev;
    }
    
    ListNode* reverseKGroup(ListNode* head, int k) 
    {
        auto node=head;
        for (int i=0; i < k; ++i)
        {
            if ( ! node  )
                return head; // nothing to do list too sort
            node = node->next;
        }

        auto new_head = reverse( head, node);
        head->next = reverseKGroup( node, k);
        return new_head;
    }
};
```



再补充一个非递归版本:

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(k == 1 || head == NULL) return head;
        ListNode *dummy = new ListNode(0), *pre = dummy, *cur = pre;
        dummy->next = head;
        int length = 0;
        while(cur = cur->next) length++;
        while(length >= k) {
            cur = pre->next;
            for (int i = 1; i < k; ++i) {//pre始终为每一段head的前一个结点
                ListNode *t = cur->next;
                cur->next = t->next;
                t->next = pre->next;
                pre->next = t;
            }
            pre = cur;
            length -= k;
        }
        return dummy->next;
    }
};
```



### 206. *Reverse Linked List

https://leetcode.com/problems/reverse-linked-list/description/

反转一个链表.

做完上面 25. Reverse Nodes in k-Group 后再来看这道题, 就非常简单了. 当然还有一种使用 3 个指针的做法. 首先看非递归的版本:

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr;

        while (head) {
            ListNode *tmp = head->next;
            head->next = prev;
            prev = head;
            head = tmp;
        }
        return prev;
    }
};
```

再看递归的版本:

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL || head->next==NULL)return head;
        ListNode* node=reverseList(head->next);
        head->next->next=head;
        head->next=NULL;
        return node;
    }
};
```



### 61. **Rotate List

https://leetcode.com/problems/rotate-list/description/

Given a linked list, rotate the list to the right by *k* places, where *k* is non-negative.

**Example 1:**

```bash
Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL
```

**Example 2:**

```bash
Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
```



思路: 使用递归可以非常简单的解决这道题目, 如果要将链表旋转 k 次, 那么可以在旋转 k - 1 次的基础上, 将链表的最后一个节点放在链表的头部, 这样就得到了第 k 次的链表. 但是有个优化必须注意, 否则会报超时, 毕竟 k 可能很大, 我们观察到, 如果 k 能整除链表中节点的个数, 那么旋转后的链表将是原链表本身.

```cpp
class Solution {
private:
    ListNode* rotateRight(ListNode *head, int n, int k) {
      	// 如果 k 能整除 n, 那么直接返回链表本身
        if ((k % n) == 0) return head;
		
      	// 否则只要在第 k-1 次旋转得到的链表的基础上, 做一些简单的操作即可.
      	// 注意 while 循环中判断 ptr->next->next 是否存在, 这样是为了让
      	// ptr 最终的值是倒数第二个节点.
        head = rotateRight(head, n, k - 1);
        auto ptr = head;
        while (ptr->next && ptr->next->next)
            ptr = ptr->next;
        auto tmp = ptr->next;
        ptr->next = nullptr;
        tmp->next = head;
        head = tmp;
        return head;

    }
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (!head || !head->next) return head;
      	// 用 n 统计链表中节点的个数
        int n = 0;
        auto ptr = head;
        while (ptr) {
            ptr = ptr->next;
            ++ n;
        }
        return rotateRight(head, n, k);
    }
};
```

leetcode 的讨论中还有比较精彩的两种未使用递归的方法:

[My clean C++ code, quite standard (find tail and reconnect the list)](https://leetcode.com/problems/rotate-list/discuss/22735/My-clean-C++-code-quite-standard-(find-tail-and-reconnect-the-list))

代码如下: There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don't see the benefit (in the sense that it doesn't reduce the pointer move op) to do so. So I just used one loop to find the length first. 

这种做法的思路是, 首先求出链表的大小, 并找到最后一个节点 `tail`, 然后将链表弄成环状 `tail->next = head`. 之后根据 `k %= len`, 判断何处断开链表. (如果 if 语句中没有使用 `k %= len`, 那么 for 循环中的判断条件 `i < len - k` 实际上是 `i < len - k % len`. 知晓这一点是因为下面要介绍的第二种思路就用到了这个公式).

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return head;
        
        int len=1; // number of nodes
        ListNode *newH, *tail;
        newH=tail=head;
        
        while(tail->next)  // get the number of nodes in the list
        {
            tail = tail->next;
            len++;
        }
        tail->next = head; // circle the link

        if(k %= len) 
        {
            for(auto i=0; i<len-k; i++) tail = tail->next; // the tail node is the (len-k)-th node (1st node is head)
        }
        newH = tail->next; 
        tail->next = NULL;
        return newH;
    }
};
```

另一个答案是:

[Share my java solution with explanation](https://leetcode.com/problems/rotate-list/discuss/22715/Share-my-java-solution-with-explanation)

代码如下:

Since n may be a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation.

Ex: {1,2,3} k=2 Move the list after the 1st node to the front

Ex: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front.

So the code has three parts.

1. Get the length
2. Move to the (l-n%l)th node
3. Do the rotation

英文解释得很明白了.

```cpp
public ListNode rotateRight(ListNode head, int n) {
    if (head==null||head.next==null) return head;
    ListNode dummy=new ListNode(0);
    dummy.next=head;
    ListNode fast=dummy,slow=dummy;

    int i;
    for (i=0;fast.next!=null;i++)//Get the total length 
    	fast=fast.next;
    
    for (int j=i-n%i;j>0;j--) //Get the i-n%i th node
    	slow=slow.next;
    
    fast.next=dummy.next; //Do the rotation
    dummy.next=slow.next;
    slow.next=null;
    
    return dummy.next;
}
```



### 189. *Rotate Array

https://leetcode.com/problems/rotate-array/description/
将一个含有 n 个元素的数组向右旋转 k 步. 和上题 61 Rotate List 类似, 只不过这里处理数组.

For example, with *n* = 7 and *k* = 3, the array `[1,2,3,4,5,6,7]` is rotated to `[5,6,7,1,2,3,4]`.

**Note:**
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.



思路: 这道题其实还有提高的版本, 比如要只使用 O(1) 的空间... 但这应该涉及一些特技... 先讲最简单直观的思路, 比如引入一个和原数组同样大小的数组, 将旋转后的数组保存到新数组中, 最后只要让原数组指向新数组即可. 具体做法是, 有两种思路:

1. 参考题 61 Rotate List 讨论中给出的解答, 可以得到如下结论, 第 `(len - k % len)` 位置(注意是从 0 开始索引)的元素以及它之后的元素都要被旋转. 比如:

   ```bash
   1 2 3 4 5 6 7 # 原数组
   # len - k % len = 7 - 3 % 7 = 4
   # 那么 5 6 7 将被旋转
   ```

   旋转的具体做法是, 将原数组看成一个环状, 起点从第 `(len - k % len)` 个元素开始. 那么要访问这个环中的每个元素, 只需要使用 `(len - k % len + i) % len`, 其中 i 变化范围为 `0 ~ len - 1`. 将这些元素依次拷贝到新数组中即可.

2. 思路二: 更简洁, 只要将原数组中第 i 个元素放在新数组中第 `(i + k) % len` 的位置即可.

思路三: 如果只允许使用 O(1) 的空间, 那么就需要仔细观察...可以使用 reverse 来解决这个问题. 这种方法的实现是基于这样的现象: 将数组旋转 k 次, 得到的结果相当于将数组后面的 k 个元素放在了数组的前面, 而原来剩下的前面的元素都将向后移动. 那么首先可以将这个数组翻转, 然后再将前 k 个元素翻转, 最后将 `k ~ len - 1` 的元素进行翻转, 比如:

```bash
Let n=7 and k=3.

Original List                   : 1 2 3 4 5 6 7
After reversing all numbers     : 7 6 5 4 3 2 1
After reversing first k numbers : 5 6 7 4 3 2 1
After revering last n-k numbers : 5 6 7 1 2 3 4 --> Result
```



下面是上面 3 种思路的实现代码:

思路1:

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if (nums.empty())
            return;

        int len = nums.size();
        vector<int> res(len);
        for (int i = 0; i < len; ++i) {
            int idx = (len - k % len + i) % len;
            res[i] = nums[idx];
        }
        nums = res;
    }
};
```



思路 2: 来自 leetcode 的官方解答: 

https://leetcode.com/problems/rotate-array/solution/

```java
public class Solution {
    public void rotate(int[] nums, int k) {
        int[] a = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            a[(i + k) % nums.length] = nums[i];
        }
        for (int i = 0; i < nums.length; i++) {
            nums[i] = a[i];
        }
    }
}
```

思路三:

使用 reverse 方法.

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        if (nums.empty())
            return;
        k %= nums.size();
        std::reverse(nums.begin(), nums.end());
        std::reverse(nums.begin(), nums.begin() + k);
        std::reverse(nums.begin() + k, nums.end());
    }
};
```



注意 leetcode 官方给出了四种解法, 详见:

https://leetcode.com/problems/rotate-array/solution/

其中的 Approach #3 Using Cyclic Replacements [Accepted] 我还没有仔细看.



### 237. *Delete Node in a Linked List

https://leetcode.com/problems/delete-node-in-a-linked-list/description/

删除链表中的节点(不考虑尾部的节点), 注意你只能访问要删除节点本身. 比如:

Supposed the linked list is `1 -> 2 -> 3 -> 4` and you are given the third node with value `3`, the linked list should become `1 -> 2 -> 4` after calling your function.

思路: 用下一个节点的值覆盖当前要删除节点的值, 当然还要考虑指针的指向.

```bash
A -- B -- C -- NULL  # 假设要删除 B, 
# 用 C 的值替换 B, 同时令 C 指向原来 C 的 next
A -- C -- C -- NULL
	 |__________|
```

代码如下:

```cpp
class Solution {
public:
    void deleteNode(ListNode* node) {
        if (node->next) {
            ListNode *delNode = node->next;
            node->val = delNode->val;
            node->next = delNode->next;
            delete delNode;
        }
    }
};
```



### 143. **Reorder List

https://leetcode.com/problems/reorder-list/description/

Given a singly linked list *L*: *L*0→*L*1→…→*Ln-1→*Ln,
reorder it to: *L*0→*Ln*→*L*1→*Ln-1→*L*2→*Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given `{1,2,3,4}`, reorder it to `{1,4,2,3}`.



思路: 前方高能, 我觉得这道题的算法实在是精彩, 链表还可以这样操作...

参考 [A concise O(n) time, O(1) in place solution](https://leetcode.com/problems/reorder-list/discuss/45003/A-concise-O(n)-time-O(1)-in-place-solution), 分为三步解决这个问题:

1. 找到位于中间的节点
2. 将链表从中间分开, 然后反转后半部分链表
3. 将两个链表合并.

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        if (!head || !head->next)
            return;
      	// find the middle node: O(n)
      	// 关于找到中间的节点, 注意 p2 的移动速度总是 p1 的两倍,
      	// 最终 p2 要么到最后一个节点, 要么到 nullptr, 如果是前者, p2 移动的
      	// 距离就是 n - 1, 后者为 n, 两种情况中, p1 移动的距离分别为
      	// (n - 1)/2 以及 n/2, 即中间的位置.
        ListNode *p1 = head, *p2 = head->next;
        while (p2 && p2->next) {
            p1 = p1->next;
            p2 = p2->next->next;
        }
		
      	// cut from the middle and reverse the second half: O(n)
      	// 然后从中间开始反转后半部分节点, 可以参考 25题 Reverse Nodes in k-Group
      	// 中的做法.
        p2 = p1->next;
        ListNode *pre = nullptr;
        while (p2) {
            auto tmp = p2->next;
            p2->next = pre;
            pre = p2;
            p2 = tmp;
        }
		// merge two lists: O(n)
      	// 最后归并两个链表, 这段代码比较神奇, p1 先是指向 head 所指的前半部分节点
      	// 然后再指向 pre 所指向的后半部分的节点.
      	// 由于 p1 要访问 next, 所以最后要保证 p1 非空.
        for (p1 = head, p2 = pre; p1; ) {
            auto t = p1->next;
            p1->next = p2;
            p1 = p1->next;
            p2 = t;
        }
    }
};
```



### 234. *Palindrome Linked List

https://leetcode.com/problems/palindrome-linked-list/description/

给定一个单链表, 判断它是不是回文的.

Could you do it in O(n) time and O(1) space?

思路: 说实话, 将这道设置为 easy 有点不公平. 当然, 如果不考虑空间的话, 那么很简单, 使用 vector 保存链表中的元素就能轻松搞定, 但是如果规定只能使用 O(1) 的空间, 那么就需要一些特技. 联系上一题 143. Reorder List 中的思路, 找到中间的节点, 然后将后半部分的节点进行反转, 然后再比较前半部分的链表中节点的值和后半部分链表中节点的值是否相等.

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head || !head->next)
            return true;

        ListNode *p1 = head, *p2 = head->next;
        // find the middle node
      	// 具体含义可以参见 143 题. Reorder List 中的注释, 大意是, p2 的速度
      	// 是 p1 的两倍, 所以当 p2 到尾部的时候, p1 指向的是中点.
        while (p2 && p2->next) {
            p1 = p1->next;
            p2 = p2->next->next;
        }
      	// 对后半段链表进行反转, 可以参考 25 题 Reverse Linked List
        p2 = p1->next;
        ListNode *pre = nullptr;
        while (p2) {
            auto tmp = p2->next;
            p2->next = pre;
            pre = p2;
            p2 = tmp;
        }
		
      	// head 表示前半段, pre 表示后半段, 前半段的结尾是 p1->next,
      	// 后半段的结尾是 nullptr.
        while (head != p1->next && pre) {
            if (head->val != pre->val)
                return false;
            head = head->next;
            pre = pre->next;
        }
        return true;
    }
};
```



### 141. *Linked List Cycle

https://leetcode.com/problems/linked-list-cycle/description/

Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?



思路: 使用快慢指针来判断链表有没有环.

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next)
            return false;

        ListNode *slow = head, *fast = head->next;
        while (fast && fast->next) {
            if (fast == slow)
                return true;
            slow = slow->next;
            fast = fast->next->next;
        }
        return false;
    }
};
```



### 328. **Odd Even Linked List

https://leetcode.com/problems/odd-even-linked-list/description/

给定一个单链表, 将奇节点和偶节点分组, 并将偶节点加在奇节点后面. 比如:

**Example:**
Given `1->2->3->4->5->NULL`,
return `1->3->5->2->4->NULL`.

**Note:**
The relative order inside both the even and odd groups should remain as it was in the input. 
The first node is considered odd, the second node even and so on ...



思路: 题目不是很难, 但要考虑怎样将代码写得简洁明白. 基本思路是, 将奇节点放在一个链表中, 将偶节点放在另一个链表中, 然后将偶节点的链表加在奇节点的链表后面.

写法有两种:

写法一: 较为繁琐.

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if (!head || !head->next)
            return head;
        ListNode *odd = new ListNode(0), *even = new ListNode(0);
      	// 使用 ptr 来遍历原链表, 使用 p1 来遍历奇节点链表, 使用 p2 来遍历偶节点链表
        ListNode *ptr = head, *p1 = odd, *p2 = even;
        while (ptr && ptr->next) {
            p1->next = ptr;
            p2->next = ptr->next;
            ptr = ptr->next->next;
            p1 = p1->next;
            p2 = p2->next;
        }
      	// 由于 ptr 初始化为 head, 也就是奇节点, 那么当上面 while 结束之后, 可能是
      	// 因为 ptr->next 不成立造成的, 所以 ptr 可能不为空, 由于此时 ptr 指向奇节点, 
      	// 所以要加在 p1 的后面, 注意最后如果不设置 p2->next = nullptr, 那么会无限循环.
        if (ptr) {
            p1->next = ptr;
            p1 = p1->next;
            p2->next = nullptr;
        }
        p1->next = even->next;
        return odd->next;
    }
};
```

写法二: 参考: [leetcode 官方解答](https://leetcode.com/problems/odd-even-linked-list/solution/)

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if (!head || !head->next)
            return head;
      	// 这里没有设置虚拟头结点, 而是使用 head 来表示奇节点链表的头节点,
      	// evenHead 表示偶节点链表的头结点, 可以看到, 判断偶节点 even 以及
      	// next 是否存在让代码清晰很多.
        ListNode *odd = head, *even = head->next, *evenHead = even;
        while (even && even->next) {
            odd->next = even->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        }
        odd->next = evenHead;
        return head;
    }
};
```



### 160. *Intersection of Two Linked Lists

https://leetcode.com/problems/intersection-of-two-linked-lists/description/

找到两个链表相交的节点. 比如:

For example, the following two linked lists:

```bash
A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
```

begin to intersect at node c1.

**Notes:**

- If the two linked lists have no intersection at all, return `null`.
- The linked lists must retain their original structure after the function returns.
- You may assume there are no cycles anywhere in the entire linked structure.
- Your code should preferably run in O(n) time and use only O(1) memory.

思路: 这道题有一些 trick. 分析之前可以看看 [Linked List Cycle II](https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/linked_list_cycle.html) 中的分析, 这道题也要设置双指针, 但需要注意到下面的事实:

```bash
 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> NULL
              /
        7 -> 8
```

对于上面两个链表, 假设 1->4 的长度为 a, 7->4 的长度为 b, 4->NULL 的长度为 c,

那么, 如果设 p1 来遍历链表 1, p2 来遍历链表 2, 那么由于链表 2 比较短, 所以 p2 肯定比 p1 先到 NULL, 那么此时让 p2 指向链表 1(对, 没错是链表 1), 然后两个指针继续移动, 当 p1 移到 NULL 时, 再让 p1 指向链表 2, 然后两个指针继续移动, 最后一定会在 4 这个节点处相遇.

这是因为, 此时, p2 走过的路径长度为 `b + c + a`, 而 p1 走过的长度为 `a + c + b`, 两个长度相等!

如果两个链表不相交, 那么最终两个指针都会指向 NULL. 此时, 两个链表的移动距离是 m + n.

参考: 

[Leetcode 官方解答](https://leetcode.com/problems/intersection-of-two-linked-lists/solution/)

[Java solution without knowing the difference in len!](https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!)

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB)
            return nullptr;

        auto p1 = headA, p2 = headB;
        while (p1 != p2) {
            p1 = p1 == nullptr ? headB : p1->next;
            p2 = p2 == nullptr ? headA : p2->next;
        }

        return p1;
    }
};
```



### 138. **Copy List with Random Pointer

https://leetcode.com/problems/copy-list-with-random-pointer/description/

考虑一个链表, 它的每个节点除了 next 指针还有 random 指针指向链表中任意一个节点, 现在要将这个链表进行拷贝. 比如, 节点的定义为为:

```cpp
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
```



思路: 这道题复杂在 random 这个节点不好确定, 因为当 next 按顺序拷贝完成后, 新链表中的节点要确定 random 指针到底指向哪一个节点. 现在提供两种思路:

思路 1: 引入一个哈希表用于保存原节点和新节点之间的对应关系, 那么要确定 random 就非常方便了, 直接搜索哈希表即可. 但是这样需要的空间复杂度就是 O(n)

思路 2: 非常巧妙, 只需要 O(1) 的空间复杂度. 具体参考: [A solution with constant space complexity O(1) and linear time complexity O(N)](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N))

思路一的代码:

```cpp
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
      	// 注意如果 !head->next, 那么 head 仍需要拷贝.
        if (!head)
            return head;
      	// fmap 用于保存原节点和新节点的对应关系
        unordered_map<RandomListNode*, RandomListNode*> fmap;
        RandomListNode *newhead = new RandomListNode(head->label);
        fmap.insert(make_pair(head, newhead));
      	
      	// 遍历原节点, 然后复制成新节点, 同时保存它们的关系.
        auto nptr = newhead;
        auto ptr = head->next;
        while (ptr) {
            RandomListNode *node = new RandomListNode(ptr->label);
            fmap.insert(make_pair(ptr, node));
            nptr->next = node;
            nptr = nptr->next;
            ptr = ptr->next;
        }
		
      	// 遍历复制后的链表, 确认每个节点的 random 指针的指向.
        ptr = head;
        nptr = newhead;
        while (nptr) {
            auto randomNode = fmap[ptr->random];
            nptr->random = randomNode;
            nptr = nptr->next;
            ptr = ptr->next;
        }
        return newhead;
    }
};
```

思路 2:  [A solution with constant space complexity O(1) and linear time complexity O(N)](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N))

该算法的核心思想是将原节点和新节点联系起来, 并放在一个链表中. 算法由 3 个 iteration rounds 组成:

1. Iterate the original list and duplicate each node. The duplicate
   of each node follows its original immediately.
2. Iterate the new list and assign the random pointer for each
   duplicated node.
3. Restore the original list and extract the duplicated nodes.

```bash
# 假设原链表是
1  --  2   --  3  --  NULL
|______________|

# 复制之后, 那么第二个 1 就是复制的, 它的 random 就
# 是第一个 1 的 random(也就是 3) 的后面那个
1  --  1  --  2  --  2  --  3  --  3  -- NULL
|______|____________________|      |
       |___________________________|
```

下面是代码, 非常清晰:

```java
public RandomListNode copyRandomList(RandomListNode head) {
	RandomListNode iter = head, next;

	// First round: make copy of each node,
	// and link them together side-by-side in a single list.
	while (iter != null) {
		next = iter.next;

		RandomListNode copy = new RandomListNode(iter.label);
		iter.next = copy;
		copy.next = next;

		iter = next;
	}

	// Second round: assign random pointers for the copy nodes.
	iter = head;
	while (iter != null) {
		if (iter.random != null) {
			iter.next.random = iter.random.next;
		}
		iter = iter.next.next;
	}

	// Third round: restore the original list, and extract the copy list.
	iter = head;
	RandomListNode pseudoHead = new RandomListNode(0);
	RandomListNode copy, copyIter = pseudoHead;

	while (iter != null) {
		next = iter.next.next;

		// extract the copy
		copy = iter.next;
		copyIter.next = copy;
		copyIter = copy;

		// restore the original list
		iter.next = next;

		iter = next;
	}

	return pseudoHead.next;
}
```

C++ 的相关代码可以查看: [2 clean C++ algorithms without using extra array/hash table.  Algorithms are explained step by step.](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43497/2-clean-C++-algorithms-without-using-extra-arrayhash-table.-Algorithms-are-explained-step-by-step.)



### 148. **Sort List

https://leetcode.com/problems/sort-list/description/

使用 O(nlogn) 算法将链表排序.



思路: 使用归并排序的的思路, merge 操作非常好写, 题 21. Merge Two Sorted Lists 就可以参考. 现在需要考虑的是如何二分. 由于这几天写了好几道使用快慢指针的题, 比如 143. Reorder List 以及 234. Palindrome Linked List, 所以一下就想到可以使用快慢指针来找到链表中间的节点, 从而实现对链表的二分.

**注意代码中查找中点的注释, 因为如果不注意的话, 代码就会无限循环.**

```cpp
class Solution {
private:
  	// merge 代码就不多说了, 非常简单.
    ListNode* merge(ListNode *head1, ListNode *head2) {
        ListNode *dummy = new ListNode(0);
        auto ptr = dummy;
        auto p1 = head1, p2 = head2;
        while (p1 && p2) {
            if (p1->val < p2->val) {
                ptr->next = p1;
                p1 = p1->next;
            }
            else {
                ptr->next = p2;
                p2 = p2->next;
            }
            ptr = ptr->next;
        }
      	// 这样写非常简洁.
        ptr->next = p1 ? p1 : p2;
        return dummy->next;
    }

public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next)
            return head;

        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        auto slow = dummy, fast = head;
      	// 使用快慢指针来找到链表的中点, 这里要强调一点为什么 slow 初始化为
      	// dummy 而 fast 初始化为 head, 也就是说, 初始化的时候, slow 应该要比
      	// fast 慢上一步才行, 否则对于链表 1 -> 2 -> NULL, 如果 fast 和 slow 初始化
      	// 都是 1, 那么当 while 循环结束后, slow 就会指向 2, 最终 leftHead 仍然是
      	// 1 -> 2 -> NULL, 而 rightHead 就是 NULL, 这是不对的, 之后 sortList 处理
      	// leftHead 就会造成无限循环. 只有当 while 结束时, slow 指向 1, 才是我们想要的,
      	// 所以初始 slow 设置为 dummy. 另外 slow->next=nullptr, 让前半部分链表结尾为空,
      	// 毕竟 merge 函数中要求的就是两个链表以空指针结尾.
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        auto rightHead = slow->next;
        slow->next = nullptr;
        auto leftHead = dummy->next;
        
      	// 归并排序
        leftHead = sortList(leftHead);
        rightHead = sortList(rightHead);
        auto newHead = merge(leftHead, rightHead);
        return newHead;
    }
};
```

使用非递归的方式可以参考:

[Bottom-to-up(not recurring)  with o(1) space complextity and o(nlgn) time complextity](https://leetcode.com/problems/sort-list/discuss/46712/Bottom-to-up(not-recurring)-with-o(1)-space-complextity-and-o(nlgn)-time-complextity)



### 817. **Linked List Components

https://leetcode.com/problems/linked-list-components/description/

找到一个数组中, 有多少个联通的分量.

We are given `head`, the head node of a linked list containing **unique integer values**.

We are also given the list `G`, a subset of the values in the linked list.

Return the number of connected components in `G`, where two values are connected if they appear consecutively in the linked list.

**Example 1:**

```bash
Input: 
head: 0->1->2->3
G = [0, 1, 3]
Output: 2
Explanation: 
0 and 1 are connected, so [0, 1] and [3] are the two connected components.
```

**Example 2:**

```bash
Input: 
head: 0->1->2->3->4
G = [0, 3, 1, 4]
Output: 2
Explanation: 
0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.
```

**Note:**

- If `N` is the length of the linked list given by `head`, `1 <= N <= 10000`.
- The value of each node in the linked list will be in the range` [0, N - 1]`.
- `1 <= G.length <= 10000`.
- `G` is a subset of all values in the linked list.



思路: 首先注意一点, 链表和 G 中的元素都是唯一不重复的. 为了找到 G 中的联通分量, 可以遍历链表, 如果当前访问的元素出现在了 G 中, 那么就一直遍历下去, 直到当前访问的值不在 G 中, 说明已经获得了一条联通分量, 然后从当前访问的值继续遍历, 直到找到第二个值在 G 中, 然后重复上述过程. 为了方便判断当前访问的值是不是在 G 中, 需要把 G 中的值存入到哈希表中, 方便查找.

下面给出两种实现, 差异在于何时将联通分量的个数增加.

方法一:

```cpp
class Solution {
public:
    int numComponents(ListNode* head, vector<int>& G) {
      	// 注意边界条件不是必须的, 下面两个边界条件全部去掉完全可以.
        if (!head)
            return 0;
        if ((!head->next && head->val == G.back()))
            return 1;

        unordered_set<int> iset(G.begin(), G.end());

        auto ptr = head;
        int res = 0;

        while (ptr) {
          	// 当前访问的元素在 G 中时, 说明找到了一条联通分量, 然后继续访问链表
          	// 知道当前访问的值不在 G 中位置, 此时可以寻找下一条联通分量.
            if (iset.find(ptr->val) != iset.end()) {
                res ++;
                while (ptr->next && iset.find(ptr->next->val) != iset.end())
                    ptr = ptr->next;
            }
            ptr = ptr->next;
        }
        return res;
    }
};
```

方法二:

```cpp
class Solution {
public:
    int numComponents(ListNode* head, vector<int>& G) {
      	// 去掉了边界条件也没事
        unordered_set<int> iset(G.begin(), G.end());

        auto ptr = head;
        int res = 0;
		
        while (ptr) {
          	// 这种方法就是在联通分量的结尾才对 res 加 1, 当找到之后, 
          	// 还要保证 ptr->next 的值也不在 G 中 res 才加 1.
            if (iset.find(ptr->val) != iset.end() &&
                (!ptr->next || iset.find(ptr->next->val) == iset.end()))
                res ++;
            ptr = ptr->next;
        }
        return res;
    }
};
```

leetcode 的官方解答见: https://leetcode.com/articles/linked-list-components/



### 109. **Convert Sorted List to Binary Search Tree

https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/

将已将元素按升序排列的链表转换为平衡的二分搜索树. 对于平衡的定义, 要求每个节点的两棵子树的深度不能超过 1. 比如:

**Example:**

```bash
Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```

再介绍一下不平衡的情况, 比如:

```bash
     5
    / \
   4   6
  /     \
 3       7
/         \
1         8
```

上面的树就不平衡. 比如以 4 或 6 为根节点的 BST 就不平衡.



思路: 由于链表中的数是已按升序排好的, 所以, 只要找到链表的中点元素, 以其作为根节点, 然后将中点左边的所有元素用于构建左子树, 右边的元素用于构建右子树, 不断递归即可.

而要找到链表的中点, 使用快慢指针即可. 可以参考 141 Linked List Cycle, 143 Reorder List, 以及 234 Palindrome Linked List 了解详情. 注意, 下面代码中的 slow 一开始是指向 dummy 的, 如果链表(这种情况可以看 148. Sort List 这道题的详细解释)为 `1 -> 2 -> NULL`, 即只有两个节点的情况, 那么 slow 就会指向 1 而不是 2, 倘若 slow 一开始指向的是 head, 那么最终 slow 将会指向  2. 之后使用 `slow->next` 来得到 2, 即根节点.

```cpp
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if (!head)
            return nullptr;
        ListNode *dummy = new ListNode(0);
      	// slow 最终指向根节点前一个节点
        dummy->next = head;
        ListNode *slow = dummy, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        TreeNode *root = new TreeNode(slow->next->val);
      	// slow->next 存在, 即根节点存在, 那么可以获得根节点的右边的节点
      	// slow->next->next, 并以它开始构建右子树.
        if (slow->next)
            root->right = sortedListToBST(slow->next->next);
      	// 这里不要忘了将前半段链表的结尾设为 NULL.
        slow->next = nullptr;
        root->left = sortedListToBST(dummy->next);
        return root;
    }
};
```

本题一开始就有这个思路, 但是不敢确定, 参阅下面的讨论才开始写代码:

[Recursive BST construction using slow-fast traversal on linked list](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/35470/Recursive-BST-construction-using-slow-fast-traversal-on-linked-list)



### 108. *Convert Sorted Array to Binary Search Tree

https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/

这道题不是关于链表的, 但是和题 109 Convert Sorted List to Binary Search Tree 思路类似, 就放在这里了.

这道题是将用数组保存的元素转换为一棵平衡二分搜索树, 其中数组中的元素是按升序排好的. 比如:

```bash
Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```



思路: 找到数组的中点, 然后将其设置为 BST 的根节点, 然后用中点左侧的元素构建左子树, 中点右侧的元素构建右子树, 递归完成.

下面代码很好理解, 那行注释记录我犯的一个巨大错误, `sortedArrayToBST(nums, start, mid - 1)`  这行代码中, 我将 start 写成了 0, 而不是 start, 导致错误的结果.... 打印出来才发现.

```cpp
class Solution {
private:
    TreeNode* sortedArrayToBST(vector<int> &nums, int start, int end) {
        if (start > end)
            return nullptr;
        int mid = start + (end - start) / 2;
        //cout << "start: " << start << " end: " << end << endl;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = sortedArrayToBST(nums, start, mid - 1);
        root->right = sortedArrayToBST(nums, mid + 1, end);
        return root;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return sortedArrayToBST(nums, 0, nums.size() - 1);
    }
};
```



### 725. **Split Linked List in Parts

Given a (singly) linked list with head node `root`, write a function to split the linked list into `k` consecutive linked list "parts".

The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.

The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.

Return a List of ListNode's representing the linked list parts that are formed.

**Example 1:**

```bash
Input: 
root = [1, 2, 3], k = 5
Output: [[1],[2],[3],[],[]]
Explanation:
The input and each element of the output are ListNodes, not arrays.
For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but it's string representation as a ListNode is [].
```

**Example 2:**

```bash
Input: 
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
```

**Note:**

The length of `root` will be in the range `[0, 1000]`.

Each value of a node in the input will be an integer in the range `[0, 999]`.

`k` will be an integer in the range `[1, 50]`.



思路: 这道题思考一下之后可以注意到使用队列保存链表的节点会是一个好想法. 比如第二个例子, 有 10 个节点, 要将其分成 3 份, 那么大小分别为 4, 3, 3. 只要确定了每个小链表的大小(代码中为 num 变量), 那么每次从队列中弹出来 num 个节点即可. 如果队列中没有元素了, 但却还要确定几个空链表(比如第一个例子), 那么只要设置空链表即可(比如下面代码中直接设置 `ptr->next = nullptr`.)

这道题我提交之后是 100%.

```cpp
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* root, int k) {
      	// 将链表中的节点放在队列中
        queue<ListNode*> Queue;
        auto ptr = root;
        while (ptr) {
            Queue.push(ptr);
            ptr = ptr->next;
        }

        int n = Queue.size();
        int num = 0; // num 用于记录小链表的大小
        vector<ListNode*> res;
      	// 每次产生第 i 个小链表
        for (int i = 0; i < k; ++i) {
            ListNode *dummy = new ListNode(0);
            auto ptr = dummy;
          	// j 用于统计是否到达小链表的大小
            int j = 0;
          	// 对于 num 的确定是个有意思的问题, 举个例子, 比如链表大小为 n=11, 而要
          	// 分成 k=3 份, 那么为了计算第一份的大小: 11/3 = 3, 但是由于11无法整除 3,
          	// 所以令 3+1=4 为第一份的大小; 之后剩余 11-4=7 个节点未处理, 但注意, 此时
          	// 只需要求剩下的两份, 所以 7要除以 2, 即 7/2=3, 所以第二份的大小为 3+1=4,
          	// 最后还剩下 7-4=3 个节点, 由于只需要 1 份了, 所以最后一份大小为 3/1=3.
          	// (还可以用 n=10, k=3 举例子, 发现规律)
          	// 另外注意 queue<int> 是队列(而不是优先队列), 它没有 top 方法, 它是容器配接器,
          	// 底层容器是 deque.
            n -= num;
            num = n % (k - i) ? (n / (k - i) + 1) : n / (k - i);
            while (!Queue.empty() && j < num) {
                auto node = Queue.front();
                Queue.pop();
                ptr->next = node;
                ptr = ptr->next;
                ++j;
            }
            ptr->next = nullptr;
            res.push_back(dummy->next);
        }
        return res;
    }
};
```

















