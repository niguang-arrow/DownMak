# Pointers on C

## 2017 年 9 月 8 日

+   数组名是一个常量指针, 也就是数组第一个元素的地址. 它的类型取决于数组元素的类型, 如果它们是 int 类型, 那么数组名的类型就是 "指向 int 的常量指针"; 如果它们是 **其他类型**, 那么数组名的类型就是 "指向**其他类型**的常量指针".

+   请不要根据这个事实就得出数组和指针是相同的结论. 数组具有一些和指针完全不同的特征. 例如, 数组具有确定数量的元素, 而指针只是一个标量值. 编译器用数组名来记住这些属性. 只有当数组名在表达式中使用时, 编译器才会为它产生一个常量指针.

+   只有在两种场合下, 数组名并不用指针常量来表示 -- 就是当数组名作为 sizeof 操作符或 & 的操作数时. 

    +   sizeof 返回的是整个数组的长度, 而不是指向数组的指针的长度. 
    +   取一个数组名的地址所产生的是一个指向数组的指针, 而不是一个指向某个常量指针的指针.

+   例子:

    ```c
    int a[10];
    int b[10];
    int *c;

    // 下面两个语句任务一样
    c = &a[0]; // 数组名的值和 &a[0] 一样
    c = a;
    ```

+   C 的下标引用和间接访问表达式是一样的.

+   书上 145 页举出了例子说明有时候使用指针访问元素比用下标来访问更有效率的原因. 消耗主要在访问下一个元素的时候, 比如整型数组, 假设当前元素的位置是 0x00000004, 但是下一个元素的指针是 0x00000008, 如果用下标, 每次循环都要做一次下标值和 4 的乘法用于计算下一个元素的位置, 然后首元素的位置进行相加; 但是用指针的话只要在编译时使用一次乘法, 之后都使用加法即可. 也就是说, 在用循环不断遍历数组时, 最好使用指针, 更有效率. 但是用下标的可读性更好.

+   多维数组:

    +   存储顺序: 在 C 中, 多维数组的元素存储顺序按照最右边的下标率率先变化的原则, 称为行主序 (row major order).

## 2017 年 9 月 7 日

+ 许多机器以字为单位存储整数, 每个字一般由 2 个或 4 个字节组成.

+ 比如: 尽管一个字包含 4 个字节, 它仍然只有一个地址. 至于它的地址是它最左边那个字节的位置还是最右边那个字节的位置, 不同的机器有不同的规定. 另一个需要注意的硬件事项是 **边界对齐**. 在要求边界对齐的机器上, 整型值存储的起始位置只能是某些特定的字节, 通常是 2 或 4 的倍数.

+ 值和类型

  + 不能简单的通过检查一个值的位来判断它的类型. 值的类型并非值本身所固有的一种特性, 而是取决于它的使用方式.

+ NULL 指针:

  + 对一个 NULL 指针解引用是非法的. 在对指针进行解引用之前, 你必须先确保它并非 NULL 指针.

+ 后缀 ++ 操作符的优先级高于 * 操作符. (*cp++)

+ 指针运算:

  + 当一个指针和一个整数量执行算术运算时, 整数在执行加法运算前始终会根据合适的大小进行调整. 这个合适的大小就是指针所指向类型的大小. "调整" 就是把整数值和合适的大小相乘.

+ 关系运算:

  + 对指针执行关系运算也是有限制的, 用下列操作符:

    ```c
    <  <= > >=
    ```

    不过前提是它们都指向同一个数组中的元素.

  + **从这里开始都后面是重点, 将揭露一个事实:**

    先来看一个循环, 它用于清除一个数组中的元素:

    ```c
    #define N_VALUES 5
    float values[N_VALUES];
    float *vp;
    for (vp = &values[0]; vp < &values[N_VALUES]; )
      *vp++ = 0;
    ```

    + `&values[N_VALUES]` 指向的是数组最后一个元素后面的那个内存位置, 虽然在最后一次比较中, vp 也指向了这个位置, 但由于我们此时未对 vp 执行间接访问操作, 所以它是安全的. (使用 != 代替 < 也是可行的)

    现在考虑下面这个循环:

    ```c
    for (vp = &values[N_VALUES]; vp > &values[0]; )
      *--vp = 0;
    ```

    + 它和前面那个循环所执行的任务相同, 但是数组元素将以相反的次序清除. 我们让 vp 指向数组最后那个元素后面的内存位置, 但在对它进行间接访问之前先执行自减操作. 当 vp 指向数组第一个元素时, 循环终止, 不过这发生在第 1 个数组元素被清除之后.

    可能有人觉得 `*--vp` 不太好看, 写出下面的 "简化" 版本, **请注意问题就来了:**

    ```c
    for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--)
      *vp = 0;
    ```

    这个程序的问题就是: 在数组第 1 个元素被清除之后, vp 的值还将减去 1, 而接下去的一次比较运算是用于结束循环的. 但这就是问题所在: 比较表达式 `vp >= &values[0]` 的值是未定义的! 因为 vp 移到了数组的边界之外. **标准允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针进行比较, 但不允许与指向数组第 1 个元素之前的那个内存位置的指针进行比较.**

+ 总结: 

  + 无论是程序员还是计算机都无法通过值的位模式来判断它的类型. 类型是通过值的使用方法隐式确定的. 编译器能够保证值的声明和值的使用之间的关系是适当的, 从而帮助我们确定值的类型.
  + 指针运算只有作用于数组中其结果才是可以预测的. 对任何并非指向数组元素的指针进行算术运算是非法的. **如果一个指针减去一个整数后, 运算结果产生的指针所指向的位置在数组第一个元素之前, 那么它也是非法的. 加法运算稍有不同, 如果结果指针指向数组最后一个元素后面的那个内存位置仍是合法的(但是不能对这个指针执行间接访问操作), 不过再往后就不合法了.**
  + 如果两个指针并不是指向同一个数组的元素, 那么它们之间进行相减就是错误的.

+ 函数:

  + 函数的定义就是函数体的实现. 函数体就是一个代码块, 它在函数被调用时执行.
  + 把函数的类型和函数名分写两行纯属风格问题. 这种写法可以使我们在使用视觉或某些工具程序追踪源代码时更容易查找函数名.

+ ADT(abstract data type) 和黑盒:

  + 限制对模块的访问是通过 static 关键字的合理使用实现的, 它可以限制对那些并非接口的函数和数据的访问. (因为在一个文件中, static 将作用的数据和函数的链接属性由 external 变为 internal, 这样它们只能在定义它们的源文件中访问)

+ 递归:

  + C 通过运行时堆栈支持递归函数的实现.
  + 当递归函数调用自身时, 每进行一次新的调用, 都将在堆栈上创建一批新的变量, 隐藏了前面的那批变量, 除非当前这次递归调用返回, 否则它们是不能被访问的.
  + **尾部递归 (tail recursion) 可以很方便的转换为一个简单的循环, 完成相同的任务.**
  + 许多问题是以递归的形式进行解释的, 这只是因为它比非递归形式更为清晰. 但是, 这些问题的迭代实现往往比递归实现效率更高.

## 2017 年 9 月 6 日

+ 变量的三个属性: **作用域**, **链接属性**, **存储类型**


+ 在 C 语言中, 仅有 4 种基本数据类型 -- 整型, 浮点型, 指针和聚合类型 (如数组和结构等). 所有其他的类型都是从这 4 中基本类型的某种组合派生而来.

+ 整型:

  ```cpp
  // 类型   最小范围
  char 0 - 127;
  unsigned char 0 - 255;
  signed char -127 - 127;
  short int -32767 - 32767;
  unsigned short int 0 - 65535;
  int -32767 - 32767;
  unsigned int 0 - 65535;
  long int -2147483647 - 2147483647;
  unsigned long int 0 - 4294967295;
  ```

  + 整数也可以用八进制来表示, 只要在数值前面以 0 开头. 如果以十六进制表示, 它以 0x 开头.

+ 浮点型:

  + 浮点数字面值在缺省情况下都是 double 类型的, 除非它的后面跟一个 L 或 l 表示它是一个 long double 类型的值, 或者跟一个 F 或 f 表示它是一个 float 类型的值.

+ 字符串常量:

  + C 语言存在字符串的概念: 它就是一串以 NUL 字节('\0') 结尾的零个或多个字符. 
  + 字符串通常存储在字符数组中, 这也是 C 语言没有显式的字符串类型的原因.
  + **在程序中使用字符串常量会生成一个"指向字符的常量指针". 当一个字符串常量出现在一个表达式中时, 表达式所使用的值就是这些字符所存储的地址, 而不是字符本身**. 因此, 你可以把字符串常量赋值给一个 "指向字符的指针", 后者指向这些字符所存储的地址. 但是, **你不能把字符串常量赋值给一个字符数组, 因为字符串常量的直接值是一个指针, 而不是这些字符本身.**

+ typedef

  + 你应该使用 typedef 而不是 `#define` 来创建新的类型名, 因为后者无法正确处理指针类型. 例如:

    ```c
    #define d_ptr_to_char char*
    d_ptr_to_char a, b;
    ```

    正确声明了 a, 但是 b 却被声明为一个字符. 在定义更为复杂的类型的名字时, 如函数指针或指向数组的指针, 使用 typedef 更为合适.

+ 常量

  + 注意, 在 C 语言中下面的声明等价:

    ```c
    int const a = 15;
    const int a = 15;
    ```

    + 在函数中声明为 const 的形参在函数被调用时会得到实参的值.

  + `#define` 是另一种创建名字常量的机制: (不需要分号)

    ```c
    #define MAX_VALUES 50
    ```

+ 链接属性

  + **标识符的链接属性决定如何处理在不同文件中出现的标识符.** (标识符的作用域与它的链接属性有关, 但这两个属性并不相同)
  + 链接属性一共有 3 种 -- external, internal, none. 没有链接属性的标识符(none) 总是被当做单独的个体, 也就是说该标识符的多个声明都被当作独立不同的实体. 属于 internal 链接属性的标识符在同一个源文件内的所有声明都指向同一个实体, 但是位于不同源文件的多个声明则分属不同的实体. 最后, 属于 external 链接属性的标识符不论声明多少次, 位于几个源文件都表示同一个实体.
  + extern 和 static 用于在声明中修改标识符的链接属性. 如果某个声明在正常情况下具有 external 链接属性, 在它前面加上 static 关键字可以使它的链接属性变为 internal. (static 只对缺省链接属性为 external 的声明才有改变链接属性的效果)
  + extern 关键字的规则更为复杂, 一般而言 它为标识符指定 external 链接属性, 这样就可以在其他任何位置定义的这个实体.

+ 存储类型:

  + 变量的存储类型是指存储变量值的内存类型. **变量的存储类型决定变量何时创建, 何时销毁以及它的值将保持多久.** 有三个地方可以用于存储变量: 普通内存, 运行时堆栈, 硬件寄存器.
  + 变量的缺省存储类型取决于它的声明位置.
  + 静态变量在程序运行之前创建, 在程序的整个执行期间始终存在. 它始终保持原先的值, 除非给它赋一个不同的值或者程序结束.

+ 初始化:(详情请看书)

  + 自动变量和静态变量的初始化存在一个重要差别: 在静态变量的初始化中, 我们可以把可执行程序文件**想要初始化的值**放在当程序执行时**变量将会使用的位置**. 当可执行文件载入内存时, 这个已经**保存了正确初始值的位置**将赋值给那个变量. 完成这个任务并不需要额外的时间, 也不需要额外的指令, 变量将会得到正确的值. 如果不显式指定其初始值, 静态变量将初始化为 0.
  + **这里详细看一下, 才明白为何自动变量没有显式初始化的话, 它们的值总是垃圾的原因:** 自动变量的初始化需要更多的开销, 因为当程序链接时还无法判断自动变量的存储位置. 事实上, 函数的局部变量在函数的每次调用中可能占据不同的位置. 基于这个理由, 自动变量没有缺省的初始值, 而显式的初始化将在代码块的起始处插入一条隐式的赋值语句. 这种技巧造成 4 种后果:
    + 首先, 自动变量的初始化较之赋值语句效率并无提高. 除了声明为 const 的变量之外,在声明变量的同时进行初始化和先声明后赋值只有风格差别, 并无效率之别.
    + 其次, 这条隐式的赋值语句使自动变量在程序执行到它们所声明的函数 (或代码块) 时, 每次都将重新初始化. 这个行为与静态变量大不相同, 后者只是在程序开始执行前初始化一次.
    + 第三个后果则是个优点, 由于初始化在运行时执行, 你可以用任何表达式作为初始值.
    + 最后一个后果是, 除非你对自动变量进行显示的初始化, 否则当自动变量创建时, 它们的值总是垃圾.

+ 语句:

  + C 并不具备布尔类型, 而是用整型来代替.

+ while 语句, 空语句:

  + 偶尔, while 语句在表达式中就可以完成整个语句的任务, 于是循环体就无事可做. 在这种情况下, 循环体就用空语句来表示.

+ 移位操作符

  + 右移位操作存在一个左移位操作不曾面临的问题: 从左边移入新位时, 可以选择两种方案.
    + 逻辑移位: 左边移入的位用 0 填充;
    + 算术移位: 左边移入的位由原先该值的符号位决定, 符号位为 1则移入的位均为 1, 符号位为 0 则移入的位均为 0.

+ sizeof 也是一个单目操作符. 比如:

  ```c
  sizeof(int)   sizeof x
  ```

  sizeof 判断它的操作数的类型长度, 以字节为单位表示. 操作数既可以是个表达式(常常单个变量), 也可以是两边加上括号的类型名.

  另外, 判断表达式的长度并不需要对表达式进行求值, 所以

  ```c
  sizeof(a = b + 1);
  ```

  并没有对 a 进行赋值.

+ (类型) 也是单目操作符, 强制类型转换. `(float)a`.

+ 复杂表达式的求值顺序是由 3 个因素决定的: 操作符的优先级, 操作符的结合性以及操作符是否控制执行的顺序. 

  + 对于第三点, 比如 &&, ||, ?:, 逗号运算符等会控制运算顺序.