# Pointers on C

## 2017 年 9 月 6 日

+ 变量的三个属性: **作用域**, **链接属性**, **存储类型**


+ 在 C 语言中, 仅有 4 种基本数据类型 -- 整型, 浮点型, 指针和聚合类型 (如数组和结构等). 所有其他的类型都是从这 4 中基本类型的某种组合派生而来.

+ 整型:

  ```cpp
  // 类型   最小范围
  char 0 - 127;
  unsigned char 0 - 255;
  signed char -127 - 127;
  short int -32767 - 32767;
  unsigned short int 0 - 65535;
  int -32767 - 32767;
  unsigned int 0 - 65535;
  long int -2147483647 - 2147483647;
  unsigned long int 0 - 4294967295;
  ```

  + 整数也可以用八进制来表示, 只要在数值前面以 0 开头. 如果以十六进制表示, 它以 0x 开头.

+ 浮点型:

  + 浮点数字面值在缺省情况下都是 double 类型的, 除非它的后面跟一个 L 或 l 表示它是一个 long double 类型的值, 或者跟一个 F 或 f 表示它是一个 float 类型的值.

+ 字符串常量:

  + C 语言存在字符串的概念: 它就是一串以 NUL 字节('\0') 结尾的零个或多个字符. 
  + 字符串通常存储在字符数组中, 这也是 C 语言没有显式的字符串类型的原因.
  + **在程序中使用字符串常量会生成一个"指向字符的常量指针". 当一个字符串常量出现在一个表达式中时, 表达式所使用的值就是这些字符所存储的地址, 而不是字符本身**. 因此, 你可以把字符串常量赋值给一个 "指向字符的指针", 后者指向这些字符所存储的地址. 但是, **你不能把字符串常量赋值给一个字符数组, 因为字符串常量的直接值是一个指针, 而不是这些字符本身.**

+ typedef

  + 你应该使用 typedef 而不是 `#define` 来创建新的类型名, 因为后者无法正确处理指针类型. 例如:

    ```c
    #define d_ptr_to_char char*
    d_ptr_to_char a, b;
    ```

    正确声明了 a, 但是 b 却被声明为一个字符. 在定义更为复杂的类型的名字时, 如函数指针或指向数组的指针, 使用 typedef 更为合适.

+ 常量

  + 注意, 在 C 语言中下面的声明等价:

    ```c
    int const a = 15;
    const int a = 15;
    ```

    + 在函数中声明为 const 的形参在函数被调用时会得到实参的值.

  + `#define` 是另一种创建名字常量的机制: (不需要分号)

    ```c
    #define MAX_VALUES 50
    ```

+ 链接属性

  + **标识符的链接属性决定如何处理在不同文件中出现的标识符.** (标识符的作用域与它的链接属性有关, 但这两个属性并不相同)
  + 链接属性一共有 3 种 -- external, internal, none. 没有链接属性的标识符(none) 总是被当做单独的个体, 也就是说该标识符的多个声明都被当作独立不同的实体. 属于 internal 链接属性的标识符在同一个源文件内的所有声明都指向同一个实体, 但是位于不同源文件的多个声明则分属不同的实体. 最后, 属于 external 链接属性的标识符不论声明多少次, 位于几个源文件都表示同一个实体.
  + extern 和 static 用于在声明中修改标识符的链接属性. 如果某个声明在正常情况下具有 external 链接属性, 在它前面加上 static 关键字可以使它的链接属性变为 internal. (static 只对缺省链接属性为 external 的声明才有改变链接属性的效果)
  + extern 关键字的规则更为复杂, 一般而言 它为标识符指定 external 链接属性, 这样就可以在其他任何位置定义的这个实体.

+ 存储类型:

  + 变量的存储类型是指存储变量值的内存类型. **变量的存储类型决定变量何时创建, 何时销毁以及它的值将保持多久.** 有三个地方可以用于存储变量: 普通内存, 运行时堆栈, 硬件寄存器.
  + 变量的缺省存储类型取决于它的声明位置.
  + 静态变量在程序运行之前创建, 在程序的整个执行期间始终存在. 它始终保持原先的值, 除非给它赋一个不同的值或者程序结束.

+ 初始化:(详情请看书)

  + 自动变量和静态变量的初始化存在一个重要差别: 在静态变量的初始化中, 我们可以把可执行程序文件**想要初始化的值**放在当程序执行时**变量将会使用的位置**. 当可执行文件载入内存时, 这个已经**保存了正确初始值的位置**将赋值给那个变量. 完成这个任务并不需要额外的时间, 也不需要额外的指令, 变量将会得到正确的值. 如果不显式指定其初始值, 静态变量将初始化为 0.
  + **这里详细看一下, 才明白为何自动变量没有显式初始化的话, 它们的值总是垃圾的原因:** 自动变量的初始化需要更多的开销, 因为当程序链接时还无法判断自动变量的存储位置. 事实上, 函数的局部变量在函数的每次调用中可能占据不同的位置. 基于这个理由, 自动变量没有缺省的初始值, 而显式的初始化将在代码块的起始处插入一条隐式的赋值语句. 这种技巧造成 4 种后果:
    + 首先, 自动变量的初始化较之赋值语句效率并无提高. 除了声明为 const 的变量之外,在声明变量的同时进行初始化和先声明后赋值只有风格差别, 并无效率之别.
    + 其次, 这条隐式的赋值语句使自动变量在程序执行到它们所声明的函数 (或代码块) 时, 每次都将重新初始化. 这个行为与静态变量大不相同, 后者只是在程序开始执行前初始化一次.
    + 第三个后果则是个优点, 由于初始化在运行时执行, 你可以用任何表达式作为初始值.
    + 最后一个后果是, 除非你对自动变量进行显示的初始化, 否则当自动变量创建时, 它们的值总是垃圾.

+ 语句:

  + C 并不具备布尔类型, 而是用整型来代替.

+ while 语句, 空语句:

  + 偶尔, while 语句在表达式中就可以完成整个语句的任务, 于是循环体就无事可做. 在这种情况下, 循环体就用空语句来表示.

+ 移位操作符

  + 右移位操作存在一个左移位操作不曾面临的问题: 从左边移入新位时, 可以选择两种方案.
    + 逻辑移位: 左边移入的位用 0 填充;
    + 算术移位: 左边移入的位由原先该值的符号位决定, 符号位为 1则移入的位均为 1, 符号位为 0 则移入的位均为 0.

+ sizeof 也是一个单目操作符. 比如:

  ```c
  sizeof(int)   sizeof x
  ```

  sizeof 判断它的操作数的类型长度, 以字节为单位表示. 操作数既可以是个表达式(常常单个变量), 也可以是两边加上括号的类型名.

  另外, 判断表达式的长度并不需要对表达式进行求值, 所以

  ```c
  sizeof(a = b + 1);
  ```

  并没有对 a 进行赋值.

+ (类型) 也是单目操作符, 强制类型转换. `(float)a`.

+ 复杂表达式的求值顺序是由 3 个因素决定的: 操作符的优先级, 操作符的结合性以及操作符是否控制执行的顺序. 

  + 对于第三点, 比如 &&, ||, ?:, 逗号运算符等会控制运算顺序.