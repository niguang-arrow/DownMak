# Introduction 2

## 2017 年 8 月 10 日

### 第 15 章 面向对象程序设计

+   面向对象程序设计基于三个基本概念: 数据抽象, 继承和动态绑定. 数据抽象在第 7 章已经介绍过, 本章介绍继承和动态绑定. 继承和动态绑定对程序的编写有两方面的影响: 一是我们可以更容易的定义与其他类相似但不完全相同的新类; 而是在使用这些彼此相似的类编写程序时, 我们可以在一定程度上忽略掉它们的区别.

+   OOP

    +   继承 (inheritance) 基类 (base class) 派生类 (derived class)

    +   在 C++ 语言中, 基类将类型相关的函数与派生类不做改变直接继承的函数区分对待. 对于某些函数, 基类希望它的派生类各自定义适合自身的版本, 此时基类就将这些函数声明为虚函数 (virtual function). 

    +   派生类必须通过使用类派生列表 (class derivation list) 明确指出它是从哪个(哪些)基类继承而来的. 类派生列表的形式是: 首先是一个冒号, 后面紧跟逗号分隔的基类列表, 其中每个基类前面可以有访问说明符.

    +   派生类必须在其内部对所有重新定义的虚函数进行声明. 使用 override 关键字显式注明它将使用哪个成员函数改写基类的虚函数.

    +   由于函数的运行版本由实参决定, 即在运行时选择函数的版本, 所以动态绑定有时又被称为运行时绑定.

    +   目前只需记住 **作为继承关系中根节点的类通常都会定义一个虚析构函数**

        ```cpp
        virtual ~Quote() = default;  // 对析构函数进行动态绑定
        ```

    +   成员函数与继承

        +   在 C++ 中, 基类必须将它的两种成员函数区分开来: 一种是基类希望派生类进行覆盖的函数; 另一种是基类希望派生类直接继承而不要改变的函数. 对于前者, 基类通常将其定义为**虚函数**. 任何构造函数之外的非静态函数都可以是虚函数.
        +   成员函数如果没有被声明为虚函数, 则其解析过程发生在编译时而非运行时. 比如书中的 `isbn()` 函数, 不管对于基类对象还是派生类对象, `isbn` 函数的行为都是一样的.

    +   访问控制与继承

        +   派生类可以继承定义在基类中的成员, 但是派生类的成员函数不一定有权访问从基类继承而来的成员. 和其他使用基类的代码一样, 派生类能访问公有成员, 而不能访问私有成员. 不过在某些时候基类中还有这样一种成员, 基类希望它的派生类有权访问该成员, 同时禁止其他用户访问. 我们用 protected 访问运算符说明这样的成员.

    +   定义派生类

        +   派生类必须通过使用**类派生列表**明确指出它是从哪个(哪些)基类继承而来的.
        +   派生类**必须**将其继承而来的成员函数中需要覆盖的那些**重新声明**;
        +   访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见.

    +   派生类对象以及派生类向基类的类型转换

        +   因为在派生类对象中含有与其基类对应的组成部分, 所以我们能把派生类的对象当成基类对象来使用, 而且我们也能把基类指针或引用绑定到派生类对象中的基类部分上.

            ```cpp
            // 书上 530 页的例子
            Quote item;
            Bulk_quote bulk;
            Quote *p = &item;  // p 指向 Quote 对象
            p = &bulk; // p 指向 bulk 的 Quote 部分
            Quote &r = bulk; // r 绑定到 bulk 的 Quote 部分
            ```

            +   这种转换通常称为 **派生类到基类的** 类型转换.

    +   派生类的构造函数

        +   派生类必须使用基类的构造函数来初始化它的基类部分. (使用构造函数初始化列表)
        +   除非我们特别指出, 否则派生类对象的基类部分会像数据成员一样执行默认初始化.
            +   **首先初始化基类的部分, 然后按照声明的顺序依次初始化派生类的成员.**

    +   派生类使用基类的成员

        +   派生类可以访问基类的公有成员和受保护成员
        +   关于作用域: **目前只需了解派生类的作用域嵌套在基类的作用域之中**

    +   继承与静态成员

        +   如果基类定义了一个静态成员, 则整个继承体系中只存在该成员的唯一定义. 不论从基类中派生出来多少个派生类, 对于每个静态成员来说都只存在唯一的实例.
        +   假设某静态成员是可访问的, 则我们既能通过基类使用它也能通过派生类使用它.

### 第 14 章 重载运算符与类型转换

+   重载的运算符是具有特殊名字的函数: 它们的名字由关键字 operator 和其后要定义的运算符号共同组成. 和其他函数一样, 重载的运算符也包含返回类型, 参数列表以及函数体.

+   对一个运算符函数来说, 它或者是类的成员, 或者至少含有一个类类型的参数:

    ```cpp
    // 错误: 不能为 int 重定义内置的运算符
    int operator+(int, int);
    ```

    这一约定意味着当运算符作用域内置类型的运算对象时, 我们无法改变该运算符的含义.

    +   我们只能重载运算符, 而无权发明新的运算符.

+   直接调用一个重载的运算符函数:

    ```cpp
    // 一个非成员运算符函数的等价调用
    data1 + data2;
    operator+(data1, data2);

    // 对成员运算符的等价调用
    data1 += data2;
    data1.operator+=(data2);
    ```

+   使用与内置类型一致的含义:

    +   如果类执行 IO 操作, 则定义移位运算符使其与内置类型的 IO 保持一致;
    +   如果类的某个操作是检查相等性, 则定义 `operator==`
    +   如果类包含一个内在的单序比较操作, 则定义 `operator<`; 如果类有了 `operator<`, 则它也应该含有其他关系操作.
    +   重载运算符的返回类型通常应该和其内置版本的返回类型兼容: 逻辑运算符和关系运算符应该返回 bool; 算术运算符应该返回一个类类型的值; 赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用.

+   重载输出运算符 `<<`

    +   通常情况下, 输出运算符的第一个形参是一个非常量 ostream 对象的引用. 之所以 ostream 是非常量是因为向流中写入内容会改变其状态; 而该形参是引用是因为我们无法直接复制一个 ostream 对象. 第二个形参一般来说是一个常量引用. 为了与其他输出运算符保持一致, `operator<<` 一般要返回它的 ostream 形参.
    +   输出运算符尽量减少格式化操作. (最好不要打印出换行符)
    +   **输入输出运算符必须是非成员函数**: 如果它们是类的成员函数, 它们的左侧运算对象将是我们的类的一个对象. **由于 IO 运算符通常需要读写类的非公有数据成员, 所以 IO 运算符一般被声明为友元.**

+   重载输入运算符 `>>`

    +   通常情况下, 输入运算符的第一个形参是运算符将要读取的流的引用, 第二个参数是将要读入到的 (非常量) 对象的引用. 该运算符通常会返回某个给定流的引用. 第二个形参之所以必须是非常量是因为输入运算符本身的目的就是将数据读入到这个对象中.

+   算术和关系运算符

    +   通常情况下, 我们把算术和关系运算符定义为非成员函数以允许对左侧或右侧的运算对象进行转换. 因为这些运算符一般不需要改变运算对象的状态, 所以形参都是常量的引用.

+   相等运算符

    +   通常情况下, C++ 中的类通过定义相等运算符来检验两个对象是否相等. 也就是说, 它们会比较对象的每一个数据成员, 只有当所有对应的成员都相等时才认为两个对象相等.
    +   如果类定义了 `operator==`, 则这个类也应该定义 `operator!=`. 相等运算符和不相等运算符中的一个应该把工作委托给另一个, 这意味着其中一个运算符应该负责实际比较对象的工作, 而另一个运算符则只是调用那个真正工作的运算符.

+   关系运算符

    +   定义了相等运算符的类常常(但不总是)包含关系运算符. **特别是, 因为关联容器和一些算法要用到小于运算符, 所以定义 operator< 会比较有用.**

+   赋值运算符

    +   之前已经介绍了拷贝赋值和移动赋值运算符. 它们可以把类的一个对象赋给该类的另一个对象. 此外, 类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象.

+   复合赋值运算符

    +   复合赋值运算符不非得是类的成员, 不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部.

+   下标运算符

    +   表示容器的类通常可以通过元素在容器中的位置访问元素, 这些类一般会定义下标运算符 `operator[]`
    +   为了与下标原始定义兼容, 下标运算符通常以访问元素的引用作为返回值, 这样的好处是下标可以出现在赋值运算符的任意一端. 我们最好同时定义下标运算符的常量版本和非常量版本, 当作用于一个常量对象时, 下标运算符返回常量引用以确保我们不会给返回的对象赋值.

+   递增递减运算符

    +   在迭代器类中通常会实现递增运算符 (++) 和递减运算符 (--), 这两种运算符使得类可以在元素的序列中前后移动. C++ 并不要求递增递减运算符必须是类的成员, 但是因为它们改变的正好是操作对象的状态, 所以建议将其设定为成员函数.

    +   定义递增递减运算符的类应该同时定义前置版本和后置版本.

        ```cpp
        class StrBlobPtr {
        public:
          // 前置运算符
          StrBlobPtr& operator++();
          StrBlobPtr& operator--();
          
          // 后置运算符
          StrBlobPtr operator++(int);
          StrBlobPtr operator--(int);
        };
        ```

        +   **区分前置和后置运算符**: 后置版本接受一个额外的 (不被使用) int 类型的形参. 因为我们不会用到 int 形参, 所以无须为其命名 (即使在函数定义时.)
        +   可以先实现前置版本, 而后置版本可以调用前置版本来完成实际的工作. 
        +   显式调用后置运算符

        ```cpp
        StrBlobPtr p(a1); // p 指向 a1 中的 vector
        p.operator++(0);  // 调用后置版本的 operator++
        p.operator++(); // 调用前置版本的 operator++
        ```

        +   尽管传入的值通常会被运算符函数忽略, 但却并不可少. 因为编译器只有通过它才能知道应该使用后置版本.

+   成员访问运算符

    +   箭头运算符必须是类的成员. 解引用运算符通常也是类的成员, 尽管并非必须如此.

        ```cpp
        string& operator*() const;
        string* operator->() const;
        ```

+   函数调用运算符

    +   **如果类重载了函数调用运算符, 则我们可以像使用函数一样使用该类的对象.** 因为这样的类同时也能存储状态, 所以与普通函数相比它们更加灵活.
    +   函数调用运算符必须是成员函数, 一个类可以定义多个不同版本的调用运算符, 相互之间应该在参数数量或类型上有所区别. 如果类定义了调用运算符, 则该类的对象称作 **函数对象** (function object). 因为可以调用这种对象, 所以我们说这些对象的 "行为像函数一样".
    +   函数对象常常作为泛型算法的实参.

+   lambda 是函数对象

    +   当我们编写一个 lambda 后, 编译器将该表达式翻译为一个未命名类的未命名对象.

+   标准库定义的函数对象

    +   标准库定义了一组表示算术运算符, 关系运算符和逻辑运算符的类, 每个类分别定义了一个执行命名操作的调用运算符. 这些类都被定义为模板的形式, 我们可以为其指定具体的应用类型. 所有的类型定义在 `#include <functional>` 头文件中.

    +   在算法中使用标准库函数对象

        +   表示运算符的函数对象类常用来替换算法中的默认运算符. 

        +   比如, 默认情况下, 排序算法使用 `operator<` 将序列按升序排列. 如果要执行降序排列的话, 我们可以传入一个 greater 类型的对象.

            ```cpp
            // 传入一个临时的函数对象用于执行两个 string 对象的 > 比较运算
            // svec 为 vector<string>
            sort(svec.begin(), svec.end(), greater<string>());
            ```

        +   **需要注意的是:** 标准库规定其函数对象对于指针同样适用. 前面介绍过, 直接比较两个无关指针将产生未定义的行为, 然而, 我们可能会希望通过比较指针的内存地址来 sort 指针的 vector. 直接这么做将产生未定义的行为, 因此我们可以使用一个标准库函数对象来实现该目的:

            ```cpp
             vector<string *> nameTable;  // 指针的 vector
            // 错误: nameTable 中的指针彼此之间没有关系, 
            // 所以 < 将产生未定义的行为
            sort(nameTable.begin(), nameTable.end(), 
                 [](string *a, string *b) { return a < b; });
            // 正确: 标准库规定指针的 less 是定义良好的
            sort(nameTable.begin(), nameTable.end(), less<string *>());
            ```

            +   关联容器使用 `less<key_type>` 对元素进行排序, 因此我们可以定义一个指针的 set 或者在 map 中使用指针作为关键值而无须直接声明 less.

+   可调用对象与 function

    +   C++ 中有几种可调用的对象: 函数, 函数指针, lambda 表达式, bind 创建的对象以及重载了函数调用运算符的类.
    +   和其他对象一样, 可调用的对象也有类型, 例如, 每个 lambda 有它自己唯一的(未命名)类类型; 函数以及函数指针的类型由其返回值类型和实参类型决定. 但是两个不同的类型的可调用对象却可能共享同一种**调用形式** (call signature). 调用形式指明了调用返回的类型以及传递给调用的实参类型. 一种调用形式对应一个函数类型, 例如: `int(int, int)` 是一个函数类型, 它接受两个 int, 返回一个 int. (总之就是**不同类型可能具有相同的调用形式**)

+   标准库 function 类型

    +   定义在 `#include <functional>` 头文件中

    +   尽管可调用对象的类型各不相同, 但是我们仍然能够把这些类型都存储在同一个 `function<int (int, int)>` 类型中.

        ```cpp
        map<string, function<int(int, int)>> binops = {
          {"+", add},  // add 是函数指针
          {"-", std:minus<int>}, // 标准库函数对象
          {"/", divide()},  // divide 是用户定义的函数对象
          {"*", [](int i, int j) { return i * j; }}, // 未命名的 lambda
          {"%", mod}  // mod 是命名的 lambda 对象
        };

        binops["+"](10, 5);  // 调用 add(10, 5)
        binops["-"](10, 5);  // 使用minus<int>对象调用运算符
        ```

    +   重载的函数与 function

        我们不能 (直接) 将重载函数的名字存入 function 类型的对象中.

        ```cpp
        int add(int i, int j) { return i + j; }
        Sales_data add(const Sales_data&, const Sales_data&);
        map<string, function<int(int, int)>> binops;
        binops.insert({"+", add}); // 错误: 哪个 add?
        ```

        解决上面二义性的问题的两个方法分别是:

        1.  使用存储函数指针而非函数名字: `int (fp*)(int, int) = add;`, 然后存入 fp;
        2.  使用 lambda 函数.

+   重载, 类型转换与运算符

    +   转换构造函数和类型转换运算符共同定义了类类型转换 (class-type conversions). 这样的转换有时也称为用户定义的类型转换.

+   类型转换运算符 (conversion operator)

    +   它是类的一种特殊成员函数, 它负责将一个类类型的值转换为其他类型, 其一般形式如下:

        ```cpp
        operator type() const;
        ```

        +   其中 type 表示某种类型. 类型转换运算符可以面向任意类型 (除了 void 之外) 进行定义, 只要该类型能作为函数的返回类型. 因此, 我们不允许转换为数组或函数类型, 但是允许转换成指针(包括数组指针以及函数指针)或者引用类型.
        +   类型转换运算符既没哟显式的返回类型, 也没有形参, 而且必须定义为类的成员函数. 类型转换运算符通常不应该改变待转换对象的内容, 因此, 类型转换运算符通常定义为 const 成员.

    +   显式的类型转换运算符

        +   使用 `explicit` 关键字

+   **转换为 bool**

    +   在 C++11 新标准下, IO 标准库通过定义一个向 bool 的显式类型转换防止出现意外结果.

    +   无论我们什么时候在条件(如 while, if 等条件判断部分)中使用流对象, 都会使用为 IO 类型定义的 operator bool.

        ```cpp
        while (std::cin >> value)
        ```

        while 语句的条件执行输入运算符, 它负责将数据读入到 value 中并返回 cin. **为了对条件求值, cin 被 istream operator bool 类型转换函数隐式地执行了转换. 如果 cin 的条件状态是 good, 则该函数返回为真; 否则该函数返回为假.** 

        注意: 向 bool 的类型转换通常用在条件部分, 因此 `operator bool` 一般定义为 explicit 的.

+   避免有二义性的类型转换

    +   如果类中包含一个或多个类型转换, 则必须确保在**类类型**和**目标类型**之间只存在唯一一种转换方式. 否则的话, 我们编写的代码很可能会具有二义性.

+   重载函数与转换构造函数

    +   总之就是要防止二义性

+   函数匹配与重载运算符

    +   重载的运算符也是重载的函数.

    +   如果 a 是一种类型, 则表达式 `a sym b` 可能是:

        ```cpp
        a.operatorsym(b); // a 有一个 operatorsym 成员函数
        operatorsym(a, b); // operatorsym 是一个普通函数
        ```

    +   总之就是要防止二义性

    +   如果我们对同一个类既提供了转换目标是算术类型的类型转换, 也提供了重载运算符, 则将会遇到重载运算符与内置运算符的二义性问题.

### 习题

+   习题 14.38: 编写一个类令其检查某个给定的 string 对象的长度是否与一个阈值相等. 使用该对象编写程序, 统计并报告在输入的文件中长度为 1 的单词有多少个, 长度为 2 的单词有多少个, ..., 长度为 10 的单词有多少个.

    ```cpp
    #include <iostream>
    #include <fstream>
    #include <sstream>
    #include <string>
    #include <iterator>

    using namespace std;

    class Compare {
    public:
        Compare() : sz(0) {}
        Compare(size_t n) : sz(n) {}
        bool operator()(const string &s) {
            return s.size() == sz;
        }
    private:
        size_t sz;
    };

    int main(int argc, const char *argv[]) {
        if (argc > 1) {
            fstream in(argv[1]);
            if (in.is_open()) {
                string line, word;
                int array[10] = {};
                while (getline(in, line)) {
                    istringstream istr(line);
                    while (istr >> word)
                        array[word.size() - 1] += 1;
                }
                for (auto p = 0; p != end(array) - begin(array); ++p)
                    cout << "character number " << p + 1 << " : " << array[p] << endl;
            }
            in.close();
        }
    }

    // 我写的, 没用到 Compare 来进行统计
    // ./main file (运行程序时要加上文件名)
    // 参考答案使用了 count_if, 估计来自 #include <algorithm>
    ```

+   **习题 14.41: 你认为 C++11 新标准为什么要增加 lambda? 对于你自己来说, 什么情况下会使用 lambda, 什么情况下会使用类?**

    +   **在 C++11 中, lambda 是通过匿名的函数对象来实现的, 因此我们可以把 lambda 看作是对函数对象在使用方式上进行的简化.**
    +   **当代码需要一个简单的函数, 并且这个函数并不会在其他地方被使用时, 就可以使用 lambda 来实现, 此时它所起的作用类似于匿名函数.**
    +   **但如果这个函数需要多次使用, 并且它需要保存某些状态的话, 使用函数对象更适合一些.**

### 合成的移动操作

+   与拷贝操作不同, 移动操作永远不会隐式定义为删除的函数. 但是, 如果我们显式要求编译器生成 `=default` 的移动操作, 且编译器不能移动所有成员, 则编译器会将移动操作定义为删除的函数.

    ```cpp
    // 假定 Y 是一个类, 它定义了自己的拷贝构造函数但未定义自己的移动构造函数
    struct hasY {
      hasY() = default;
      hasY(hasY&&) = default;
      Y mem; // hasY 将有一个删除的移动构造函数
    };
    hasY hy1, hy2 = std::move(hy1);// 错误, 移动构造函数是删除的
    ```

    移动操作和合成的拷贝控制成员还有最后一个相互作用的关系: 一个类是否定义了自己的移动操作对拷贝操作如何合成有影响. 如果类定义了一个移动构造函数和/或一个移动赋值运算符, 则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的. (**也就是说, 定义了一个移动构造函数或移动赋值运算符的类必须定义自己的拷贝操作, 否则, 这些成员默认被定义为删除的**).

+   移动右值, 拷贝左值...

    +   如果一个类既有移动构造函数, 也有拷贝构造函数, 编译器使用普通的函数匹配规则来确定使用哪个构造函数. 

    +   比如在 StrVec 类中, 拷贝构造函数接受一个 const StrVec 的引用, 因此它可以用于任何可以转换为 StrVec 的类型. 而移动构造函数接受一个 `StrVec&&`, 因此只能用于实参是右值 (非 static) 的情形:

        ```cpp
        StrVec v1, v2;
        v1 = v2;  // v2 是左值; 使用拷贝赋值
        StrVec getVec(istream &); // 注意 getVec 返回一个右值
        v2 = getVec(cin); // 此处赋值给 v2 调用的移动赋值构造函数, 因为 getVec 返回右值
        ```

        +   注意虽然第二个赋值中, 两种赋值运算符(拷贝和移动)都是可行的,  但是调用拷贝赋值运算符需要调用一次到 const 的转换, 而 `StrVec&&` 则是精确匹配.

+   如果没有移动构造函数, 右值也被拷贝

    +   如果一个类有一个拷贝构造函数但未定义移动构造函数, 在此情况下, 编译器不会合成移动构造函数. 此时该类将有拷贝构造函数但不会有移动构造函数. 如果一个类没有移动构造函数, 函数匹配规则保证该类型的对象会被拷贝, 即使我们试图通过调用 move 来移动它们也是如此.

        ```cpp
        class Foo {
        public:
          Foo() = default;
          Foo(const Foo&);
        };
        Foo x;
        Foo z(std::move(x));
        ```

        +   在对 z 进行初始化时, 我们调用了 `move(x)`, 它返回一个绑定到 x 的 `Foo&&`, Foo 的拷贝构造函数是可行的, 因为我们可以将 `Foo&&` 转换为一个 `const Foo&`.

+   拷贝并交换赋值运算符和移动操作

    如果我们为 HasPtr 类 (453 页)添加一个移动构造函数, 它实际上也会获得一个移动赋值运算符.

    ```cpp
    class HasPtr {
    public:
      // 添加的移动构造函数
      HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) { p.ps = nullptr; }
      // 赋值运算符既是移动赋值运算符, 也是拷贝赋值运算符
      HasPtr& operator=(HasPtr rhs)
        { swap(*this, rhs); return *this; }
      // 其他成员的定义同 453 页
    };

    hp = hp2; // 使用拷贝构造函数来拷贝
    hp = std::move(hp2);  // 使用移动构造函数来移动 hp2
    ```

    +   注意第二个赋值中, 我们调用 `std::move` 将一个右值引用绑定到 `hp2` 上. 由于实参是一个右值引用, 移动构造函数是精确匹配的. 移动构造函数从 hp2 拷贝指针, 而不会分配任何内存.

+   建议: 更新 3/5 法则

    +   五个拷贝控制成员应该看做一个整体, 一般来说, 如果一个类定义了任何一个拷贝操作, 它就应该定义所有的五个操作.

+   移动迭代器

    +   一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配次迭代器. 一般来说, 一个迭代器的解引用运算符返回一个指向元素的左值. 与其他迭代器不同, **移动迭代器的解引用运算符生成一个右值引用.**

    +   我们通过调用标准库的 `make_move_iterator` 函数将一个普通迭代器转换为一个移动迭代器. 此函数接受一个迭代器参数, 返回一个移动迭代器.

    +   比如 StrVec 的 reallocate 成员中使用了一个 for 循环来调用 construct 从旧内存中将元素拷贝到新内存中. 作为一种替换方法, 我们也能用 `uninitialized_copy` 来构造新分配的内存. 但是该函数是对元素进行拷贝操作, 而标准库中并没有类似的函数将对象移动到未构造的内存中. 但是我们可以通过将移动迭代器传递给该函数:

        ```cpp
        // 469 页使用 for 循环写的 reallocate 成员
        void StrVec::reallocate() {
          // 分配当前大小两倍的内存空间
          auto newcapacity = size() ? 2 * size() :  1;
          // 分配新内存
          auto newdata = alloc.allocate(newcapacity);
          // 将数据从旧内存移动到新内存
          auto dest = newdata; // 指向新内存中下一个空闲位置
          auto elem = elements; // 指向旧数组下一个元素
          for (size_t i = 0; i != size(); )
            alloc.construct(dest++, std::move(*elem++));
          free();  // 一旦移动完元素就释放旧内存
          // 更新数据结构
          elements = newdata;
          first_free = dest;
          cap = elements + newcapacity;
        }

        // 对 uninitialized_copy 使用移动迭代器
        void StrVec::reallocate() {
          // 分配当前大小两倍的内存空间
          auto newcapacity = size() ? 2 * size() :  1;
          // 分配新内存
          auto first = alloc.allocate(newcapacity);
          // 移动元素
          auto last = uninitialized_copy(make_move_iterator(begin()),
                                        make_move_iterator(end()),
                                        first);
          free();  // 释放旧内存
          elements = first;
          first_free = last;
          cap = elements + newcapacity;
        }
        ```

+   **建议: 不要随意使用移动操作**

    +   由于移后源对象具有不确定的状态, 对其调用 `std::move` 是危险的. 当我们调用 move 时, 必须绝对确认移后源对象没有其他用户. 通过在类代码中小心的使用 move, 可以大幅度提升性能, 而如果随意在普通用户代码中使用移动操作, 很可能导致莫名其妙的, 难以查找的错误. 因此, 在移动构造函数和移动赋值运算符这些类实现代码之外的地方, 只有当你确信需要进行移动操作且移动操作是安全的, 才可以使用 `std::move`.

+   右值引用和成员函数

    +   允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式 -- 一个版本接受一个指向 const 的左值引用, 第二个版本接受一个指向非 const 的右值引用. 区分移动和拷贝的重载函数通常有一个版本接受一个 `const T&`, 而另一个版本接受一个 `T&&`.

+   右值和左值引用成员函数

    +   对右值进行了赋值

        ```cpp
        string s1 = "a", s2 = "b";
        s1 + s2 = "wow!"; // 对右值进行了赋值
        ```

        +   在旧标准中, 我们没有办法阻止这种使用方式. 为了维持向后兼容性, 新标准库类仍然允许向右值赋值. 但是我们可能希望在自己的类中阻止这种用法. **在此情况下, 我们希望强制左侧运算对象是一个左值(即, this 指向的对象是一个左值)**.

    +   我们指出 this 的左值/右值属性的方式与定义 const 成员函数相同, 即在参数列表后放置一个**引用限定符** (Reference qualifier):

        ```cpp
        class Foo {
        public:
          Foo &operator=(const Foo&) &;  // 只能向可修改的左值赋值
        };

        Foo& Foo::operator=(const Foo &rhs) & {
          // 执行将 rhs 赋予本对象所需的工作
          return *this;
        }
        ```

    +   引用限定符可以是 `&` 或 `&&`, 分别指出 this 可以指向一个左值或右值. 类似 const 限定符, 引用限定符只能用于成员函数 (非 static), 且必须同时出现在函数的声明和定义中.

    +   对于 `&` 限定的函数, 我们只能将它用于左值; 对于 `&&` 限定的函数, 我们只能用于右值;

        ```cpp
        Foo& retFoo(); // 返回一个引用, retFoo 调用是一个左值
        Foo retVal(); // 返回一个值, retVal 调用是一个右值
        ```

    +   一个函数可以同时用 const 和引用限定. 在此情况下, 引用限定符必须跟随在 const 限定符之后:

        ```cpp
        class Foo {
        public:
          Foo someMem() & const; // 错误
          Foo anotherMem() const &;  // 正确L: const 限定符在前
        };
        ```

+   重载和引用函数

    +   引用限定符也可以区分重载版本, 而且, 我们可以综合引用限定符和 const 来区分一个成员函数的重载版本.

    +   如下面的例子:

        ```cpp
        class Foo {
        public:
          Foo sorted() &&;  // 可用于可改变的右值
          Foo sorted() const &;  // 可用于任何类型的 Foo
        private:
          vector<int> data;
        };
        // 本对象为右值, 因此可以原址排序
        Foo Foo::sorted() && {
          sort(data.begin(), data.end());
          return *this;
        }
        // 本对象是 const 或是一个左值, 哪种情况我们都不能对其进行原址排序
        Foo Foo::sorted() const & {
          Foo ret(*this); // 拷贝一个副本
          sort(ret.data.begin(), ret.data.end());
          return ret;  // 返回副本
        }

        retVal()::sorted();  // retVal() 是一个右值, 调用 Foo::sorted() &&
        retFoo()::sorted(); // retFoo() 是一个左值, 调用 Foo::sorted() const &
        ```

        +   **当我们对一个右值执行 sorted 时, 它可以安全地直接对 data 成员进行排序. 对象是一个右值, 意味着没有其他用户, 因此我们可以改变对象.** 
        +   当对一个 const 右值或是一个左值执行 sorted 时, 我们不能改变对象, 因此就需要在排序前拷贝 data.

    +   另外, 当我们定义 const 成员函数时, 可以定义两个版本, 唯一的差别是一个版本有 const 限定而另一个没有. **引用限定的函数则不一样. 如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数, 就必须对所有函数都加上引用限定符, 或者所有都不加**:

        ```cpp
        class Foo {
        public:
          Foo sorted() &&;
          Foo sorted() const;  // 错误: 必须加上引用限定符
        };
        ```

        ​