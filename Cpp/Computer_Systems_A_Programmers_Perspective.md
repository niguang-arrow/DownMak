# Computer Systems A Programmer's Perspective

## 2017 年 7 月 13 日

### 前言

+   对计算机的算术运算有深刻的理解是写出可靠程序的关键. 比如程序员和编译器不能使用表达式 `x - y < 0` 来*代替* `x < y`, 因为前者可能会产生溢出. 甚至于也不能用表达式 `-y < -x` 来代替, 因为在二进制补码表表示中负数和正数的范围是不对称的.

### 第一章 计算机系统漫游

+   像 `hello.c` 这样只由 ASCII 字符构成的文件称为文本文件, 所有其他文件都称为二进制文件.

+   源程序文件 `hello.c` $\rightarrow$ 可执行目标文件 `hello`: 经历四个阶段 (预处理器, 编译器, 汇编器, 链接器)

    ```bash
       hello.c    -->   cpp    -->      hello.i       -->   cc    -->    hello.s     -->   as     -->         hello.o         -->    ld     -->         hello
    (源程序, 文本)     (预处理器)    (被修改的源程序, 文本)     (编译器)     (汇编程序, 文本)     (汇编器)     (可重定位目标程序, 二进制)  |->  (链接器)       (可执行目标程序, 二进制)
                                                                                                                           printf.o
    ```

    可以使用 `gcc -c hello.c` 产生 `hello.o` 文件, 使用 `cpp -o hello.i hello.c` 产生 `hello.i` 文件.

+   典型系统硬件组织:

    ```bash
    CPU
    ++++++++++++++++++++++++++++++++++
    |         寄存器文件               |
    |          [-----]  >>>  [     ] |
    | [ PC ]   [-----]  <<<  [ ALU ] |   系统总线           存储器总线
    |          [-----]       [     ] |  /                     |
    |             ^                  | /                      | 
    |             V                  |/                       |
    |      [ 总线接口 ] <<<---------------->>> [ I/O 桥 ] <<<--------->>> [ 主存储器 ]
    |                                |            |
    ++++++++++++++++++++++++++++++++++            |
                                                  |
    <<<---------------------------------------------------------------||-||-||-------->>>
            |            |                     I/O 总线       |       扩展槽, 留待网络适配器
        	|            |                                   |       一类的设备使用
            [USB 控制器]  [图形适配器]                          [磁盘控制器]
    ```


+   CPU: 中央处理单元; ALU: 算术/逻辑单元; PC: 程序计数器; USB: 通用串行总线
    +   总线传送 字 (word); 字中的字节数 (称为字长) 是一个基本系统参数, 大多数机器字长有的是 4 个字节 (32位), 有的是 8 个字节 (64位).
    +   I/O 设备: 系统与外部世界联系的通道. 每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连. 控制器和适配器之间的区别主要是在于它们的封装方式: 控制器是置于 I/O 设备本身的或者系统的主板上的芯片组, 而适配器则是一块插在主板插槽上的卡. 它们的功能都是在 I/O 总线和 I/O 设备之间传递信息.
    +   主存: 临时存储设备, 在处理器执行程序时, 用来存放程序和程序处理的数据.
    +   CPU: 处理器的核心是一个字长的存储设备(或寄存器), 称为程序计数器 (PC). 在任何时刻, PC 都指向主存中的某条机器语言指令 (即含有该条指令的地址)
        +   寄存器文件 (register file) 是一个小的存储设备, 由一些 1 字长的寄存器组成. 每个寄存器都有唯一的名字
        +   ALU 计算新的数据和地址值
    +   利用直接存储器存取 (DMA) 技术, 数据可以不通过处理器而直接从磁盘到达主存.
    +   一旦目标文件 hello 中的代码和数据被加载到主存中, 处理器就开始执行 hello 程序的 main 程序中的机器语言指令. 这些指令将 "hello, world\n" 字符串中的字节从主存复制到寄存器文件, 再从寄存器文件中复制到显示设备, 最终显示在屏幕上.

+   高速缓存至关重要: 根据机械原理, 较大的存储设备要比较小的存储设备运行得慢, 而快速设备的造价远高于同类的低速设备. 处理器从寄存器文件中读数据的速度比从主存中读取几乎快 100 倍 (寄存器文件只存储几百字节的信息, 而主存里可以存放几十亿字节). 使用高速缓存存储器可以用来存放处理器近期可能会需要的信息. 位于处理器芯片上的 L1 高速缓存的容量可以达到数万字节, 访问速度几乎和访问寄存器文件一样快. 可以利用高速缓存将程序的性能提高一个数量级.

+   存储设备形成层次结构: (从上向下, 设备的访问速度越来越慢, 容量越来越大, 并且每个字节的造价页越来越便宜)

    ```bash
                	 _______________
                L0: /     寄存器     \
                   /_________________\
              L1: / L1 高速缓存 (SRAM) \
                 /_____________________\ 
            L2: /   L2 高速缓存 (SRAM)   \
               /________________________\
          L3: /     L3 高速缓存 (SRAM)    \
             /___________________________\
    	L4: /          主存 (DRAM)        \
           /______________________________\
      L5: /       本地二级存储 (本地磁盘)     \
         /_________________________________\
    L6: /             远程二级存储           \
       /      (分布式文件系统, Web 服务器)     \
      /_____________________________________\
    ```

+ 存储器层次结构的主要思想是: 一层上的存储器作为第一层存储器的高速缓存.


+   计算机系统的分层视图:

    ```bash
    ___________________________________
    [             应用程序              ]
    [             操作系统              ]
    [ 处理器 ]-----[ 主存 ]----[ I/O 设备]
    ```

+   操作系统提供的抽象表示

    ```bash
    [ 处理器 ]-----[ 主存 ]----[ I/O 设备]
                              +++++++++
                                 文件
                  +++++++++++++++++++++
                        虚拟存储器
    +++++++++++++++++++++++++++++++++++
                  进程            
    ```

    +   操作系统的两个基本功能:
        +   防止硬件被失控的应用程序滥用
        +   向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备
        +   操作系统通过进程, 虚拟存储器和文件几个抽象的概念来实现这两个功能.

+   虚拟存储器

+   系统之间利用网络通信: 网络也可以视为一个 I/O 设备.

### 第二章 信息的表示和处理

+   大端法和小端法

+   下面程序打印不同对象的字节表示:

    ```c
    #include <stdio.h>
    #include <string.h>

    typedef unsigned char *byte_pointer;

    void show_bytes(byte_pointer start, int len){
        int i;
        for (i = 0; i < len; i++)
            printf(" %.2x", start[i]); // %.2x 表示使用至少两个数字的十六进制格式输出.
        printf("\n");
    }

    void show_int(int x){
        show_bytes((byte_pointer) &x, sizeof(int));
    }

    int main(){
      
      int x = 12345;
      show_int(x);     // 输出结果为: 39 30 00 00, 说明我的使用小端法的机器
      
      const char *s = "abcd";
      show_bytes((byte_pointer) s, strlen(s)); // 使用 gcc 需要 -std=c99 选项, 结果 61 62 63 64
      
      return 0;
    }
    ```

+   十进制数字 x 的 ASCII 码正好是 `0x3x`; 而终止字节的十六进制表示为 `0x00`.

+   使用 `man ascii` 可以得到一张 ascii 字符码表.

+   计算机系统的一个基本概念就是从机器的角度来看, 程序仅仅只是字节序列. 不同的机器类型使用不同的且不兼容的指令和编码方式, 即使是完全一样的进程运行在不同的操作系统上也会有不同的编码规则, 因此二进制代码是不兼容的.

+   掩码运算: 表达式 `~0` 将生成一个全 1 的掩码, 不管机器的字大小是多少. 尽管对于一个 32 位的机器来说, 同样的掩码可以写成 `0xFFFFFFFF`, 但是这样的代码不是可移植的.

+   逻辑运算 `||`, `&&`, `!` 容易与位级运算混淆, 但它们的功能完全不同:

    +   逻辑运算认为所有非零的参数都表示 TRUE, 而参数 0 表示 FALSE. 它们返回 1 (0x01) 或者 0 (0x00) 分别表示 TRUE 或 False.
    +   逻辑运算符 `&&` 和 `||` 与对应的位级运算 `&` 和 `|` 之间第二个重要区别是, 如果对第一个参数求值就能确定表达式的结果, 那么逻辑运算符就不会对第二个参数求值, 因此表达式 `a && 5/a` 将不会造成被零除, 而表达式 `p && *p++` 也不会导致间接引用空指针.

+   C 语言中的移位运算

    +   `x << k`: 表示 x 向左移动 k 位, 丢弃最高的 k 位, 并在右端补 k 个 0. 移位量应该是一个 `0 ~ n - 1` 之间的值 (x 有 n 位). 移位运算是从左至右可结合的, `x << j << k` 等价于 `(x << j) << k`.
    +   而右移运算 `x >> k` 行为有点微妙, 一般而言机器支持两种形式的右移: 逻辑右移和算术右移
        +   逻辑右移: 左端补上 k 个 0; 比如 [10011100], k 为 4 时, 结果为 [00001001]
        +   算术右移: 左端补上 k 个最高有效位的值; 比如 [10011100], k 为 4 时, 结果为 [11111001], 这种做法对有符号整数数据的运算非常有用.
    +   对于无符号数据, 右移必须是逻辑的. 而对于有符号数据, 算术的或者逻辑的右移都可以, 虽然这意味着这可能存在潜在的可移植性的问题, 然而, 实际上几乎所有的编译器/机器组合都对有符号数据使用算术右移, 并且许多程序员也都假设机器会使用这种右移.
        +   移动 k 位, 但是 k 很大时, 实际上的位移量就是通过计算 `k mod w` 得到的. (C 语言中的移位数量应该保持小于字长)

+   整数表示

    +   C 语言支持多种整型数据类型 -- 表示有限范围的整数. 每种类型都能用关键字 (char, short, long 或者 long long) 来指定大小. 注意取值范围是不对称的, 负数的范围比正数的范围大 1.



### 第二章习题

+   习题 2.10: 对于位向量 a, 有 `a^a = 0` 这个性质 (`^` 表示异或), 因此下面的程序:

    ```c
    void inplace_swap(int *x, int *y){ // 假设 *x 与 *y 中分别为 a, b
        *y = *x ^ *y;  // *y 的结果为 (a ^ b)
        *x = *x ^ *y;  // *x 的结果为 a ^ (a ^ b) = b (利用性质)
        *y = *x ^ *y;  // *y 的结果为 b ^ (a ^ b) = a
    }
    // 因此达到交换两个值的目的
    ```

+   习题 2.11: 该题利用 2.10 中的函数写了一个将数组中元素头尾两端依次对调的函数:

    ```c
    void reverse_array(int a[], int cnt){
        int first, last;
        for(first = 0, last = cnt - 1;
            first <= last;       // 注意这一行
            first++, last--){
            inplace_swap(&a[first], &a[last]);
        }
    }
    ```

    如果使用题目中的函数, 那么对于包含偶数长度的数组能正确工作, 但是当数组的长度为奇数时, 它就会把中间的元素设置为 0: 比如对于 {1, 2, 3, 4, 5}, 结果为 {5, 4, 0, 2, 1}. 这是因为当长度为奇数时, 由于上面代码中使用 `first <= last`, 那么当处理中间这个元素时, `first == last`, 此时 `&a[first]` 和 `&a[last]` 是同一个地址, 那么在 `inplace_swap` 函数中, 第一行代码 `*y = *x ^ *y` 结果就是 `*y = 0`, 同时还必须注意到, 由于此时 `x` 和 `y` 是同一个地址, 所以 `*x` 也等于 0. 因此要解决这个问题只要令 `first < last` 即可.

+   习题 2.12: 写出下面变量 x 的 C 语言表达式, 代码应该对任何字长 $w \geq 8$ 都能正确工作. 同时给出了当 $x=0x87654321$ 以及 $w = 32$ 时表达式的求值结果供参考.

    +   A. x 的最低有效字节, 其他位均为零 [0x00000021] : `x & 0xFF`

    +   除了 x 的最低有效字节外, 其他位都取补, 最低有效字节保持不变. [0x789ABC21]

        ```c
        // 我的测试代码
        // 虽然答案是一样的, 但是为何结果...太麻烦~
        #include <stdio.h>

        int main(){
          
          int x = 0x87654321;
          printf("%x\n", x);
          x = (~(x & ~0xFF) & ~0xFF) | (x & 0xFF);
          printf("%x\n", x);
          return 0;
        }

        // 输出结果为 0x789ABC21
        // 我的考虑是首先 x 可以表示为 x = (x & ~0xFF) | (x & 0xFF)
        // 那么要对最低有效字节外, 对其他位取补, 那么 ~(x & ~0xFF) 还有将最低位置 0, 
        // 因此还需要加上 & ~0xFF
        ```

    +   x 的最低有效字节设置为 1, 其他字节保持不变 [0x876543FF]: `x | 0xFF`

+   习题 2.15: 只使用位级和逻辑运算, 编写一个 C 表达式, 它等价于 `x == y`, 换句话说, 当 x 和 y 相等时它返回 1, 否则就返回 0.

    ```c
    !(x ^ y)
      
    // 当 x 和 y 相等时, x ^ y 的结果为 0
    ```

    ​

    ​

















