# 链接

## 2017 年 12 月 27 日

+ 注意本地链接器符号和本地程序变量是不同的. (本地程序变量就是函数中的局部变量)

  .symtab 中的符号表不包括对应于本地非静态程序变量的任何符号. 这些符号在运行时在栈中被管理, 链接器对此类符号不感兴趣. 另外, 定义为带有 C static 属性的局部变量是不在栈中管理的. 相反, 编译器在 .data 或 .bss(Block Storage Start 或 Better Save Space, 因为他们不占用磁盘空间, 可以直接加载到内存中, 默认初始化为 0) 中为每个定义分配空间, 并在符号表中创建一个有唯一名字的本地链接器符号. 

  这个时候就会想到, 如果我在两个不同的函数中定义了名字相同的 static 局部变量, 那编译器会如何处理? 在这种情况, 编译器向汇编器输出两个不同名字的局部链接器符号, 比如 x.1 与 x.2.

+ 利用 static 属性隐藏变量和函数名字, (就像 public 和 private 一样), 任何带有 static 属性声明的全局变量或者函数都是模块私有的, 而任何不带 static 属性声明的全局变量和函数都是公有的, 可以被其他模块访问. 尽可能用 static 属性来保护你的变量很函数是很好的编程习惯.

+ C++ 和 Java 都允许重载方法, 这些方法在源代码中有相同的名字, 却有不同的参数列表. 那么链接器是如何区别这些不同的重载函数之间的差异呢? C++ 和 Java 中能使用重载函数, 是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字. 这种编码的过程叫做 mangling (重整), 而相反的过程叫做 demangling (恢复).

+ C++ 和 Java 使用兼容的重整策略. 一个被重整的类名字是由名字中字符的整数数量, 后面跟原始名字组成的. 比如, 类 Foo 被编码成 3Foo. 方法被编码成原始方法名, 后面加上双下划线 `__`, 加上被重整的类名, 在加上每个参数的单字母编码. 比如, `Foo::bar(int, long)` 被编码成 `bar__3Fooil`. mangling 全局变量和模板名字的策略是相似的.

+ 静态库: 所有的编译系统都提供一种机制, 将所有相关的目标模块打包成为一个单独的文件, 成为静态库.(static library) 它可以用作链接器的输入. 当链接器构造一个输出的可执行文件时, 它只复制静态库里被应用程序引用的目标模块.

  另外, 注意到, 在链接的时候, 比如使用 `gcc main.c`, 我们并没有显式的链接 `libc.a` 与 `libm.a`(定义了一些数学运算), 这是因为 C 编译器驱动程序总是传送 `libc.a` 给链接器, 所以就不必写成 `gcc main.c /usr/lib/libc.a`.

  在 Linux 系统中, 静态库是以一种称为 archive(存档) 的特殊文件格式存放在磁盘上的. 存档文件是一组连接起来的可重定位目标文件的集合, 有一个头部用来描述每个成员目标文件的大小和位置. 存档文件名由后缀 `.a` 标识.

+ 在符号解析阶段, 链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件.(注意: 驱动程序自动将命令行中所有的 .c 文件翻译为 .o 文件)

  链接器使用的算法会导致一些令人困扰的链接时错误, 因为命令行上的库和目标文件的顺序非常重要, 在命令行中, 如果定义了一个符号的库出现在引用这个符号的目标文件之前, 那么引用就不能被解析, 链接会失败.

+ 关于库的一般准则是将它们放在命令行的结尾. 如果库不是相互独立的, 那么必须对它们进行排序. 另外, 如果需要满足依赖需求, 可以在命令行上重复库.

+ 加载可执行目标文件, 比如在 shell 中执行 `./prog`, 因为 prog 不是一个内置的 shell 命令, 所以 shell 会认为 prog 是一个可执行目标文件, 通过调用某个驻留在存储器中称为加载器(loader)的操作系统代码来运行它. 任何 linux 程序都可以通过调用 execve 函数来调用加载器. 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中, 然后通过跳转到程序的第一条指令或入口点来运行该程序. 这个将程序复制到内存并运行的过程叫做加载. (代码段总是从地址 0x400000 处开始, 后面是数据段. 运行时堆在数据段之后. 堆后面的区域是为共享模块保留的. 用户栈总是从最大的合法用户地址 ($2^{48} - 1$) 开始, 向较小内存地址增长. 栈上面的区域, 从地址 $2^{48}$ 开始, 是为内核中的代码和数据保留的, 所谓内核就是操作系统驻留在内存的部分.)

+ 另外注意代码段和数据段之间是有间隙的, 因为 `.data` 段有对齐要求. 同时, 在分配栈, 共享库和堆段运行时地址的时候, 链接器还会使用地址空间布局随机化(ASLR, 参见 3.10.4 节). 虽然每次程序运行时这些区域的地址都会改变, 它们的相对位置是不变的.

+ 当加载器运行时, 它创建类似图 7-15 所示的内存映像. 在程序头部表的引导下, 加载器将可执行文件的片 (chunk) 复制到代码段和数据段. 接下来, 加载器跳转到程序的入口点, 也就是 `_start` 函数的地址, 这个函数是在系统目标文件 `ctrl.o` 中定义的, 对所有的 C 程序都是一样的. `_start` 函数调用系统启动函数 `__libc_start_main`, 该函数定义在 `libc.so` 中. 它初始化执行环境, 调用用户层的 main 函数, 处理 main 函数的返回值, 并且在需要的时候把控制返回给内核.

+ 动态链接是由一个叫做动态链接器的程序来执行的.

+ 书上的一个生成共享库 libvector.so 的例子:

  ```bash
  gcc -shared -fpic -o libvector.so addvec.c multvec.c
  ```

  `-fpic` 选项指示编译器生成与位置无关的代码, `-shared` 选项指示链接器创建一个共享的目标文件. 一旦创建了这个库, 随后就要将它链接到程序中. 使得程序能在执行时, 动态完成链接过程. 注意, 在创建可执行文件时, 并没有将任何 libvector.so 中的代码和数据节真的复制到可执行文件中, 而是链接器复制了一些重定位和符号表信息, 它们使得运行时可以解析对 libvector.so 中代码和数据的引用.

  注意, 当加载器运行使用动态链接生成的可执行文件时, 它不会先将控制传递给应用, 而是加载和运行动态链接器(注意动态链接器本事就是一个共享目标, 如在 linux 系统上的 ld-linux.so). 动态链接器通过执行各种重定位来完成链接任务.

+ **7.11 从应用程序中加载和链接共享库** 这一节的内容可以用来解释 Python 中的 import 可以导入 .so 的共享库文件的原理. (如 dlopen 系统函数)

+ 位置无关的代码: **可以加载而无需重定位的代码称为位置无关代码(Position-Independent Code, PIC)**. 用户对 GCC 使用 -fpic 选项指示编译系统生成 PIC 代码. 共享库的编译必须总是使用该选项.

+ 库打桩技术(library interpositioning)

  编译时打桩需要能够访问程序的源代码, 链接时打桩需要能够访问程序的可重定位对象文件, 基于动态链接器的 `LD_PRELOAD` 环境变量的机制能够在运行时打桩, 它只需要能够访问可执行目标文件. 动态链接器会先搜索 `LD_PRELOAD` 库, 然后才搜索任何其他的库. 有了这个机制, 当你加载和执行任意可执行文件时, 可以对任何共享库中的任何函数打桩, 包括 libc.so.