# 链接

## 2017 年 12 月 27 日

+ 注意本地链接器符号和本地程序变量是不同的. (本地程序变量就是函数中的局部变量)

  .symtab 中的符号表不包括对应于本地非静态程序变量的任何符号. 这些符号在运行时在栈中被管理, 链接器对此类符号不感兴趣. 另外, 定义为带有 C static 属性的局部变量是不在栈中管理的. 相反, 编译器在 .data 或 .bss(Block Storage Start 或 Better Save Space, 因为他们不占用磁盘空间, 可以直接加载到内存中, 默认初始化为 0) 中为每个定义分配空间, 并在符号表中创建一个有唯一名字的本地链接器符号. 

  这个时候就会想到, 如果我在两个不同的函数中定义了名字相同的 static 局部变量, 那编译器会如何处理? 在这种情况, 编译器向汇编器输出两个不同名字的局部链接器符号, 比如 x.1 与 x.2.

+ 利用 static 属性隐藏变量和函数名字, (就像 public 和 private 一样), 任何带有 static 属性声明的全局变量或者函数都是模块私有的, 而任何不带 static 属性声明的全局变量和函数都是公有的, 可以被其他模块访问. 尽可能用 static 属性来保护你的变量很函数是很好的编程习惯.

+ C++ 和 Java 都允许重载方法, 这些方法在源代码中有相同的名字, 却有不同的参数列表. 那么链接器是如何区别这些不同的重载函数之间的差异呢? C++ 和 Java 中能使用重载函数, 是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字. 这种编码的过程叫做 mangling (重整), 而相反的过程叫做 demangling (恢复).

+ C++ 和 Java 使用兼容的重整策略. 一个被重整的类名字是由名字中字符的整数数量, 后面跟原始名字组成的. 比如, 类 Foo 被编码成 3Foo. 方法被编码成原始方法名, 后面加上双下划线 `__`, 加上被重整的类名, 在加上每个参数的单字母编码. 比如, `Foo::bar(int, long)` 被编码成 `bar__3Fooil`. mangling 全局变量和模板名字的策略是相似的.

+ 静态库: 所有的编译系统都提供一种机制, 将所有相关的目标模块打包成为一个单独的文件, 成为静态库.(static library) 它可以用作链接器的输入. 当链接器构造一个输出的可执行文件时, 它只复制静态库里被应用程序引用的目标模块.

  另外, 注意到, 在链接的时候, 比如使用 `gcc main.c`, 我们并没有显式的链接 `libc.a` 与 `libm.a`(定义了一些数学运算), 这是因为 C 编译器驱动程序总是传送 `libc.a` 给链接器, 所以就不必写成 `gcc main.c /usr/lib/libc.a`.

  在 Linux 系统中, 静态库是以一种称为 archive(存档) 的特殊文件格式存放在磁盘上的. 存档文件是一组连接起来的可重定位目标文件的集合, 有一个头部用来描述每个成员目标文件的大小和位置. 存档文件名由后缀 `.a` 标识.